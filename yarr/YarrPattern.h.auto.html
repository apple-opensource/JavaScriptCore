<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>YarrPattern.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">YarrPattern.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (C) 2009 Apple Inc. All rights reserved.
 * Copyright (C) 2010 Peter Varga (<a href="mailto:pvarga@inf.u-szeged.hu">pvarga@inf.u-szeged.hu</a>), University of Szeged
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YarrPattern_h</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YarrPattern_h</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;runtime/UString.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/CheckedArithmetic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/RefCounted.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/Vector.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/unicode/Unicode.h&gt;</span>

namespace JSC { namespace Yarr {

<span class="enscript-type">struct</span> PatternDisjunction;

<span class="enscript-type">struct</span> CharacterRange {
    UChar begin;
    UChar end;

    CharacterRange(UChar begin, UChar end)
        : begin(begin)
        , end(end)
    {
    }
};

<span class="enscript-type">struct</span> CharacterClassTable : RefCounted&lt;CharacterClassTable&gt; {
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>* m_table;
    bool m_inverted;
    <span class="enscript-type">static</span> PassRefPtr&lt;CharacterClassTable&gt; create(<span class="enscript-type">const</span> <span class="enscript-type">char</span>* table, bool inverted)
    {
        <span class="enscript-keyword">return</span> adoptRef(new CharacterClassTable(table, inverted));
    }

<span class="enscript-reference">private</span>:
    CharacterClassTable(<span class="enscript-type">const</span> <span class="enscript-type">char</span>* table, bool inverted)
        : m_table(table)
        , m_inverted(inverted)
    {
    }
};

<span class="enscript-type">struct</span> CharacterClass {
    WTF_MAKE_FAST_ALLOCATED;
<span class="enscript-reference">public</span>:
    <span class="enscript-comment">// All CharacterClass instances have to have the full set of matches and ranges,
</span>    <span class="enscript-comment">// they may have an optional table for faster lookups (which must match the
</span>    <span class="enscript-comment">// specified matches and ranges)
</span>    CharacterClass(PassRefPtr&lt;CharacterClassTable&gt; table)
        : m_table(table)
    {
    }
    Vector&lt;UChar&gt; m_matches;
    Vector&lt;CharacterRange&gt; m_ranges;
    Vector&lt;UChar&gt; m_matchesUnicode;
    Vector&lt;CharacterRange&gt; m_rangesUnicode;
    RefPtr&lt;CharacterClassTable&gt; m_table;
};

<span class="enscript-type">enum</span> QuantifierType {
    QuantifierFixedCount,
    QuantifierGreedy,
    QuantifierNonGreedy,
};

<span class="enscript-type">struct</span> PatternTerm {
    <span class="enscript-type">enum</span> Type {
        TypeAssertionBOL,
        TypeAssertionEOL,
        TypeAssertionWordBoundary,
        TypePatternCharacter,
        TypeCharacterClass,
        TypeBackReference,
        TypeForwardReference,
        TypeParenthesesSubpattern,
        TypeParentheticalAssertion,
        TypeDotStarEnclosure,
    } type;
    bool m_capture :1;
    bool m_invert :1;
    <span class="enscript-type">union</span> {
        UChar patternCharacter;
        CharacterClass* characterClass;
        <span class="enscript-type">unsigned</span> backReferenceSubpatternId;
        <span class="enscript-type">struct</span> {
            PatternDisjunction* disjunction;
            <span class="enscript-type">unsigned</span> subpatternId;
            <span class="enscript-type">unsigned</span> lastSubpatternId;
            bool isCopy;
            bool isTerminal;
        } parentheses;
        <span class="enscript-type">struct</span> {
            bool bolAnchor : 1;
            bool eolAnchor : 1;
        } anchors;
    };
    QuantifierType quantityType;
    Checked&lt;<span class="enscript-type">unsigned</span>&gt; quantityCount;
    <span class="enscript-type">int</span> inputPosition;
    <span class="enscript-type">unsigned</span> frameLocation;

    PatternTerm(UChar ch)
        : type(PatternTerm::TypePatternCharacter)
        , m_capture(false)
        , m_invert(false)
    {
        patternCharacter = ch;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    PatternTerm(CharacterClass* charClass, bool invert)
        : type(PatternTerm::TypeCharacterClass)
        , m_capture(false)
        , m_invert(invert)
    {
        characterClass = charClass;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    PatternTerm(Type type, <span class="enscript-type">unsigned</span> subpatternId, PatternDisjunction* disjunction, bool capture = false, bool invert = false)
        : type(type)
        , m_capture(capture)
        , m_invert(invert)
    {
        parentheses.disjunction = disjunction;
        parentheses.subpatternId = subpatternId;
        parentheses.isCopy = false;
        parentheses.isTerminal = false;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }
    
    PatternTerm(Type type, bool invert = false)
        : type(type)
        , m_capture(false)
        , m_invert(invert)
    {
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    PatternTerm(<span class="enscript-type">unsigned</span> spatternId)
        : type(TypeBackReference)
        , m_capture(false)
        , m_invert(false)
    {
        backReferenceSubpatternId = spatternId;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }

    PatternTerm(bool bolAnchor, bool eolAnchor)
        : type(TypeDotStarEnclosure)
        , m_capture(false)
        , m_invert(false)
    {
        anchors.bolAnchor = bolAnchor;
        anchors.eolAnchor = eolAnchor;
        quantityType = QuantifierFixedCount;
        quantityCount = 1;
    }
    
    <span class="enscript-type">static</span> PatternTerm ForwardReference()
    {
        <span class="enscript-keyword">return</span> PatternTerm(TypeForwardReference);
    }

    <span class="enscript-type">static</span> PatternTerm BOL()
    {
        <span class="enscript-keyword">return</span> PatternTerm(TypeAssertionBOL);
    }

    <span class="enscript-type">static</span> PatternTerm EOL()
    {
        <span class="enscript-keyword">return</span> PatternTerm(TypeAssertionEOL);
    }

    <span class="enscript-type">static</span> PatternTerm WordBoundary(bool invert)
    {
        <span class="enscript-keyword">return</span> PatternTerm(TypeAssertionWordBoundary, invert);
    }
    
    bool invert()
    {
        <span class="enscript-keyword">return</span> m_invert;
    }

    bool capture()
    {
        <span class="enscript-keyword">return</span> m_capture;
    }
    
    <span class="enscript-type">void</span> quantify(<span class="enscript-type">unsigned</span> count, QuantifierType type)
    {
        quantityCount = count;
        quantityType = type;
    }
};

<span class="enscript-type">struct</span> PatternAlternative {
    WTF_MAKE_FAST_ALLOCATED;
<span class="enscript-reference">public</span>:
    PatternAlternative(PatternDisjunction* disjunction)
        : m_parent(disjunction)
        , m_onceThrough(false)
        , m_hasFixedSize(false)
        , m_startsWithBOL(false)
        , m_containsBOL(false)
    {
    }

    PatternTerm&amp; lastTerm()
    {
        ASSERT(m_terms.size());
        <span class="enscript-keyword">return</span> m_terms[m_terms.size() - 1];
    }
    
    <span class="enscript-type">void</span> removeLastTerm()
    {
        ASSERT(m_terms.size());
        m_terms.shrink(m_terms.size() - 1);
    }
    
    <span class="enscript-type">void</span> setOnceThrough()
    {
        m_onceThrough = true;
    }
    
    bool onceThrough()
    {
        <span class="enscript-keyword">return</span> m_onceThrough;
    }

    Vector&lt;PatternTerm&gt; m_terms;
    PatternDisjunction* m_parent;
    <span class="enscript-type">unsigned</span> m_minimumSize;
    bool m_onceThrough : 1;
    bool m_hasFixedSize : 1;
    bool m_startsWithBOL : 1;
    bool m_containsBOL : 1;
};

<span class="enscript-type">struct</span> PatternDisjunction {
    WTF_MAKE_FAST_ALLOCATED;
<span class="enscript-reference">public</span>:
    PatternDisjunction(PatternAlternative* parent = 0)
        : m_parent(parent)
        , m_hasFixedSize(false)
    {
    }
    
    ~PatternDisjunction()
    {
        deleteAllValues(m_alternatives);
    }

    PatternAlternative* addNewAlternative()
    {
        PatternAlternative* alternative = new PatternAlternative(this);
        m_alternatives.append(alternative);
        <span class="enscript-keyword">return</span> alternative;
    }

    Vector&lt;PatternAlternative*&gt; m_alternatives;
    PatternAlternative* m_parent;
    <span class="enscript-type">unsigned</span> m_minimumSize;
    <span class="enscript-type">unsigned</span> m_callFrameSize;
    bool m_hasFixedSize;
};

<span class="enscript-comment">// You probably don't want to be calling these functions directly
</span><span class="enscript-comment">// (please to be calling newlineCharacterClass() et al on your
</span><span class="enscript-comment">// friendly neighborhood YarrPattern instance to get nicely
</span><span class="enscript-comment">// cached copies).
</span>CharacterClass* <span class="enscript-function-name">newlineCreate</span>();
CharacterClass* <span class="enscript-function-name">digitsCreate</span>();
CharacterClass* <span class="enscript-function-name">spacesCreate</span>();
CharacterClass* <span class="enscript-function-name">wordcharCreate</span>();
CharacterClass* <span class="enscript-function-name">nondigitsCreate</span>();
CharacterClass* <span class="enscript-function-name">nonspacesCreate</span>();
CharacterClass* <span class="enscript-function-name">nonwordcharCreate</span>();

<span class="enscript-type">struct</span> TermChain {
    TermChain(PatternTerm term)
        : term(term)
    {}

    PatternTerm term;
    Vector&lt;TermChain&gt; hotTerms;
};

<span class="enscript-type">struct</span> YarrPattern {
    JS_EXPORT_PRIVATE YarrPattern(<span class="enscript-type">const</span> UString&amp; pattern, bool ignoreCase, bool multiline, <span class="enscript-type">const</span> <span class="enscript-type">char</span>** error);

    ~YarrPattern()
    {
        deleteAllValues(m_disjunctions);
        deleteAllValues(m_userCharacterClasses);
    }

    <span class="enscript-type">void</span> reset()
    {
        m_numSubpatterns = 0;
        m_maxBackReference = 0;

        m_containsBackreferences = false;
        m_containsBOL = false;

        newlineCached = 0;
        digitsCached = 0;
        spacesCached = 0;
        wordcharCached = 0;
        nondigitsCached = 0;
        nonspacesCached = 0;
        nonwordcharCached = 0;

        deleteAllValues(m_disjunctions);
        m_disjunctions.clear();
        deleteAllValues(m_userCharacterClasses);
        m_userCharacterClasses.clear();
    }

    bool containsIllegalBackReference()
    {
        <span class="enscript-keyword">return</span> m_maxBackReference &gt; m_numSubpatterns;
    }

    CharacterClass* newlineCharacterClass()
    {
        <span class="enscript-keyword">if</span> (!newlineCached)
            m_userCharacterClasses.append(newlineCached = newlineCreate());
        <span class="enscript-keyword">return</span> newlineCached;
    }
    CharacterClass* digitsCharacterClass()
    {
        <span class="enscript-keyword">if</span> (!digitsCached)
            m_userCharacterClasses.append(digitsCached = digitsCreate());
        <span class="enscript-keyword">return</span> digitsCached;
    }
    CharacterClass* spacesCharacterClass()
    {
        <span class="enscript-keyword">if</span> (!spacesCached)
            m_userCharacterClasses.append(spacesCached = spacesCreate());
        <span class="enscript-keyword">return</span> spacesCached;
    }
    CharacterClass* wordcharCharacterClass()
    {
        <span class="enscript-keyword">if</span> (!wordcharCached)
            m_userCharacterClasses.append(wordcharCached = wordcharCreate());
        <span class="enscript-keyword">return</span> wordcharCached;
    }
    CharacterClass* nondigitsCharacterClass()
    {
        <span class="enscript-keyword">if</span> (!nondigitsCached)
            m_userCharacterClasses.append(nondigitsCached = nondigitsCreate());
        <span class="enscript-keyword">return</span> nondigitsCached;
    }
    CharacterClass* nonspacesCharacterClass()
    {
        <span class="enscript-keyword">if</span> (!nonspacesCached)
            m_userCharacterClasses.append(nonspacesCached = nonspacesCreate());
        <span class="enscript-keyword">return</span> nonspacesCached;
    }
    CharacterClass* nonwordcharCharacterClass()
    {
        <span class="enscript-keyword">if</span> (!nonwordcharCached)
            m_userCharacterClasses.append(nonwordcharCached = nonwordcharCreate());
        <span class="enscript-keyword">return</span> nonwordcharCached;
    }

    bool m_ignoreCase : 1;
    bool m_multiline : 1;
    bool m_containsBackreferences : 1;
    bool m_containsBOL : 1;
    <span class="enscript-type">unsigned</span> m_numSubpatterns;
    <span class="enscript-type">unsigned</span> m_maxBackReference;
    PatternDisjunction* m_body;
    Vector&lt;PatternDisjunction*, 4&gt; m_disjunctions;
    Vector&lt;CharacterClass*&gt; m_userCharacterClasses;

<span class="enscript-reference">private</span>:
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>* compile(<span class="enscript-type">const</span> UString&amp; patternString);

    CharacterClass* newlineCached;
    CharacterClass* digitsCached;
    CharacterClass* spacesCached;
    CharacterClass* wordcharCached;
    CharacterClass* nondigitsCached;
    CharacterClass* nonspacesCached;
    CharacterClass* nonwordcharCached;
};

} } <span class="enscript-comment">// namespace JSC::Yarr
</span>
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">YarrPattern_h</span>
</pre>
<hr />
</body></html>