<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>YarrPattern.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">YarrPattern.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (C) 2009 Apple Inc. All rights reserved.
 * Copyright (C) 2010 Peter Varga (<a href="mailto:pvarga@inf.u-szeged.hu">pvarga@inf.u-szeged.hu</a>), University of Szeged
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;config.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;YarrPattern.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Yarr.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;YarrCanonicalizeUCS2.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;YarrParser.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/Vector.h&gt;</span>

using namespace WTF;

namespace JSC { namespace Yarr {

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;RegExpJitTables.h&quot;</span>

<span class="enscript-type">class</span> CharacterClassConstructor {
<span class="enscript-type">public</span>:
    CharacterClassConstructor(<span class="enscript-type">bool</span> isCaseInsensitive = false)
        : m_isCaseInsensitive(isCaseInsensitive)
    {
    }
    
    <span class="enscript-type">void</span> reset()
    {
        m_matches.clear();
        m_ranges.clear();
        m_matchesUnicode.clear();
        m_rangesUnicode.clear();
    }

    <span class="enscript-type">void</span> append(<span class="enscript-type">const</span> CharacterClass* other)
    {
        <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; other-&gt;m_matches.size(); ++i)
            addSorted(m_matches, other-&gt;m_matches[i]);
        <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; other-&gt;m_ranges.size(); ++i)
            addSortedRange(m_ranges, other-&gt;m_ranges[i].begin, other-&gt;m_ranges[i].end);
        <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; other-&gt;m_matchesUnicode.size(); ++i)
            addSorted(m_matchesUnicode, other-&gt;m_matchesUnicode[i]);
        <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; other-&gt;m_rangesUnicode.size(); ++i)
            addSortedRange(m_rangesUnicode, other-&gt;m_rangesUnicode[i].begin, other-&gt;m_rangesUnicode[i].end);
    }

    <span class="enscript-type">void</span> putChar(UChar ch)
    {
        <span class="enscript-comment">// Handle ascii cases.
</span>        <span class="enscript-keyword">if</span> (ch &lt;= 0x7f) {
            <span class="enscript-keyword">if</span> (m_isCaseInsensitive &amp;&amp; isASCIIAlpha(ch)) {
                addSorted(m_matches, toASCIIUpper(ch));
                addSorted(m_matches, toASCIILower(ch));
            } <span class="enscript-keyword">else</span>
                addSorted(m_matches, ch);
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// Simple case, not a case-insensitive match.
</span>        <span class="enscript-keyword">if</span> (!m_isCaseInsensitive) {
            addSorted(m_matchesUnicode, ch);
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// Add multiple matches, if necessary.
</span>        UCS2CanonicalizationRange* info = rangeInfoFor(ch);
        <span class="enscript-keyword">if</span> (info-&gt;type == CanonicalizeUnique)
            addSorted(m_matchesUnicode, ch);
        <span class="enscript-keyword">else</span>
            putUnicodeIgnoreCase(ch, info);
    }

    <span class="enscript-type">void</span> putUnicodeIgnoreCase(UChar ch, UCS2CanonicalizationRange* info)
    {
        ASSERT(m_isCaseInsensitive);
        ASSERT(ch &gt; 0x7f);
        ASSERT(ch &gt;= info-&gt;begin &amp;&amp; ch &lt;= info-&gt;end);
        ASSERT(info-&gt;type != CanonicalizeUnique);
        <span class="enscript-keyword">if</span> (info-&gt;type == CanonicalizeSet) {
            <span class="enscript-keyword">for</span> (uint16_t* set = characterSetInfo[info-&gt;value]; (ch = *set); ++set)
                addSorted(m_matchesUnicode, ch);
        } <span class="enscript-keyword">else</span> {
            addSorted(m_matchesUnicode, ch);
            addSorted(m_matchesUnicode, getCanonicalPair(info, ch));
        }
    }

    <span class="enscript-type">void</span> putRange(UChar lo, UChar hi)
    {
        <span class="enscript-keyword">if</span> (lo &lt;= 0x7f) {
            <span class="enscript-type">char</span> asciiLo = lo;
            <span class="enscript-type">char</span> asciiHi = std::min(hi, (UChar)0x7f);
            addSortedRange(m_ranges, lo, asciiHi);
            
            <span class="enscript-keyword">if</span> (m_isCaseInsensitive) {
                <span class="enscript-keyword">if</span> ((asciiLo &lt;= <span class="enscript-string">'Z'</span>) &amp;&amp; (asciiHi &gt;= <span class="enscript-string">'A'</span>))
                    addSortedRange(m_ranges, std::max(asciiLo, <span class="enscript-string">'A'</span>)+(<span class="enscript-string">'a'</span>-<span class="enscript-string">'A'</span>), std::min(asciiHi, <span class="enscript-string">'Z'</span>)+(<span class="enscript-string">'a'</span>-<span class="enscript-string">'A'</span>));
                <span class="enscript-keyword">if</span> ((asciiLo &lt;= <span class="enscript-string">'z'</span>) &amp;&amp; (asciiHi &gt;= <span class="enscript-string">'a'</span>))
                    addSortedRange(m_ranges, std::max(asciiLo, <span class="enscript-string">'a'</span>)+(<span class="enscript-string">'A'</span>-<span class="enscript-string">'a'</span>), std::min(asciiHi, <span class="enscript-string">'z'</span>)+(<span class="enscript-string">'A'</span>-<span class="enscript-string">'a'</span>));
            }
        }
        <span class="enscript-keyword">if</span> (hi &lt;= 0x7f)
            <span class="enscript-keyword">return</span>;

        lo = std::max(lo, (UChar)0x80);
        addSortedRange(m_rangesUnicode, lo, hi);
        
        <span class="enscript-keyword">if</span> (!m_isCaseInsensitive)
            <span class="enscript-keyword">return</span>;

        UCS2CanonicalizationRange* info = rangeInfoFor(lo);
        <span class="enscript-keyword">while</span> (true) {
            <span class="enscript-comment">// Handle the range [lo .. end]
</span>            UChar end = std::min&lt;UChar&gt;(info-&gt;end, hi);

            <span class="enscript-keyword">switch</span> (info-&gt;type) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">CanonicalizeUnique</span>:
                <span class="enscript-comment">// Nothing to do - no canonical equivalents.
</span>                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">CanonicalizeSet</span>: {
                UChar ch;
                <span class="enscript-keyword">for</span> (uint16_t* set = characterSetInfo[info-&gt;value]; (ch = *set); ++set)
                    addSorted(m_matchesUnicode, ch);
                <span class="enscript-keyword">break</span>;
            }
            <span class="enscript-keyword">case</span> <span class="enscript-reference">CanonicalizeRangeLo</span>:
                addSortedRange(m_rangesUnicode, lo + info-&gt;value, end + info-&gt;value);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">CanonicalizeRangeHi</span>:
                addSortedRange(m_rangesUnicode, lo - info-&gt;value, end - info-&gt;value);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">CanonicalizeAlternatingAligned</span>:
                <span class="enscript-comment">// Use addSortedRange since there is likely an abutting range to combine with.
</span>                <span class="enscript-keyword">if</span> (lo &amp; 1)
                    addSortedRange(m_rangesUnicode, lo - 1, lo - 1);
                <span class="enscript-keyword">if</span> (!(end &amp; 1))
                    addSortedRange(m_rangesUnicode, end + 1, end + 1);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">CanonicalizeAlternatingUnaligned</span>:
                <span class="enscript-comment">// Use addSortedRange since there is likely an abutting range to combine with.
</span>                <span class="enscript-keyword">if</span> (!(lo &amp; 1))
                    addSortedRange(m_rangesUnicode, lo - 1, lo - 1);
                <span class="enscript-keyword">if</span> (end &amp; 1)
                    addSortedRange(m_rangesUnicode, end + 1, end + 1);
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-keyword">if</span> (hi == end)
                <span class="enscript-keyword">return</span>;

            ++info;
            lo = info-&gt;begin;
        };

    }

    CharacterClass* charClass()
    {
        CharacterClass* characterClass = <span class="enscript-keyword">new</span> CharacterClass(0);

        characterClass-&gt;m_matches.swap(m_matches);
        characterClass-&gt;m_ranges.swap(m_ranges);
        characterClass-&gt;m_matchesUnicode.swap(m_matchesUnicode);
        characterClass-&gt;m_rangesUnicode.swap(m_rangesUnicode);

        <span class="enscript-keyword">return</span> characterClass;
    }

<span class="enscript-type">private</span>:
    <span class="enscript-type">void</span> addSorted(Vector&lt;UChar&gt;&amp; matches, UChar ch)
    {
        <span class="enscript-type">unsigned</span> pos = 0;
        <span class="enscript-type">unsigned</span> range = matches.size();

        <span class="enscript-comment">// binary chop, find position to insert char.
</span>        <span class="enscript-keyword">while</span> (range) {
            <span class="enscript-type">unsigned</span> index = range &gt;&gt; 1;

            <span class="enscript-type">int</span> val = matches[pos+index] - ch;
            <span class="enscript-keyword">if</span> (!val)
                <span class="enscript-keyword">return</span>;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (val &gt; 0)
                range = index;
            <span class="enscript-keyword">else</span> {
                pos += (index+1);
                range -= (index+1);
            }
        }
        
        <span class="enscript-keyword">if</span> (pos == matches.size())
            matches.append(ch);
        <span class="enscript-keyword">else</span>
            matches.insert(pos, ch);
    }

    <span class="enscript-type">void</span> addSortedRange(Vector&lt;CharacterRange&gt;&amp; ranges, UChar lo, UChar hi)
    {
        <span class="enscript-type">unsigned</span> end = ranges.size();
        
        <span class="enscript-comment">// Simple linear scan - I doubt there are that many ranges anyway...
</span>        <span class="enscript-comment">// feel free to fix this with something faster (eg binary chop).
</span>        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; end; ++i) {
            <span class="enscript-comment">// does the new range fall before the current position in the array
</span>            <span class="enscript-keyword">if</span> (hi &lt; ranges[i].begin) {
                <span class="enscript-comment">// optional optimization: concatenate appending ranges? - may not be worthwhile.
</span>                <span class="enscript-keyword">if</span> (hi == (ranges[i].begin - 1)) {
                    ranges[i].begin = lo;
                    <span class="enscript-keyword">return</span>;
                }
                ranges.insert(i, CharacterRange(lo, hi));
                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-comment">// Okay, since we didn't hit the last case, the end of the new range is definitely at or after the begining
</span>            <span class="enscript-comment">// If the new range start at or before the end of the last range, then the overlap (if it starts one after the
</span>            <span class="enscript-comment">// end of the last range they concatenate, which is just as good.
</span>            <span class="enscript-keyword">if</span> (lo &lt;= (ranges[i].end + 1)) {
                <span class="enscript-comment">// found an intersect! we'll replace this entry in the array.
</span>                ranges[i].begin = std::min(ranges[i].begin, lo);
                ranges[i].end = std::max(ranges[i].end, hi);

                <span class="enscript-comment">// now check if the new range can subsume any subsequent ranges.
</span>                <span class="enscript-type">unsigned</span> next = i+1;
                <span class="enscript-comment">// each iteration of the loop we will either remove something from the list, or break the loop.
</span>                <span class="enscript-keyword">while</span> (next &lt; ranges.size()) {
                    <span class="enscript-keyword">if</span> (ranges[next].begin &lt;= (ranges[i].end + 1)) {
                        <span class="enscript-comment">// the next entry now overlaps / concatenates this one.
</span>                        ranges[i].end = std::max(ranges[i].end, ranges[next].end);
                        ranges.remove(next);
                    } <span class="enscript-keyword">else</span>
                        <span class="enscript-keyword">break</span>;
                }
                
                <span class="enscript-keyword">return</span>;
            }
        }

        <span class="enscript-comment">// CharacterRange comes after all existing ranges.
</span>        ranges.append(CharacterRange(lo, hi));
    }

    <span class="enscript-type">bool</span> m_isCaseInsensitive;

    Vector&lt;UChar&gt; m_matches;
    Vector&lt;CharacterRange&gt; m_ranges;
    Vector&lt;UChar&gt; m_matchesUnicode;
    Vector&lt;CharacterRange&gt; m_rangesUnicode;
};

<span class="enscript-type">class</span> YarrPatternConstructor {
<span class="enscript-type">public</span>:
    YarrPatternConstructor(YarrPattern&amp; pattern)
        : m_pattern(pattern)
        , m_characterClassConstructor(pattern.m_ignoreCase)
        , m_invertParentheticalAssertion(false)
    {
        m_pattern.m_body = <span class="enscript-keyword">new</span> PatternDisjunction();
        m_alternative = m_pattern.m_body-&gt;addNewAlternative();
        m_pattern.m_disjunctions.append(m_pattern.m_body);
    }

    ~YarrPatternConstructor()
    {
    }

    <span class="enscript-type">void</span> reset()
    {
        m_pattern.reset();
        m_characterClassConstructor.reset();

        m_pattern.m_body = <span class="enscript-keyword">new</span> PatternDisjunction();
        m_alternative = m_pattern.m_body-&gt;addNewAlternative();
        m_pattern.m_disjunctions.append(m_pattern.m_body);
    }
    
    <span class="enscript-type">void</span> assertionBOL()
    {
        <span class="enscript-keyword">if</span> (!m_alternative-&gt;m_terms.size() &amp; !m_invertParentheticalAssertion) {
            m_alternative-&gt;m_startsWithBOL = true;
            m_alternative-&gt;m_containsBOL = true;
            m_pattern.m_containsBOL = true;
        }
        m_alternative-&gt;m_terms.append(PatternTerm::BOL());
    }
    <span class="enscript-type">void</span> assertionEOL()
    {
        m_alternative-&gt;m_terms.append(PatternTerm::EOL());
    }
    <span class="enscript-type">void</span> assertionWordBoundary(<span class="enscript-type">bool</span> invert)
    {
        m_alternative-&gt;m_terms.append(PatternTerm::WordBoundary(invert));
    }

    <span class="enscript-type">void</span> atomPatternCharacter(UChar ch)
    {
        <span class="enscript-comment">// We handle case-insensitive checking of unicode characters which do have both
</span>        <span class="enscript-comment">// cases by handling them as if they were defined using a CharacterClass.
</span>        <span class="enscript-keyword">if</span> (!m_pattern.m_ignoreCase || isASCII(ch)) {
            m_alternative-&gt;m_terms.append(PatternTerm(ch));
            <span class="enscript-keyword">return</span>;
        }

        UCS2CanonicalizationRange* info = rangeInfoFor(ch);
        <span class="enscript-keyword">if</span> (info-&gt;type == CanonicalizeUnique) {
            m_alternative-&gt;m_terms.append(PatternTerm(ch));
            <span class="enscript-keyword">return</span>;
        }

        m_characterClassConstructor.putUnicodeIgnoreCase(ch, info);
        CharacterClass* newCharacterClass = m_characterClassConstructor.charClass();
        m_pattern.m_userCharacterClasses.append(newCharacterClass);
        m_alternative-&gt;m_terms.append(PatternTerm(newCharacterClass, false));
    }

    <span class="enscript-type">void</span> atomBuiltInCharacterClass(BuiltInCharacterClassID classID, <span class="enscript-type">bool</span> invert)
    {
        <span class="enscript-keyword">switch</span> (classID) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">DigitClassID</span>:
            m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.digitsCharacterClass(), invert));
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">SpaceClassID</span>:
            m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.spacesCharacterClass(), invert));
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">WordClassID</span>:
            m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.wordcharCharacterClass(), invert));
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">NewlineClassID</span>:
            m_alternative-&gt;m_terms.append(PatternTerm(m_pattern.newlineCharacterClass(), invert));
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-type">void</span> atomCharacterClassBegin(<span class="enscript-type">bool</span> invert = false)
    {
        m_invertCharacterClass = invert;
    }

    <span class="enscript-type">void</span> atomCharacterClassAtom(UChar ch)
    {
        m_characterClassConstructor.putChar(ch);
    }

    <span class="enscript-type">void</span> atomCharacterClassRange(UChar begin, UChar end)
    {
        m_characterClassConstructor.putRange(begin, end);
    }

    <span class="enscript-type">void</span> atomCharacterClassBuiltIn(BuiltInCharacterClassID classID, <span class="enscript-type">bool</span> invert)
    {
        ASSERT(classID != NewlineClassID);

        <span class="enscript-keyword">switch</span> (classID) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">DigitClassID</span>:
            m_characterClassConstructor.append(invert ? m_pattern.nondigitsCharacterClass() : m_pattern.digitsCharacterClass());
            <span class="enscript-keyword">break</span>;
        
        <span class="enscript-keyword">case</span> <span class="enscript-reference">SpaceClassID</span>:
            m_characterClassConstructor.append(invert ? m_pattern.nonspacesCharacterClass() : m_pattern.spacesCharacterClass());
            <span class="enscript-keyword">break</span>;
        
        <span class="enscript-keyword">case</span> <span class="enscript-reference">WordClassID</span>:
            m_characterClassConstructor.append(invert ? m_pattern.nonwordcharCharacterClass() : m_pattern.wordcharCharacterClass());
            <span class="enscript-keyword">break</span>;
        
        <span class="enscript-reference">default</span>:
            ASSERT_NOT_REACHED();
        }
    }

    <span class="enscript-type">void</span> atomCharacterClassEnd()
    {
        CharacterClass* newCharacterClass = m_characterClassConstructor.charClass();
        m_pattern.m_userCharacterClasses.append(newCharacterClass);
        m_alternative-&gt;m_terms.append(PatternTerm(newCharacterClass, m_invertCharacterClass));
    }

    <span class="enscript-type">void</span> atomParenthesesSubpatternBegin(<span class="enscript-type">bool</span> capture = true)
    {
        <span class="enscript-type">unsigned</span> subpatternId = m_pattern.m_numSubpatterns + 1;
        <span class="enscript-keyword">if</span> (capture)
            m_pattern.m_numSubpatterns++;

        PatternDisjunction* parenthesesDisjunction = <span class="enscript-keyword">new</span> PatternDisjunction(m_alternative);
        m_pattern.m_disjunctions.append(parenthesesDisjunction);
        m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParenthesesSubpattern, subpatternId, parenthesesDisjunction, capture, false));
        m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
    }

    <span class="enscript-type">void</span> atomParentheticalAssertionBegin(<span class="enscript-type">bool</span> invert = false)
    {
        PatternDisjunction* parenthesesDisjunction = <span class="enscript-keyword">new</span> PatternDisjunction(m_alternative);
        m_pattern.m_disjunctions.append(parenthesesDisjunction);
        m_alternative-&gt;m_terms.append(PatternTerm(PatternTerm::TypeParentheticalAssertion, m_pattern.m_numSubpatterns + 1, parenthesesDisjunction, false, invert));
        m_alternative = parenthesesDisjunction-&gt;addNewAlternative();
        m_invertParentheticalAssertion = invert;
    }

    <span class="enscript-type">void</span> atomParenthesesEnd()
    {
        ASSERT(m_alternative-&gt;m_parent);
        ASSERT(m_alternative-&gt;m_parent-&gt;m_parent);

        PatternDisjunction* parenthesesDisjunction = m_alternative-&gt;m_parent;
        m_alternative = m_alternative-&gt;m_parent-&gt;m_parent;

        PatternTerm&amp; lastTerm = m_alternative-&gt;lastTerm();

        <span class="enscript-type">unsigned</span> numParenAlternatives = parenthesesDisjunction-&gt;m_alternatives.size();
        <span class="enscript-type">unsigned</span> numBOLAnchoredAlts = 0;

        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; numParenAlternatives; i++) {
            <span class="enscript-comment">// Bubble up BOL flags
</span>            <span class="enscript-keyword">if</span> (parenthesesDisjunction-&gt;m_alternatives[i]-&gt;m_startsWithBOL)
                numBOLAnchoredAlts++;
        }

        <span class="enscript-keyword">if</span> (numBOLAnchoredAlts) {
            m_alternative-&gt;m_containsBOL = true;
            <span class="enscript-comment">// If all the alternatives in parens start with BOL, then so does this one
</span>            <span class="enscript-keyword">if</span> (numBOLAnchoredAlts == numParenAlternatives)
                m_alternative-&gt;m_startsWithBOL = true;
        }

        lastTerm.parentheses.lastSubpatternId = m_pattern.m_numSubpatterns;
        m_invertParentheticalAssertion = false;
    }

    <span class="enscript-type">void</span> atomBackReference(<span class="enscript-type">unsigned</span> subpatternId)
    {
        ASSERT(subpatternId);
        m_pattern.m_containsBackreferences = true;
        m_pattern.m_maxBackReference = std::max(m_pattern.m_maxBackReference, subpatternId);

        <span class="enscript-keyword">if</span> (subpatternId &gt; m_pattern.m_numSubpatterns) {
            m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
            <span class="enscript-keyword">return</span>;
        }

        PatternAlternative* currentAlternative = m_alternative;
        ASSERT(currentAlternative);

        <span class="enscript-comment">// Note to self: if we waited until the AST was baked, we could also remove forwards refs 
</span>        <span class="enscript-keyword">while</span> ((currentAlternative = currentAlternative-&gt;m_parent-&gt;m_parent)) {
            PatternTerm&amp; term = currentAlternative-&gt;lastTerm();
            ASSERT((term.type == PatternTerm::TypeParenthesesSubpattern) || (term.type == PatternTerm::TypeParentheticalAssertion));

            <span class="enscript-keyword">if</span> ((term.type == PatternTerm::TypeParenthesesSubpattern) &amp;&amp; term.capture() &amp;&amp; (subpatternId == term.parentheses.subpatternId)) {
                m_alternative-&gt;m_terms.append(PatternTerm::ForwardReference());
                <span class="enscript-keyword">return</span>;
            }
        }

        m_alternative-&gt;m_terms.append(PatternTerm(subpatternId));
    }

    <span class="enscript-comment">// deep copy the argument disjunction.  If filterStartsWithBOL is true, 
</span>    <span class="enscript-comment">// skip alternatives with m_startsWithBOL set true.
</span>    PatternDisjunction* copyDisjunction(PatternDisjunction* disjunction, <span class="enscript-type">bool</span> filterStartsWithBOL = false)
    {
        PatternDisjunction* newDisjunction = 0;
        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
            PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt];
            <span class="enscript-keyword">if</span> (!filterStartsWithBOL || !alternative-&gt;m_startsWithBOL) {
                <span class="enscript-keyword">if</span> (!newDisjunction) {
                    newDisjunction = <span class="enscript-keyword">new</span> PatternDisjunction();
                    newDisjunction-&gt;m_parent = disjunction-&gt;m_parent;
                }
                PatternAlternative* newAlternative = newDisjunction-&gt;addNewAlternative();
                <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; alternative-&gt;m_terms.size(); ++i)
                    newAlternative-&gt;m_terms.append(copyTerm(alternative-&gt;m_terms[i], filterStartsWithBOL));
            }
        }
        
        <span class="enscript-keyword">if</span> (newDisjunction)
            m_pattern.m_disjunctions.append(newDisjunction);
        <span class="enscript-keyword">return</span> newDisjunction;
    }
    
    PatternTerm copyTerm(PatternTerm&amp; term, <span class="enscript-type">bool</span> filterStartsWithBOL = false)
    {
        <span class="enscript-keyword">if</span> ((term.type != PatternTerm::TypeParenthesesSubpattern) &amp;&amp; (term.type != PatternTerm::TypeParentheticalAssertion))
            <span class="enscript-keyword">return</span> PatternTerm(term);
        
        PatternTerm termCopy = term;
        termCopy.parentheses.disjunction = copyDisjunction(termCopy.parentheses.disjunction, filterStartsWithBOL);
        <span class="enscript-keyword">return</span> termCopy;
    }
    
    <span class="enscript-type">void</span> quantifyAtom(<span class="enscript-type">unsigned</span> min, <span class="enscript-type">unsigned</span> max, <span class="enscript-type">bool</span> greedy)
    {
        ASSERT(min &lt;= max);
        ASSERT(m_alternative-&gt;m_terms.size());

        <span class="enscript-keyword">if</span> (!max) {
            m_alternative-&gt;removeLastTerm();
            <span class="enscript-keyword">return</span>;
        }

        PatternTerm&amp; term = m_alternative-&gt;lastTerm();
        ASSERT(term.type &gt; PatternTerm::TypeAssertionWordBoundary);
        ASSERT((term.quantityCount == 1) &amp;&amp; (term.quantityType == QuantifierFixedCount));

        <span class="enscript-keyword">if</span> (term.type == PatternTerm::TypeParentheticalAssertion) {
            <span class="enscript-comment">// If an assertion is quantified with a minimum count of zero, it can simply be removed.
</span>            <span class="enscript-comment">// This arises from the RepeatMatcher behaviour in the spec. Matching an assertion never
</span>            <span class="enscript-comment">// results in any input being consumed, however the continuation passed to the assertion
</span>            <span class="enscript-comment">// (called in steps, 8c and 9 of the RepeatMatcher definition, ES5.1 15.10.2.5) will
</span>            <span class="enscript-comment">// reject all zero length matches (see step 2.1). A match from the continuation of the
</span>            <span class="enscript-comment">// expression will still be accepted regardless (via steps 8a and 11) - the upshot of all
</span>            <span class="enscript-comment">// this is that matches from the assertion are not required, and won't be accepted anyway,
</span>            <span class="enscript-comment">// so no need to ever run it.
</span>            <span class="enscript-keyword">if</span> (!min)
                m_alternative-&gt;removeLastTerm();
            <span class="enscript-comment">// We never need to run an assertion more than once. Subsequent interations will be run
</span>            <span class="enscript-comment">// with the same start index (since assertions are non-capturing) and the same captures
</span>            <span class="enscript-comment">// (per step 4 of RepeatMatcher in ES5.1 15.10.2.5), and as such will always produce the
</span>            <span class="enscript-comment">// same result and captures. If the first match succeeds then the subsequent (min - 1)
</span>            <span class="enscript-comment">// matches will too. Any additional optional matches will fail (on the same basis as the
</span>            <span class="enscript-comment">// minimum zero quantified assertions, above), but this will still result in a match.
</span>            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-keyword">if</span> (min == 0)
            term.quantify(max, greedy   ? QuantifierGreedy : QuantifierNonGreedy);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (min == max)
            term.quantify(min, QuantifierFixedCount);
        <span class="enscript-keyword">else</span> {
            term.quantify(min, QuantifierFixedCount);
            m_alternative-&gt;m_terms.append(copyTerm(term));
            <span class="enscript-comment">// NOTE: this term is interesting from an analysis perspective, in that it can be ignored.....
</span>            m_alternative-&gt;lastTerm().quantify((max == quantifyInfinite) ? max : max - min, greedy ? QuantifierGreedy : QuantifierNonGreedy);
            <span class="enscript-keyword">if</span> (m_alternative-&gt;lastTerm().type == PatternTerm::TypeParenthesesSubpattern)
                m_alternative-&gt;lastTerm().parentheses.isCopy = true;
        }
    }

    <span class="enscript-type">void</span> disjunction()
    {
        m_alternative = m_alternative-&gt;m_parent-&gt;addNewAlternative();
    }

    <span class="enscript-type">unsigned</span> setupAlternativeOffsets(PatternAlternative* alternative, <span class="enscript-type">unsigned</span> currentCallFrameSize, <span class="enscript-type">unsigned</span> initialInputPosition)
    {
        alternative-&gt;m_hasFixedSize = true;
        Checked&lt;<span class="enscript-type">unsigned</span>&gt; currentInputPosition = initialInputPosition;

        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; alternative-&gt;m_terms.size(); ++i) {
            PatternTerm&amp; term = alternative-&gt;m_terms[i];

            <span class="enscript-keyword">switch</span> (term.type) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeAssertionBOL:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeAssertionEOL:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeAssertionWordBoundary:
                term.inputPosition = currentInputPosition.unsafeGet();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeBackReference:
                term.inputPosition = currentInputPosition.unsafeGet();
                term.frameLocation = currentCallFrameSize;
                currentCallFrameSize += YarrStackSpaceForBackTrackInfoBackReference;
                alternative-&gt;m_hasFixedSize = false;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeForwardReference:
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypePatternCharacter:
                term.inputPosition = currentInputPosition.unsafeGet();
                <span class="enscript-keyword">if</span> (term.quantityType != QuantifierFixedCount) {
                    term.frameLocation = currentCallFrameSize;
                    currentCallFrameSize += YarrStackSpaceForBackTrackInfoPatternCharacter;
                    alternative-&gt;m_hasFixedSize = false;
                } <span class="enscript-keyword">else</span>
                    currentInputPosition += term.quantityCount;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeCharacterClass:
                term.inputPosition = currentInputPosition.unsafeGet();
                <span class="enscript-keyword">if</span> (term.quantityType != QuantifierFixedCount) {
                    term.frameLocation = currentCallFrameSize;
                    currentCallFrameSize += YarrStackSpaceForBackTrackInfoCharacterClass;
                    alternative-&gt;m_hasFixedSize = false;
                } <span class="enscript-keyword">else</span>
                    currentInputPosition += term.quantityCount;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeParenthesesSubpattern:
                <span class="enscript-comment">// Note: for fixed once parentheses we will ensure at least the minimum is available; others are on their own.
</span>                term.frameLocation = currentCallFrameSize;
                <span class="enscript-keyword">if</span> (term.quantityCount == 1 &amp;&amp; !term.parentheses.isCopy) {
                    <span class="enscript-keyword">if</span> (term.quantityType != QuantifierFixedCount)
                        currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesOnce;
                    currentCallFrameSize = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet());
                    <span class="enscript-comment">// If quantity is fixed, then pre-check its minimum size.
</span>                    <span class="enscript-keyword">if</span> (term.quantityType == QuantifierFixedCount)
                        currentInputPosition += term.parentheses.disjunction-&gt;m_minimumSize;
                    term.inputPosition = currentInputPosition.unsafeGet();
                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (term.parentheses.isTerminal) {
                    currentCallFrameSize += YarrStackSpaceForBackTrackInfoParenthesesTerminal;
                    currentCallFrameSize = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize, currentInputPosition.unsafeGet());
                    term.inputPosition = currentInputPosition.unsafeGet();
                } <span class="enscript-keyword">else</span> {
                    term.inputPosition = currentInputPosition.unsafeGet();
                    setupDisjunctionOffsets(term.parentheses.disjunction, 0, currentInputPosition.unsafeGet());
                    currentCallFrameSize += YarrStackSpaceForBackTrackInfoParentheses;
                }
                <span class="enscript-comment">// Fixed count of 1 could be accepted, if they have a fixed size *AND* if all alternatives are of the same length.
</span>                alternative-&gt;m_hasFixedSize = false;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeParentheticalAssertion:
                term.inputPosition = currentInputPosition.unsafeGet();
                term.frameLocation = currentCallFrameSize;
                currentCallFrameSize = setupDisjunctionOffsets(term.parentheses.disjunction, currentCallFrameSize + YarrStackSpaceForBackTrackInfoParentheticalAssertion, currentInputPosition.unsafeGet());
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeDotStarEnclosure:
                alternative-&gt;m_hasFixedSize = false;
                term.inputPosition = initialInputPosition;
                <span class="enscript-keyword">break</span>;
            }
        }

        alternative-&gt;m_minimumSize = (currentInputPosition - initialInputPosition).unsafeGet();
        <span class="enscript-keyword">return</span> currentCallFrameSize;
    }

    <span class="enscript-type">unsigned</span> setupDisjunctionOffsets(PatternDisjunction* disjunction, <span class="enscript-type">unsigned</span> initialCallFrameSize, <span class="enscript-type">unsigned</span> initialInputPosition)
    {
        <span class="enscript-keyword">if</span> ((disjunction != m_pattern.m_body) &amp;&amp; (disjunction-&gt;m_alternatives.size() &gt; 1))
            initialCallFrameSize += YarrStackSpaceForBackTrackInfoAlternative;

        <span class="enscript-type">unsigned</span> minimumInputSize = UINT_MAX;
        <span class="enscript-type">unsigned</span> maximumCallFrameSize = 0;
        <span class="enscript-type">bool</span> hasFixedSize = true;

        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
            PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt];
            <span class="enscript-type">unsigned</span> currentAlternativeCallFrameSize = setupAlternativeOffsets(alternative, initialCallFrameSize, initialInputPosition);
            minimumInputSize = min(minimumInputSize, alternative-&gt;m_minimumSize);
            maximumCallFrameSize = max(maximumCallFrameSize, currentAlternativeCallFrameSize);
            hasFixedSize &amp;= alternative-&gt;m_hasFixedSize;
        }
        
        ASSERT(minimumInputSize != UINT_MAX);
        ASSERT(maximumCallFrameSize &gt;= initialCallFrameSize);

        disjunction-&gt;m_hasFixedSize = hasFixedSize;
        disjunction-&gt;m_minimumSize = minimumInputSize;
        disjunction-&gt;m_callFrameSize = maximumCallFrameSize;
        <span class="enscript-keyword">return</span> maximumCallFrameSize;
    }

    <span class="enscript-type">void</span> setupOffsets()
    {
        setupDisjunctionOffsets(m_pattern.m_body, 0, 0);
    }

    <span class="enscript-comment">// This optimization identifies sets of parentheses that we will never need to backtrack.
</span>    <span class="enscript-comment">// In these cases we do not need to store state from prior iterations.
</span>    <span class="enscript-comment">// We can presently avoid backtracking for:
</span>    <span class="enscript-comment">//   * where the parens are at the end of the regular expression (last term in any of the
</span>    <span class="enscript-comment">//     alternatives of the main body disjunction).
</span>    <span class="enscript-comment">//   * where the parens are non-capturing, and quantified unbounded greedy (*).
</span>    <span class="enscript-comment">//   * where the parens do not contain any capturing subpatterns.
</span>    <span class="enscript-type">void</span> checkForTerminalParentheses()
    {
        <span class="enscript-comment">// This check is much too crude; should be just checking whether the candidate
</span>        <span class="enscript-comment">// node contains nested capturing subpatterns, not the whole expression!
</span>        <span class="enscript-keyword">if</span> (m_pattern.m_numSubpatterns)
            <span class="enscript-keyword">return</span>;

        Vector&lt;PatternAlternative*&gt;&amp; alternatives = m_pattern.m_body-&gt;m_alternatives;
        <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; alternatives.size(); ++i) {
            Vector&lt;PatternTerm&gt;&amp; terms = alternatives[i]-&gt;m_terms;
            <span class="enscript-keyword">if</span> (terms.size()) {
                PatternTerm&amp; term = terms.last();
                <span class="enscript-keyword">if</span> (term.type == PatternTerm::TypeParenthesesSubpattern
                    &amp;&amp; term.quantityType == QuantifierGreedy
                    &amp;&amp; term.quantityCount == quantifyInfinite
                    &amp;&amp; !term.capture())
                    term.parentheses.isTerminal = true;
            }
        }
    }

    <span class="enscript-type">void</span> optimizeBOL()
    {
        <span class="enscript-comment">// Look for expressions containing beginning of line (^) anchoring and unroll them.
</span>        <span class="enscript-comment">// e.g. /^a|^b|c/ becomes /^a|^b|c/ which is executed once followed by /c/ which loops
</span>        <span class="enscript-comment">// This code relies on the parsing code tagging alternatives with m_containsBOL and
</span>        <span class="enscript-comment">// m_startsWithBOL and rolling those up to containing alternatives.
</span>        <span class="enscript-comment">// At this point, this is only valid for non-multiline expressions.
</span>        PatternDisjunction* disjunction = m_pattern.m_body;
        
        <span class="enscript-keyword">if</span> (!m_pattern.m_containsBOL || m_pattern.m_multiline)
            <span class="enscript-keyword">return</span>;
        
        PatternDisjunction* loopDisjunction = copyDisjunction(disjunction, true);

        <span class="enscript-comment">// Set alternatives in disjunction to &quot;onceThrough&quot;
</span>        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt)
            disjunction-&gt;m_alternatives[alt]-&gt;setOnceThrough();

        <span class="enscript-keyword">if</span> (loopDisjunction) {
            <span class="enscript-comment">// Move alternatives from loopDisjunction to disjunction
</span>            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> alt = 0; alt &lt; loopDisjunction-&gt;m_alternatives.size(); ++alt)
                disjunction-&gt;m_alternatives.append(loopDisjunction-&gt;m_alternatives[alt]);
                
            loopDisjunction-&gt;m_alternatives.clear();
        }
    }

    <span class="enscript-type">bool</span> containsCapturingTerms(PatternAlternative* alternative, size_t firstTermIndex, size_t lastTermIndex)
    {
        Vector&lt;PatternTerm&gt;&amp; terms = alternative-&gt;m_terms;

        <span class="enscript-keyword">for</span> (size_t termIndex = firstTermIndex; termIndex &lt;= lastTermIndex; ++termIndex) {
            PatternTerm&amp; term = terms[termIndex];

            <span class="enscript-keyword">if</span> (term.m_capture)
                <span class="enscript-keyword">return</span> true;

            <span class="enscript-keyword">if</span> (term.type == PatternTerm::TypeParenthesesSubpattern) {
                PatternDisjunction* nestedDisjunction = term.parentheses.disjunction;
                <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> alt = 0; alt &lt; nestedDisjunction-&gt;m_alternatives.size(); ++alt) {
                    <span class="enscript-keyword">if</span> (containsCapturingTerms(nestedDisjunction-&gt;m_alternatives[alt], 0, nestedDisjunction-&gt;m_alternatives[alt]-&gt;m_terms.size() - 1))
                        <span class="enscript-keyword">return</span> true;
                }
            }
        }

        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-comment">// This optimization identifies alternatives in the form of 
</span>    <span class="enscript-comment">// [^].*[?]&lt;expression&gt;.*[$] for expressions that don't have any 
</span>    <span class="enscript-comment">// capturing terms. The alternative is changed to &lt;expression&gt; 
</span>    <span class="enscript-comment">// followed by processing of the dot stars to find and adjust the 
</span>    <span class="enscript-comment">// beginning and the end of the match.
</span>    <span class="enscript-type">void</span> optimizeDotStarWrappedExpressions()
    {
        Vector&lt;PatternAlternative*&gt;&amp; alternatives = m_pattern.m_body-&gt;m_alternatives;
        <span class="enscript-keyword">if</span> (alternatives.size() != 1)
            <span class="enscript-keyword">return</span>;

        PatternAlternative* alternative = alternatives[0];
        Vector&lt;PatternTerm&gt;&amp; terms = alternative-&gt;m_terms;
        <span class="enscript-keyword">if</span> (terms.size() &gt;= 3) {
            <span class="enscript-type">bool</span> startsWithBOL = false;
            <span class="enscript-type">bool</span> endsWithEOL = false;
            size_t termIndex, firstExpressionTerm, lastExpressionTerm;

            termIndex = 0;
            <span class="enscript-keyword">if</span> (terms[termIndex].type == PatternTerm::TypeAssertionBOL) {
                startsWithBOL = true;
                ++termIndex;
            }
            
            PatternTerm&amp; firstNonAnchorTerm = terms[termIndex];
            <span class="enscript-keyword">if</span> ((firstNonAnchorTerm.type != PatternTerm::TypeCharacterClass) || (firstNonAnchorTerm.characterClass != m_pattern.newlineCharacterClass()) || !((firstNonAnchorTerm.quantityType == QuantifierGreedy) || (firstNonAnchorTerm.quantityType == QuantifierNonGreedy)))
                <span class="enscript-keyword">return</span>;
            
            firstExpressionTerm = termIndex + 1;
            
            termIndex = terms.size() - 1;
            <span class="enscript-keyword">if</span> (terms[termIndex].type == PatternTerm::TypeAssertionEOL) {
                endsWithEOL = true;
                --termIndex;
            }
            
            PatternTerm&amp; lastNonAnchorTerm = terms[termIndex];
            <span class="enscript-keyword">if</span> ((lastNonAnchorTerm.type != PatternTerm::TypeCharacterClass) || (lastNonAnchorTerm.characterClass != m_pattern.newlineCharacterClass()) || (lastNonAnchorTerm.quantityType != QuantifierGreedy))
                <span class="enscript-keyword">return</span>;
            
            lastExpressionTerm = termIndex - 1;

            <span class="enscript-keyword">if</span> (firstExpressionTerm &gt; lastExpressionTerm)
                <span class="enscript-keyword">return</span>;

            <span class="enscript-keyword">if</span> (!containsCapturingTerms(alternative, firstExpressionTerm, lastExpressionTerm)) {
                <span class="enscript-keyword">for</span> (termIndex = terms.size() - 1; termIndex &gt; lastExpressionTerm; --termIndex)
                    terms.remove(termIndex);

                <span class="enscript-keyword">for</span> (termIndex = firstExpressionTerm; termIndex &gt; 0; --termIndex)
                    terms.remove(termIndex - 1);

                terms.append(PatternTerm(startsWithBOL, endsWithEOL));
                
                m_pattern.m_containsBOL = false;
            }
        }
    }

<span class="enscript-type">private</span>:
    YarrPattern&amp; m_pattern;
    PatternAlternative* m_alternative;
    CharacterClassConstructor m_characterClassConstructor;
    <span class="enscript-type">bool</span> m_invertCharacterClass;
    <span class="enscript-type">bool</span> m_invertParentheticalAssertion;
};

<span class="enscript-type">const</span> <span class="enscript-type">char</span>* <span class="enscript-function-name">YarrPattern::compile</span>(<span class="enscript-type">const</span> UString&amp; patternString)
{
    YarrPatternConstructor constructor(*<span class="enscript-keyword">this</span>);

    <span class="enscript-keyword">if</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span>* error = parse(constructor, patternString))
        <span class="enscript-keyword">return</span> error;
    
    <span class="enscript-comment">// If the pattern contains illegal backreferences reset &amp; reparse.
</span>    <span class="enscript-comment">// Quoting Netscape's &quot;What's new in JavaScript 1.2&quot;,
</span>    <span class="enscript-comment">//      &quot;Note: if the number of left parentheses is less than the number specified
</span>    <span class="enscript-comment">//       in \#, the \# is taken as an octal escape as described in the next row.&quot;
</span>    <span class="enscript-keyword">if</span> (containsIllegalBackReference()) {
        <span class="enscript-type">unsigned</span> numSubpatterns = m_numSubpatterns;

        constructor.reset();
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">ASSERT_DISABLED</span>
        <span class="enscript-type">const</span> <span class="enscript-type">char</span>* error =
#<span class="enscript-reference">endif</span>
            parse(constructor, patternString, numSubpatterns);

        ASSERT(!error);
        ASSERT(numSubpatterns == m_numSubpatterns);
    }

    constructor.checkForTerminalParentheses();
    constructor.optimizeDotStarWrappedExpressions();
    constructor.optimizeBOL();
        
    constructor.setupOffsets();

    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-function-name">YarrPattern::YarrPattern</span>(<span class="enscript-type">const</span> UString&amp; pattern, <span class="enscript-type">bool</span> ignoreCase, <span class="enscript-type">bool</span> multiline, <span class="enscript-type">const</span> <span class="enscript-type">char</span>** error)
    : m_ignoreCase(ignoreCase)
    , m_multiline(multiline)
    , m_containsBackreferences(false)
    , m_containsBOL(false)
    , m_numSubpatterns(0)
    , m_maxBackReference(0)
    , newlineCached(0)
    , digitsCached(0)
    , spacesCached(0)
    , wordcharCached(0)
    , nondigitsCached(0)
    , nonspacesCached(0)
    , nonwordcharCached(0)
{
    *error = compile(pattern);
}

} }
</pre>
<hr />
</body></html>