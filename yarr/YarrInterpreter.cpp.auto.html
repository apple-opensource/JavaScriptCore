<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>YarrInterpreter.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">YarrInterpreter.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (C) 2009 Apple Inc. All rights reserved.
 * Copyright (C) 2010 Peter Varga (<a href="mailto:pvarga@inf.u-szeged.hu">pvarga@inf.u-szeged.hu</a>), University of Szeged
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;config.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;YarrInterpreter.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;UString.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Yarr.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;YarrCanonicalizeUCS2.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/BumpPointerAllocator.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/DataLog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/text/CString.h&gt;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NDEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">endif</span>

using namespace WTF;

namespace JSC { namespace Yarr {

<span class="enscript-type">template</span>&lt;typename CharType&gt;
<span class="enscript-type">class</span> Interpreter {
<span class="enscript-type">public</span>:
    <span class="enscript-type">struct</span> ParenthesesDisjunctionContext;

    <span class="enscript-type">struct</span> BackTrackInfoPatternCharacter {
        uintptr_t matchAmount;
    };
    <span class="enscript-type">struct</span> BackTrackInfoCharacterClass {
        uintptr_t matchAmount;
    };
    <span class="enscript-type">struct</span> BackTrackInfoBackReference {
        uintptr_t begin; <span class="enscript-comment">// Not really needed for greedy quantifiers.
</span>        uintptr_t matchAmount; <span class="enscript-comment">// Not really needed for fixed quantifiers.
</span>    };
    <span class="enscript-type">struct</span> BackTrackInfoAlternative {
        uintptr_t offset;
    };
    <span class="enscript-type">struct</span> BackTrackInfoParentheticalAssertion {
        uintptr_t begin;
    };
    <span class="enscript-type">struct</span> BackTrackInfoParenthesesOnce {
        uintptr_t begin;
    };
    <span class="enscript-type">struct</span> BackTrackInfoParenthesesTerminal {
        uintptr_t begin;
    };
    <span class="enscript-type">struct</span> BackTrackInfoParentheses {
        uintptr_t matchAmount;
        ParenthesesDisjunctionContext* lastContext;
    };

    <span class="enscript-type">static</span> <span class="enscript-type">inline</span> <span class="enscript-type">void</span> appendParenthesesDisjunctionContext(BackTrackInfoParentheses* backTrack, ParenthesesDisjunctionContext* context)
    {
        context-&gt;next = backTrack-&gt;lastContext;
        backTrack-&gt;lastContext = context;
        ++backTrack-&gt;matchAmount;
    }

    <span class="enscript-type">static</span> <span class="enscript-type">inline</span> <span class="enscript-type">void</span> popParenthesesDisjunctionContext(BackTrackInfoParentheses* backTrack)
    {
        ASSERT(backTrack-&gt;matchAmount);
        ASSERT(backTrack-&gt;lastContext);
        backTrack-&gt;lastContext = backTrack-&gt;lastContext-&gt;next;
        --backTrack-&gt;matchAmount;
    }

    <span class="enscript-type">struct</span> DisjunctionContext
    {
        DisjunctionContext()
            : term(0)
        {
        }

        <span class="enscript-type">void</span>* <span class="enscript-keyword">operator</span> <span class="enscript-keyword">new</span>(size_t, <span class="enscript-type">void</span>* where)
        {
            <span class="enscript-keyword">return</span> where;
        }

        <span class="enscript-type">int</span> term;
        <span class="enscript-type">unsigned</span> matchBegin;
        <span class="enscript-type">unsigned</span> matchEnd;
        uintptr_t frame[1];
    };

    DisjunctionContext* allocDisjunctionContext(ByteDisjunction* disjunction)
    {
        size_t size = <span class="enscript-keyword">sizeof</span>(DisjunctionContext) - <span class="enscript-keyword">sizeof</span>(uintptr_t) + disjunction-&gt;m_frameSize * <span class="enscript-keyword">sizeof</span>(uintptr_t);
        allocatorPool = allocatorPool-&gt;ensureCapacity(size);
        <span class="enscript-keyword">if</span> (!allocatorPool)
            CRASH();
        <span class="enscript-keyword">return</span> <span class="enscript-keyword">new</span> (allocatorPool-&gt;alloc(size)) DisjunctionContext();
    }

    <span class="enscript-type">void</span> freeDisjunctionContext(DisjunctionContext* context)
    {
        allocatorPool = allocatorPool-&gt;dealloc(context);
    }

    <span class="enscript-type">struct</span> ParenthesesDisjunctionContext
    {
        ParenthesesDisjunctionContext(<span class="enscript-type">unsigned</span>* output, ByteTerm&amp; term)
            : next(0)
        {
            <span class="enscript-type">unsigned</span> firstSubpatternId = term.atom.subpatternId;
            <span class="enscript-type">unsigned</span> numNestedSubpatterns = term.atom.parenthesesDisjunction-&gt;m_numSubpatterns;

            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; (numNestedSubpatterns &lt;&lt; 1); ++i) {
                subpatternBackup[i] = output[(firstSubpatternId &lt;&lt; 1) + i];
                output[(firstSubpatternId &lt;&lt; 1) + i] = offsetNoMatch;
            }

            <span class="enscript-keyword">new</span> (getDisjunctionContext(term)) DisjunctionContext();
        }

        <span class="enscript-type">void</span>* <span class="enscript-keyword">operator</span> <span class="enscript-keyword">new</span>(size_t, <span class="enscript-type">void</span>* where)
        {
            <span class="enscript-keyword">return</span> where;
        }

        <span class="enscript-type">void</span> restoreOutput(<span class="enscript-type">unsigned</span>* output, <span class="enscript-type">unsigned</span> firstSubpatternId, <span class="enscript-type">unsigned</span> numNestedSubpatterns)
        {
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; (numNestedSubpatterns &lt;&lt; 1); ++i)
                output[(firstSubpatternId &lt;&lt; 1) + i] = subpatternBackup[i];
        }

        DisjunctionContext* getDisjunctionContext(ByteTerm&amp; term)
        {
            <span class="enscript-keyword">return</span> reinterpret_cast&lt;DisjunctionContext*&gt;(&amp;(subpatternBackup[term.atom.parenthesesDisjunction-&gt;m_numSubpatterns &lt;&lt; 1]));
        }

        ParenthesesDisjunctionContext* next;
        <span class="enscript-type">unsigned</span> subpatternBackup[1];
    };

    ParenthesesDisjunctionContext* allocParenthesesDisjunctionContext(ByteDisjunction* disjunction, <span class="enscript-type">unsigned</span>* output, ByteTerm&amp; term)
    {
        size_t size = <span class="enscript-keyword">sizeof</span>(ParenthesesDisjunctionContext) - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span>) + (term.atom.parenthesesDisjunction-&gt;m_numSubpatterns &lt;&lt; 1) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span>) + <span class="enscript-keyword">sizeof</span>(DisjunctionContext) - <span class="enscript-keyword">sizeof</span>(uintptr_t) + disjunction-&gt;m_frameSize * <span class="enscript-keyword">sizeof</span>(uintptr_t);
        allocatorPool = allocatorPool-&gt;ensureCapacity(size);
        <span class="enscript-keyword">if</span> (!allocatorPool)
            CRASH();
        <span class="enscript-keyword">return</span> <span class="enscript-keyword">new</span> (allocatorPool-&gt;alloc(size)) ParenthesesDisjunctionContext(output, term);
    }

    <span class="enscript-type">void</span> freeParenthesesDisjunctionContext(ParenthesesDisjunctionContext* context)
    {
        allocatorPool = allocatorPool-&gt;dealloc(context);
    }

    <span class="enscript-type">class</span> InputStream {
    <span class="enscript-type">public</span>:
        InputStream(<span class="enscript-type">const</span> CharType* input, <span class="enscript-type">unsigned</span> start, <span class="enscript-type">unsigned</span> length)
            : input(input)
            , pos(start)
            , length(length)
        {
        }

        <span class="enscript-type">void</span> next()
        {
            ++pos;
        }

        <span class="enscript-type">void</span> rewind(<span class="enscript-type">unsigned</span> amount)
        {
            ASSERT(pos &gt;= amount);
            pos -= amount;
        }

        <span class="enscript-type">int</span> read()
        {
            ASSERT(pos &lt; length);
            <span class="enscript-keyword">if</span> (pos &lt; length)
                <span class="enscript-keyword">return</span> input[pos];
            <span class="enscript-keyword">return</span> -1;
        }

        <span class="enscript-type">int</span> readPair()
        {
            ASSERT(pos + 1 &lt; length);
            <span class="enscript-keyword">return</span> input[pos] | input[pos + 1] &lt;&lt; 16;
        }

        <span class="enscript-type">int</span> readChecked(<span class="enscript-type">unsigned</span> negativePositionOffest)
        {
            <span class="enscript-keyword">if</span> (pos &lt; negativePositionOffest)
                CRASH();
            <span class="enscript-type">unsigned</span> p = pos - negativePositionOffest;
            ASSERT(p &lt; length);
            <span class="enscript-keyword">return</span> input[p];
        }

        <span class="enscript-type">int</span> reread(<span class="enscript-type">unsigned</span> from)
        {
            ASSERT(from &lt; length);
            <span class="enscript-keyword">return</span> input[from];
        }

        <span class="enscript-type">int</span> prev()
        {
            ASSERT(!(pos &gt; length));
            <span class="enscript-keyword">if</span> (pos &amp;&amp; length)
                <span class="enscript-keyword">return</span> input[pos - 1];
            <span class="enscript-keyword">return</span> -1;
        }

        <span class="enscript-type">unsigned</span> getPos()
        {
            <span class="enscript-keyword">return</span> pos;
        }

        <span class="enscript-type">void</span> setPos(<span class="enscript-type">unsigned</span> p)
        {
            pos = p;
        }

        <span class="enscript-type">bool</span> atStart()
        {
            <span class="enscript-keyword">return</span> pos == 0;
        }

        <span class="enscript-type">bool</span> atEnd()
        {
            <span class="enscript-keyword">return</span> pos == length;
        }

        <span class="enscript-type">unsigned</span> end()
        {
            <span class="enscript-keyword">return</span> length;
        }

        <span class="enscript-type">bool</span> checkInput(<span class="enscript-type">unsigned</span> count)
        {
            <span class="enscript-keyword">if</span> (((pos + count) &lt;= length) &amp;&amp; ((pos + count) &gt;= pos)) {
                pos += count;
                <span class="enscript-keyword">return</span> true;
            }
            <span class="enscript-keyword">return</span> false;
        }

        <span class="enscript-type">void</span> uncheckInput(<span class="enscript-type">unsigned</span> count)
        {
            <span class="enscript-keyword">if</span> (pos &lt; count)
                CRASH();
            pos -= count;
        }

        <span class="enscript-type">bool</span> atStart(<span class="enscript-type">unsigned</span> negativePositionOffest)
        {
            <span class="enscript-keyword">return</span> pos == negativePositionOffest;
        }

        <span class="enscript-type">bool</span> atEnd(<span class="enscript-type">unsigned</span> negativePositionOffest)
        {
            <span class="enscript-keyword">if</span> (pos &lt; negativePositionOffest)
                CRASH();
            <span class="enscript-keyword">return</span> (pos - negativePositionOffest) == length;
        }

        <span class="enscript-type">bool</span> isAvailableInput(<span class="enscript-type">unsigned</span> offset)
        {
            <span class="enscript-keyword">return</span> (((pos + offset) &lt;= length) &amp;&amp; ((pos + offset) &gt;= pos));
        }

    <span class="enscript-type">private</span>:
        <span class="enscript-type">const</span> CharType* input;
        <span class="enscript-type">unsigned</span> pos;
        <span class="enscript-type">unsigned</span> length;
    };

    <span class="enscript-type">bool</span> testCharacterClass(CharacterClass* characterClass, <span class="enscript-type">int</span> ch)
    {
        <span class="enscript-keyword">if</span> (ch &amp; 0xFF80) {
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; characterClass-&gt;m_matchesUnicode.size(); ++i)
                <span class="enscript-keyword">if</span> (ch == characterClass-&gt;m_matchesUnicode[i])
                    <span class="enscript-keyword">return</span> true;
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; characterClass-&gt;m_rangesUnicode.size(); ++i)
                <span class="enscript-keyword">if</span> ((ch &gt;= characterClass-&gt;m_rangesUnicode[i].begin) &amp;&amp; (ch &lt;= characterClass-&gt;m_rangesUnicode[i].end))
                    <span class="enscript-keyword">return</span> true;
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; characterClass-&gt;m_matches.size(); ++i)
                <span class="enscript-keyword">if</span> (ch == characterClass-&gt;m_matches[i])
                    <span class="enscript-keyword">return</span> true;
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; characterClass-&gt;m_ranges.size(); ++i)
                <span class="enscript-keyword">if</span> ((ch &gt;= characterClass-&gt;m_ranges[i].begin) &amp;&amp; (ch &lt;= characterClass-&gt;m_ranges[i].end))
                    <span class="enscript-keyword">return</span> true;
        }

        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> checkCharacter(<span class="enscript-type">int</span> testChar, <span class="enscript-type">unsigned</span> negativeInputOffset)
    {
        <span class="enscript-keyword">return</span> testChar == input.readChecked(negativeInputOffset);
    }

    <span class="enscript-type">bool</span> checkCasedCharacter(<span class="enscript-type">int</span> loChar, <span class="enscript-type">int</span> hiChar, <span class="enscript-type">unsigned</span> negativeInputOffset)
    {
        <span class="enscript-type">int</span> ch = input.readChecked(negativeInputOffset);
        <span class="enscript-keyword">return</span> (loChar == ch) || (hiChar == ch);
    }

    <span class="enscript-type">bool</span> checkCharacterClass(CharacterClass* characterClass, <span class="enscript-type">bool</span> invert, <span class="enscript-type">unsigned</span> negativeInputOffset)
    {
        <span class="enscript-type">bool</span> match = testCharacterClass(characterClass, input.readChecked(negativeInputOffset));
        <span class="enscript-keyword">return</span> invert ? !match : match;
    }

    <span class="enscript-type">bool</span> tryConsumeBackReference(<span class="enscript-type">int</span> matchBegin, <span class="enscript-type">int</span> matchEnd, <span class="enscript-type">unsigned</span> negativeInputOffset)
    {
        <span class="enscript-type">unsigned</span> matchSize = (<span class="enscript-type">unsigned</span>)(matchEnd - matchBegin);

        <span class="enscript-keyword">if</span> (!input.checkInput(matchSize))
            <span class="enscript-keyword">return</span> false;

        <span class="enscript-keyword">if</span> (pattern-&gt;m_ignoreCase) {
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; matchSize; ++i) {
                <span class="enscript-type">int</span> oldCh = input.reread(matchBegin + i);
                <span class="enscript-type">int</span> ch = input.readChecked(negativeInputOffset + matchSize - i);

                <span class="enscript-keyword">if</span> (oldCh == ch)
                    <span class="enscript-keyword">continue</span>;

                <span class="enscript-comment">// The definition for canonicalize (see ES 5.1, 15.10.2.8) means that
</span>                <span class="enscript-comment">// unicode values are never allowed to match against ascii ones.
</span>                <span class="enscript-keyword">if</span> (isASCII(oldCh) || isASCII(ch)) {
                    <span class="enscript-keyword">if</span> (toASCIIUpper(oldCh) == toASCIIUpper(ch))
                        <span class="enscript-keyword">continue</span>;
                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (areCanonicallyEquivalent(oldCh, ch))
                    <span class="enscript-keyword">continue</span>;

                input.uncheckInput(matchSize);
                <span class="enscript-keyword">return</span> false;
            }
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; matchSize; ++i) {
                <span class="enscript-keyword">if</span> (!checkCharacter(input.reread(matchBegin + i), negativeInputOffset + matchSize - i)) {
                    input.uncheckInput(matchSize);
                    <span class="enscript-keyword">return</span> false;
                }
            }
        }

        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-type">bool</span> matchAssertionBOL(ByteTerm&amp; term)
    {
        <span class="enscript-keyword">return</span> (input.atStart(term.inputPosition)) || (pattern-&gt;m_multiline &amp;&amp; testCharacterClass(pattern-&gt;newlineCharacterClass, input.readChecked(term.inputPosition + 1)));
    }

    <span class="enscript-type">bool</span> matchAssertionEOL(ByteTerm&amp; term)
    {
        <span class="enscript-keyword">if</span> (term.inputPosition)
            <span class="enscript-keyword">return</span> (input.atEnd(term.inputPosition)) || (pattern-&gt;m_multiline &amp;&amp; testCharacterClass(pattern-&gt;newlineCharacterClass, input.readChecked(term.inputPosition)));

        <span class="enscript-keyword">return</span> (input.atEnd()) || (pattern-&gt;m_multiline &amp;&amp; testCharacterClass(pattern-&gt;newlineCharacterClass, input.read()));
    }

    <span class="enscript-type">bool</span> matchAssertionWordBoundary(ByteTerm&amp; term)
    {
        <span class="enscript-type">bool</span> prevIsWordchar = !input.atStart(term.inputPosition) &amp;&amp; testCharacterClass(pattern-&gt;wordcharCharacterClass, input.readChecked(term.inputPosition + 1));
        <span class="enscript-type">bool</span> readIsWordchar;
        <span class="enscript-keyword">if</span> (term.inputPosition)
            readIsWordchar = !input.atEnd(term.inputPosition) &amp;&amp; testCharacterClass(pattern-&gt;wordcharCharacterClass, input.readChecked(term.inputPosition));
        <span class="enscript-keyword">else</span>
            readIsWordchar = !input.atEnd() &amp;&amp; testCharacterClass(pattern-&gt;wordcharCharacterClass, input.read());

        <span class="enscript-type">bool</span> wordBoundary = prevIsWordchar != readIsWordchar;
        <span class="enscript-keyword">return</span> term.invert() ? !wordBoundary : wordBoundary;
    }

    <span class="enscript-type">bool</span> backtrackPatternCharacter(ByteTerm&amp; term, DisjunctionContext* context)
    {
        BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + term.frameLocation);

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>:
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>:
            <span class="enscript-keyword">if</span> (backTrack-&gt;matchAmount) {
                --backTrack-&gt;matchAmount;
                input.uncheckInput(1);
                <span class="enscript-keyword">return</span> true;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>:
            <span class="enscript-keyword">if</span> ((backTrack-&gt;matchAmount &lt; term.atom.quantityCount) &amp;&amp; input.checkInput(1)) {
                ++backTrack-&gt;matchAmount;
                <span class="enscript-keyword">if</span> (checkCharacter(term.atom.patternCharacter, term.inputPosition + 1))
                    <span class="enscript-keyword">return</span> true;
            }
            input.uncheckInput(backTrack-&gt;matchAmount);
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> backtrackPatternCasedCharacter(ByteTerm&amp; term, DisjunctionContext* context)
    {
        BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + term.frameLocation);

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>:
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>:
            <span class="enscript-keyword">if</span> (backTrack-&gt;matchAmount) {
                --backTrack-&gt;matchAmount;
                input.uncheckInput(1);
                <span class="enscript-keyword">return</span> true;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>:
            <span class="enscript-keyword">if</span> ((backTrack-&gt;matchAmount &lt; term.atom.quantityCount) &amp;&amp; input.checkInput(1)) {
                ++backTrack-&gt;matchAmount;
                <span class="enscript-keyword">if</span> (checkCasedCharacter(term.atom.casedCharacter.lo, term.atom.casedCharacter.hi, term.inputPosition + 1))
                    <span class="enscript-keyword">return</span> true;
            }
            input.uncheckInput(backTrack-&gt;matchAmount);
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> matchCharacterClass(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeCharacterClass);
        BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + term.frameLocation);

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>: {
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> matchAmount = 0; matchAmount &lt; term.atom.quantityCount; ++matchAmount) {
                <span class="enscript-keyword">if</span> (!checkCharacterClass(term.atom.characterClass, term.invert(), term.inputPosition - matchAmount))
                    <span class="enscript-keyword">return</span> false;
            }
            <span class="enscript-keyword">return</span> true;
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>: {
            <span class="enscript-type">unsigned</span> matchAmount = 0;
            <span class="enscript-keyword">while</span> ((matchAmount &lt; term.atom.quantityCount) &amp;&amp; input.checkInput(1)) {
                <span class="enscript-keyword">if</span> (!checkCharacterClass(term.atom.characterClass, term.invert(), term.inputPosition + 1)) {
                    input.uncheckInput(1);
                    <span class="enscript-keyword">break</span>;
                }
                ++matchAmount;
            }
            backTrack-&gt;matchAmount = matchAmount;

            <span class="enscript-keyword">return</span> true;
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>:
            backTrack-&gt;matchAmount = 0;
            <span class="enscript-keyword">return</span> true;
        }

        ASSERT_NOT_REACHED();
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> backtrackCharacterClass(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeCharacterClass);
        BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + term.frameLocation);

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>:
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>:
            <span class="enscript-keyword">if</span> (backTrack-&gt;matchAmount) {
                --backTrack-&gt;matchAmount;
                input.uncheckInput(1);
                <span class="enscript-keyword">return</span> true;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>:
            <span class="enscript-keyword">if</span> ((backTrack-&gt;matchAmount &lt; term.atom.quantityCount) &amp;&amp; input.checkInput(1)) {
                ++backTrack-&gt;matchAmount;
                <span class="enscript-keyword">if</span> (checkCharacterClass(term.atom.characterClass, term.invert(), term.inputPosition + 1))
                    <span class="enscript-keyword">return</span> true;
            }
            input.uncheckInput(backTrack-&gt;matchAmount);
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> matchBackReference(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeBackReference);
        BackTrackInfoBackReference* backTrack = reinterpret_cast&lt;BackTrackInfoBackReference*&gt;(context-&gt;frame + term.frameLocation);

        <span class="enscript-type">unsigned</span> matchBegin = output[(term.atom.subpatternId &lt;&lt; 1)];
        <span class="enscript-type">unsigned</span> matchEnd = output[(term.atom.subpatternId &lt;&lt; 1) + 1];

        <span class="enscript-comment">// If the end position of the referenced match hasn't set yet then the backreference in the same parentheses where it references to that.
</span>        <span class="enscript-comment">// In this case the result of match is empty string like when it references to a parentheses with zero-width match.
</span>        <span class="enscript-comment">// Eg.: /(a\1)/
</span>        <span class="enscript-keyword">if</span> (matchEnd == offsetNoMatch)
            <span class="enscript-keyword">return</span> true;

        <span class="enscript-keyword">if</span> (matchBegin == offsetNoMatch)
            <span class="enscript-keyword">return</span> true;

        ASSERT(matchBegin &lt;= matchEnd);

        <span class="enscript-keyword">if</span> (matchBegin == matchEnd)
            <span class="enscript-keyword">return</span> true;

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>: {
            backTrack-&gt;begin = input.getPos();
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> matchAmount = 0; matchAmount &lt; term.atom.quantityCount; ++matchAmount) {
                <span class="enscript-keyword">if</span> (!tryConsumeBackReference(matchBegin, matchEnd, term.inputPosition)) {
                    input.setPos(backTrack-&gt;begin);
                    <span class="enscript-keyword">return</span> false;
                }
            }
            <span class="enscript-keyword">return</span> true;
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>: {
            <span class="enscript-type">unsigned</span> matchAmount = 0;
            <span class="enscript-keyword">while</span> ((matchAmount &lt; term.atom.quantityCount) &amp;&amp; tryConsumeBackReference(matchBegin, matchEnd, term.inputPosition))
                ++matchAmount;
            backTrack-&gt;matchAmount = matchAmount;
            <span class="enscript-keyword">return</span> true;
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>:
            backTrack-&gt;begin = input.getPos();
            backTrack-&gt;matchAmount = 0;
            <span class="enscript-keyword">return</span> true;
        }

        ASSERT_NOT_REACHED();
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> backtrackBackReference(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeBackReference);
        BackTrackInfoBackReference* backTrack = reinterpret_cast&lt;BackTrackInfoBackReference*&gt;(context-&gt;frame + term.frameLocation);

        <span class="enscript-type">unsigned</span> matchBegin = output[(term.atom.subpatternId &lt;&lt; 1)];
        <span class="enscript-type">unsigned</span> matchEnd = output[(term.atom.subpatternId &lt;&lt; 1) + 1];

        <span class="enscript-keyword">if</span> (matchBegin == offsetNoMatch)
            <span class="enscript-keyword">return</span> false;

        ASSERT(matchBegin &lt;= matchEnd);

        <span class="enscript-keyword">if</span> (matchBegin == matchEnd)
            <span class="enscript-keyword">return</span> false;

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>:
            <span class="enscript-comment">// for quantityCount == 1, could rewind.
</span>            input.setPos(backTrack-&gt;begin);
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>:
            <span class="enscript-keyword">if</span> (backTrack-&gt;matchAmount) {
                --backTrack-&gt;matchAmount;
                input.rewind(matchEnd - matchBegin);
                <span class="enscript-keyword">return</span> true;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>:
            <span class="enscript-keyword">if</span> ((backTrack-&gt;matchAmount &lt; term.atom.quantityCount) &amp;&amp; tryConsumeBackReference(matchBegin, matchEnd, term.inputPosition)) {
                ++backTrack-&gt;matchAmount;
                <span class="enscript-keyword">return</span> true;
            }
            input.setPos(backTrack-&gt;begin);
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">void</span> recordParenthesesMatch(ByteTerm&amp; term, ParenthesesDisjunctionContext* context)
    {
        <span class="enscript-keyword">if</span> (term.capture()) {
            <span class="enscript-type">unsigned</span> subpatternId = term.atom.subpatternId;
            output[(subpatternId &lt;&lt; 1)] = context-&gt;getDisjunctionContext(term)-&gt;matchBegin + term.inputPosition;
            output[(subpatternId &lt;&lt; 1) + 1] = context-&gt;getDisjunctionContext(term)-&gt;matchEnd + term.inputPosition;
        }
    }
    <span class="enscript-type">void</span> resetMatches(ByteTerm&amp; term, ParenthesesDisjunctionContext* context)
    {
        <span class="enscript-type">unsigned</span> firstSubpatternId = term.atom.subpatternId;
        <span class="enscript-type">unsigned</span> count = term.atom.parenthesesDisjunction-&gt;m_numSubpatterns;
        context-&gt;restoreOutput(output, firstSubpatternId, count);
    }
    JSRegExpResult parenthesesDoBacktrack(ByteTerm&amp; term, BackTrackInfoParentheses* backTrack)
    {
        <span class="enscript-keyword">while</span> (backTrack-&gt;matchAmount) {
            ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;

            JSRegExpResult result = matchDisjunction(term.atom.parenthesesDisjunction, context-&gt;getDisjunctionContext(term), true);
            <span class="enscript-keyword">if</span> (result == JSRegExpMatch)
                <span class="enscript-keyword">return</span> JSRegExpMatch;

            resetMatches(term, context);
            popParenthesesDisjunctionContext(backTrack);
            freeParenthesesDisjunctionContext(context);

            <span class="enscript-keyword">if</span> (result != JSRegExpNoMatch)
                <span class="enscript-keyword">return</span> result;
        }

        <span class="enscript-keyword">return</span> JSRegExpNoMatch;
    }

    <span class="enscript-type">bool</span> matchParenthesesOnceBegin(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternOnceBegin);
        ASSERT(term.atom.quantityCount == 1);

        BackTrackInfoParenthesesOnce* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesOnce*&gt;(context-&gt;frame + term.frameLocation);

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>: {
            <span class="enscript-comment">// set this speculatively; if we get to the parens end this will be true.
</span>            backTrack-&gt;begin = input.getPos();
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>: {
            backTrack-&gt;begin = notFound;
            context-&gt;term += term.atom.parenthesesWidth;
            <span class="enscript-keyword">return</span> true;
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>:
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> (term.capture()) {
            <span class="enscript-type">unsigned</span> subpatternId = term.atom.subpatternId;
            output[(subpatternId &lt;&lt; 1)] = input.getPos() - term.inputPosition;
        }

        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-type">bool</span> matchParenthesesOnceEnd(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternOnceEnd);
        ASSERT(term.atom.quantityCount == 1);

        <span class="enscript-keyword">if</span> (term.capture()) {
            <span class="enscript-type">unsigned</span> subpatternId = term.atom.subpatternId;
            output[(subpatternId &lt;&lt; 1) + 1] = input.getPos() + term.inputPosition;
        }

        <span class="enscript-keyword">if</span> (term.atom.quantityType == QuantifierFixedCount)
            <span class="enscript-keyword">return</span> true;

        BackTrackInfoParenthesesOnce* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesOnce*&gt;(context-&gt;frame + term.frameLocation);
        <span class="enscript-keyword">return</span> backTrack-&gt;begin != input.getPos();
    }

    <span class="enscript-type">bool</span> backtrackParenthesesOnceBegin(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternOnceBegin);
        ASSERT(term.atom.quantityCount == 1);

        BackTrackInfoParenthesesOnce* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesOnce*&gt;(context-&gt;frame + term.frameLocation);

        <span class="enscript-keyword">if</span> (term.capture()) {
            <span class="enscript-type">unsigned</span> subpatternId = term.atom.subpatternId;
            output[(subpatternId &lt;&lt; 1)] = offsetNoMatch;
            output[(subpatternId &lt;&lt; 1) + 1] = offsetNoMatch;
        }

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>:
            <span class="enscript-comment">// if we backtrack to this point, there is another chance - try matching nothing.
</span>            ASSERT(backTrack-&gt;begin != notFound);
            backTrack-&gt;begin = notFound;
            context-&gt;term += term.atom.parenthesesWidth;
            <span class="enscript-keyword">return</span> true;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>:
            ASSERT(backTrack-&gt;begin != notFound);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>:
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> backtrackParenthesesOnceEnd(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternOnceEnd);
        ASSERT(term.atom.quantityCount == 1);

        BackTrackInfoParenthesesOnce* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesOnce*&gt;(context-&gt;frame + term.frameLocation);

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>:
            <span class="enscript-keyword">if</span> (backTrack-&gt;begin == notFound) {
                context-&gt;term -= term.atom.parenthesesWidth;
                <span class="enscript-keyword">return</span> false;
            }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>:
            <span class="enscript-keyword">if</span> (backTrack-&gt;begin == notFound) {
                backTrack-&gt;begin = input.getPos();
                <span class="enscript-keyword">if</span> (term.capture()) {
                    <span class="enscript-comment">// Technically this access to inputPosition should be accessing the begin term's
</span>                    <span class="enscript-comment">// inputPosition, but for repeats other than fixed these values should be
</span>                    <span class="enscript-comment">// the same anyway! (We don't pre-check for greedy or non-greedy matches.)
</span>                    ASSERT((&amp;term - term.atom.parenthesesWidth)-&gt;type == ByteTerm::TypeParenthesesSubpatternOnceBegin);
                    ASSERT((&amp;term - term.atom.parenthesesWidth)-&gt;inputPosition == term.inputPosition);
                    <span class="enscript-type">unsigned</span> subpatternId = term.atom.subpatternId;
                    output[subpatternId &lt;&lt; 1] = input.getPos() + term.inputPosition;
                }
                context-&gt;term -= term.atom.parenthesesWidth;
                <span class="enscript-keyword">return</span> true;
            }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>:
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> matchParenthesesTerminalBegin(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternTerminalBegin);
        ASSERT(term.atom.quantityType == QuantifierGreedy);
        ASSERT(term.atom.quantityCount == quantifyInfinite);
        ASSERT(!term.capture());

        BackTrackInfoParenthesesTerminal* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesTerminal*&gt;(context-&gt;frame + term.frameLocation);
        backTrack-&gt;begin = input.getPos();
        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-type">bool</span> matchParenthesesTerminalEnd(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternTerminalEnd);

        BackTrackInfoParenthesesTerminal* backTrack = reinterpret_cast&lt;BackTrackInfoParenthesesTerminal*&gt;(context-&gt;frame + term.frameLocation);
        <span class="enscript-comment">// Empty match is a failed match.
</span>        <span class="enscript-keyword">if</span> (backTrack-&gt;begin == input.getPos())
            <span class="enscript-keyword">return</span> false;

        <span class="enscript-comment">// Successful match! Okay, what's next? - loop around and try to match moar!
</span>        context-&gt;term -= (term.atom.parenthesesWidth + 1);
        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-type">bool</span> backtrackParenthesesTerminalBegin(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParenthesesSubpatternTerminalBegin);
        ASSERT(term.atom.quantityType == QuantifierGreedy);
        ASSERT(term.atom.quantityCount == quantifyInfinite);
        ASSERT(!term.capture());

        <span class="enscript-comment">// If we backtrack to this point, we have failed to match this iteration of the parens.
</span>        <span class="enscript-comment">// Since this is greedy / zero minimum a failed is also accepted as a match!
</span>        context-&gt;term += term.atom.parenthesesWidth;
        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-type">bool</span> backtrackParenthesesTerminalEnd(ByteTerm&amp;, DisjunctionContext*)
    {
        <span class="enscript-comment">// 'Terminal' parentheses are at the end of the regex, and as such a match past end
</span>        <span class="enscript-comment">// should always be returned as a successful match - we should never backtrack to here.
</span>        ASSERT_NOT_REACHED();
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> matchParentheticalAssertionBegin(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParentheticalAssertionBegin);
        ASSERT(term.atom.quantityCount == 1);

        BackTrackInfoParentheticalAssertion* backTrack = reinterpret_cast&lt;BackTrackInfoParentheticalAssertion*&gt;(context-&gt;frame + term.frameLocation);

        backTrack-&gt;begin = input.getPos();
        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-type">bool</span> matchParentheticalAssertionEnd(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParentheticalAssertionEnd);
        ASSERT(term.atom.quantityCount == 1);

        BackTrackInfoParentheticalAssertion* backTrack = reinterpret_cast&lt;BackTrackInfoParentheticalAssertion*&gt;(context-&gt;frame + term.frameLocation);

        input.setPos(backTrack-&gt;begin);

        <span class="enscript-comment">// We've reached the end of the parens; if they are inverted, this is failure.
</span>        <span class="enscript-keyword">if</span> (term.invert()) {
            context-&gt;term -= term.atom.parenthesesWidth;
            <span class="enscript-keyword">return</span> false;
        }

        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-type">bool</span> backtrackParentheticalAssertionBegin(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParentheticalAssertionBegin);
        ASSERT(term.atom.quantityCount == 1);

        <span class="enscript-comment">// We've failed to match parens; if they are inverted, this is win!
</span>        <span class="enscript-keyword">if</span> (term.invert()) {
            context-&gt;term += term.atom.parenthesesWidth;
            <span class="enscript-keyword">return</span> true;
        }

        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-type">bool</span> backtrackParentheticalAssertionEnd(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParentheticalAssertionEnd);
        ASSERT(term.atom.quantityCount == 1);

        BackTrackInfoParentheticalAssertion* backTrack = reinterpret_cast&lt;BackTrackInfoParentheticalAssertion*&gt;(context-&gt;frame + term.frameLocation);

        input.setPos(backTrack-&gt;begin);

        context-&gt;term -= term.atom.parenthesesWidth;
        <span class="enscript-keyword">return</span> false;
    }

    JSRegExpResult matchParentheses(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParenthesesSubpattern);

        BackTrackInfoParentheses* backTrack = reinterpret_cast&lt;BackTrackInfoParentheses*&gt;(context-&gt;frame + term.frameLocation);
        ByteDisjunction* disjunctionBody = term.atom.parenthesesDisjunction;

        backTrack-&gt;matchAmount = 0;
        backTrack-&gt;lastContext = 0;

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>: {
            <span class="enscript-comment">// While we haven't yet reached our fixed limit,
</span>            <span class="enscript-keyword">while</span> (backTrack-&gt;matchAmount &lt; term.atom.quantityCount) {
                <span class="enscript-comment">// Try to do a match, and it it succeeds, add it to the list.
</span>                ParenthesesDisjunctionContext* context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
                JSRegExpResult result = matchDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));
                <span class="enscript-keyword">if</span> (result == JSRegExpMatch)
                    appendParenthesesDisjunctionContext(backTrack, context);
                <span class="enscript-keyword">else</span> {
                    <span class="enscript-comment">// The match failed; try to find an alternate point to carry on from.
</span>                    resetMatches(term, context);
                    freeParenthesesDisjunctionContext(context);

                    <span class="enscript-keyword">if</span> (result != JSRegExpNoMatch)
                        <span class="enscript-keyword">return</span> result;
                    JSRegExpResult backtrackResult = parenthesesDoBacktrack(term, backTrack);
                    <span class="enscript-keyword">if</span> (backtrackResult != JSRegExpMatch)
                        <span class="enscript-keyword">return</span> backtrackResult;
                }
            }

            ASSERT(backTrack-&gt;matchAmount == term.atom.quantityCount);
            ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
            recordParenthesesMatch(term, context);
            <span class="enscript-keyword">return</span> JSRegExpMatch;
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>: {
            <span class="enscript-keyword">while</span> (backTrack-&gt;matchAmount &lt; term.atom.quantityCount) {
                ParenthesesDisjunctionContext* context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
                JSRegExpResult result = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));
                <span class="enscript-keyword">if</span> (result == JSRegExpMatch)
                    appendParenthesesDisjunctionContext(backTrack, context);
                <span class="enscript-keyword">else</span> {
                    resetMatches(term, context);
                    freeParenthesesDisjunctionContext(context);

                    <span class="enscript-keyword">if</span> (result != JSRegExpNoMatch)
                        <span class="enscript-keyword">return</span> result;

                    <span class="enscript-keyword">break</span>;
                }
            }

            <span class="enscript-keyword">if</span> (backTrack-&gt;matchAmount) {
                ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
                recordParenthesesMatch(term, context);
            }
            <span class="enscript-keyword">return</span> JSRegExpMatch;
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>:
            <span class="enscript-keyword">return</span> JSRegExpMatch;
        }

        ASSERT_NOT_REACHED();
        <span class="enscript-keyword">return</span> JSRegExpErrorNoMatch;
    }

    <span class="enscript-comment">// Rules for backtracking differ depending on whether this is greedy or non-greedy.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Greedy matches never should try just adding more - you should already have done
</span>    <span class="enscript-comment">// the 'more' cases.  Always backtrack, at least a leetle bit.  However cases where
</span>    <span class="enscript-comment">// you backtrack an item off the list needs checking, since we'll never have matched
</span>    <span class="enscript-comment">// the one less case.  Tracking forwards, still add as much as possible.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Non-greedy, we've already done the one less case, so don't match on popping.
</span>    <span class="enscript-comment">// We haven't done the one more case, so always try to add that.
</span>    <span class="enscript-comment">//
</span>    JSRegExpResult backtrackParentheses(ByteTerm&amp; term, DisjunctionContext* context)
    {
        ASSERT(term.type == ByteTerm::TypeParenthesesSubpattern);

        BackTrackInfoParentheses* backTrack = reinterpret_cast&lt;BackTrackInfoParentheses*&gt;(context-&gt;frame + term.frameLocation);
        ByteDisjunction* disjunctionBody = term.atom.parenthesesDisjunction;

        <span class="enscript-keyword">switch</span> (term.atom.quantityType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierFixedCount</span>: {
            ASSERT(backTrack-&gt;matchAmount == term.atom.quantityCount);

            ParenthesesDisjunctionContext* context = 0;
            JSRegExpResult result = parenthesesDoBacktrack(term, backTrack);

            <span class="enscript-keyword">if</span> (result != JSRegExpMatch)
                <span class="enscript-keyword">return</span> result;

            <span class="enscript-comment">// While we haven't yet reached our fixed limit,
</span>            <span class="enscript-keyword">while</span> (backTrack-&gt;matchAmount &lt; term.atom.quantityCount) {
                <span class="enscript-comment">// Try to do a match, and it it succeeds, add it to the list.
</span>                context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
                result = matchDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));

                <span class="enscript-keyword">if</span> (result == JSRegExpMatch)
                    appendParenthesesDisjunctionContext(backTrack, context);
                <span class="enscript-keyword">else</span> {
                    <span class="enscript-comment">// The match failed; try to find an alternate point to carry on from.
</span>                    resetMatches(term, context);
                    freeParenthesesDisjunctionContext(context);

                    <span class="enscript-keyword">if</span> (result != JSRegExpNoMatch)
                        <span class="enscript-keyword">return</span> result;
                    JSRegExpResult backtrackResult = parenthesesDoBacktrack(term, backTrack);
                    <span class="enscript-keyword">if</span> (backtrackResult != JSRegExpMatch)
                        <span class="enscript-keyword">return</span> backtrackResult;
                }
            }

            ASSERT(backTrack-&gt;matchAmount == term.atom.quantityCount);
            context = backTrack-&gt;lastContext;
            recordParenthesesMatch(term, context);
            <span class="enscript-keyword">return</span> JSRegExpMatch;
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierGreedy</span>: {
            <span class="enscript-keyword">if</span> (!backTrack-&gt;matchAmount)
                <span class="enscript-keyword">return</span> JSRegExpNoMatch;

            ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
            JSRegExpResult result = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term), true);
            <span class="enscript-keyword">if</span> (result == JSRegExpMatch) {
                <span class="enscript-keyword">while</span> (backTrack-&gt;matchAmount &lt; term.atom.quantityCount) {
                    ParenthesesDisjunctionContext* context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
                    JSRegExpResult parenthesesResult = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));
                    <span class="enscript-keyword">if</span> (parenthesesResult == JSRegExpMatch)
                        appendParenthesesDisjunctionContext(backTrack, context);
                    <span class="enscript-keyword">else</span> {
                        resetMatches(term, context);
                        freeParenthesesDisjunctionContext(context);

                        <span class="enscript-keyword">if</span> (parenthesesResult != JSRegExpNoMatch)
                            <span class="enscript-keyword">return</span> parenthesesResult;

                        <span class="enscript-keyword">break</span>;
                    }
                }
            } <span class="enscript-keyword">else</span> {
                resetMatches(term, context);
                popParenthesesDisjunctionContext(backTrack);
                freeParenthesesDisjunctionContext(context);

                <span class="enscript-keyword">if</span> (result != JSRegExpNoMatch)
                    <span class="enscript-keyword">return</span> result;
            }

            <span class="enscript-keyword">if</span> (backTrack-&gt;matchAmount) {
                ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
                recordParenthesesMatch(term, context);
            }
            <span class="enscript-keyword">return</span> JSRegExpMatch;
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">QuantifierNonGreedy</span>: {
            <span class="enscript-comment">// If we've not reached the limit, try to add one more match.
</span>            <span class="enscript-keyword">if</span> (backTrack-&gt;matchAmount &lt; term.atom.quantityCount) {
                ParenthesesDisjunctionContext* context = allocParenthesesDisjunctionContext(disjunctionBody, output, term);
                JSRegExpResult result = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term));
                <span class="enscript-keyword">if</span> (result == JSRegExpMatch) {
                    appendParenthesesDisjunctionContext(backTrack, context);
                    recordParenthesesMatch(term, context);
                    <span class="enscript-keyword">return</span> JSRegExpMatch;
                }

                resetMatches(term, context);
                freeParenthesesDisjunctionContext(context);

                <span class="enscript-keyword">if</span> (result != JSRegExpNoMatch)
                    <span class="enscript-keyword">return</span> result;
            }

            <span class="enscript-comment">// Nope - okay backtrack looking for an alternative.
</span>            <span class="enscript-keyword">while</span> (backTrack-&gt;matchAmount) {
                ParenthesesDisjunctionContext* context = backTrack-&gt;lastContext;
                JSRegExpResult result = matchNonZeroDisjunction(disjunctionBody, context-&gt;getDisjunctionContext(term), true);
                <span class="enscript-keyword">if</span> (result == JSRegExpMatch) {
                    <span class="enscript-comment">// successful backtrack! we're back in the game!
</span>                    <span class="enscript-keyword">if</span> (backTrack-&gt;matchAmount) {
                        context = backTrack-&gt;lastContext;
                        recordParenthesesMatch(term, context);
                    }
                    <span class="enscript-keyword">return</span> JSRegExpMatch;
                }

                <span class="enscript-comment">// pop a match off the stack
</span>                resetMatches(term, context);
                popParenthesesDisjunctionContext(backTrack);
                freeParenthesesDisjunctionContext(context);

                <span class="enscript-keyword">if</span> (result != JSRegExpNoMatch)
                    <span class="enscript-keyword">return</span> result;
            }

            <span class="enscript-keyword">return</span> JSRegExpNoMatch;
        }
        }

        ASSERT_NOT_REACHED();
        <span class="enscript-keyword">return</span> JSRegExpErrorNoMatch;
    }

    <span class="enscript-type">bool</span> matchDotStarEnclosure(ByteTerm&amp; term, DisjunctionContext* context)
    {
        UNUSED_PARAM(term);
        <span class="enscript-type">unsigned</span> matchBegin = context-&gt;matchBegin;

        <span class="enscript-keyword">if</span> (matchBegin) {
            <span class="enscript-keyword">for</span> (matchBegin--; true; matchBegin--) {
                <span class="enscript-keyword">if</span> (testCharacterClass(pattern-&gt;newlineCharacterClass, input.reread(matchBegin))) {
                    ++matchBegin;
                    <span class="enscript-keyword">break</span>;
                }

                <span class="enscript-keyword">if</span> (!matchBegin)
                    <span class="enscript-keyword">break</span>;
            }
        }

        <span class="enscript-type">unsigned</span> matchEnd = input.getPos();

        <span class="enscript-keyword">for</span> (; (matchEnd != input.end())
             &amp;&amp; (!testCharacterClass(pattern-&gt;newlineCharacterClass, input.reread(matchEnd))); matchEnd++) { }

        <span class="enscript-keyword">if</span> (((matchBegin &amp;&amp; term.anchors.m_bol)
             || ((matchEnd != input.end()) &amp;&amp; term.anchors.m_eol))
            &amp;&amp; !pattern-&gt;m_multiline)
            <span class="enscript-keyword">return</span> false;

        context-&gt;matchBegin = matchBegin;
        context-&gt;matchEnd = matchEnd;
        <span class="enscript-keyword">return</span> true;
    }

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MATCH_NEXT</span>() { ++context-&gt;term; goto matchAgain; }
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BACKTRACK</span>() { --context-&gt;term; goto backtrack; }
#<span class="enscript-reference">define</span> <span class="enscript-function-name">currentTerm</span>() (disjunction-&gt;terms[context-&gt;term])
    JSRegExpResult matchDisjunction(ByteDisjunction* disjunction, DisjunctionContext* context, <span class="enscript-type">bool</span> btrack = false)
    {
        <span class="enscript-keyword">if</span> (!--remainingMatchCount)
            <span class="enscript-keyword">return</span> JSRegExpErrorHitLimit;

        <span class="enscript-keyword">if</span> (btrack)
            BACKTRACK();

        context-&gt;matchBegin = input.getPos();
        context-&gt;term = 0;

    <span class="enscript-reference">matchAgain</span>:
        ASSERT(context-&gt;term &lt; static_cast&lt;<span class="enscript-type">int</span>&gt;(disjunction-&gt;terms.size()));

        <span class="enscript-keyword">switch</span> (currentTerm().type) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeSubpatternBegin:
            MATCH_NEXT();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeSubpatternEnd:
            context-&gt;matchEnd = input.getPos();
            <span class="enscript-keyword">return</span> JSRegExpMatch;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeBodyAlternativeBegin:
            MATCH_NEXT();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeBodyAlternativeDisjunction:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeBodyAlternativeEnd:
            context-&gt;matchEnd = input.getPos();
            <span class="enscript-keyword">return</span> JSRegExpMatch;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAlternativeBegin:
            MATCH_NEXT();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAlternativeDisjunction:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAlternativeEnd: {
            <span class="enscript-type">int</span> offset = currentTerm().alternative.end;
            BackTrackInfoAlternative* backTrack = reinterpret_cast&lt;BackTrackInfoAlternative*&gt;(context-&gt;frame + currentTerm().frameLocation);
            backTrack-&gt;offset = offset;
            context-&gt;term += offset;
            MATCH_NEXT();
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAssertionBOL:
            <span class="enscript-keyword">if</span> (matchAssertionBOL(currentTerm()))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAssertionEOL:
            <span class="enscript-keyword">if</span> (matchAssertionEOL(currentTerm()))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAssertionWordBoundary:
            <span class="enscript-keyword">if</span> (matchAssertionWordBoundary(currentTerm()))
                MATCH_NEXT();
            BACKTRACK();

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCharacterOnce:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCharacterFixed: {
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> matchAmount = 0; matchAmount &lt; currentTerm().atom.quantityCount; ++matchAmount) {
                <span class="enscript-keyword">if</span> (!checkCharacter(currentTerm().atom.patternCharacter, currentTerm().inputPosition - matchAmount))
                    BACKTRACK();
            }
            MATCH_NEXT();
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCharacterGreedy: {
            BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + currentTerm().frameLocation);
            <span class="enscript-type">unsigned</span> matchAmount = 0;
            <span class="enscript-keyword">while</span> ((matchAmount &lt; currentTerm().atom.quantityCount) &amp;&amp; input.checkInput(1)) {
                <span class="enscript-keyword">if</span> (!checkCharacter(currentTerm().atom.patternCharacter, currentTerm().inputPosition + 1)) {
                    input.uncheckInput(1);
                    <span class="enscript-keyword">break</span>;
                }
                ++matchAmount;
            }
            backTrack-&gt;matchAmount = matchAmount;

            MATCH_NEXT();
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCharacterNonGreedy: {
            BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + currentTerm().frameLocation);
            backTrack-&gt;matchAmount = 0;
            MATCH_NEXT();
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCasedCharacterOnce:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCasedCharacterFixed: {
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> matchAmount = 0; matchAmount &lt; currentTerm().atom.quantityCount; ++matchAmount) {
                <span class="enscript-keyword">if</span> (!checkCasedCharacter(currentTerm().atom.casedCharacter.lo, currentTerm().atom.casedCharacter.hi, currentTerm().inputPosition - matchAmount))
                    BACKTRACK();
            }
            MATCH_NEXT();
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCasedCharacterGreedy: {
            BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + currentTerm().frameLocation);
            <span class="enscript-type">unsigned</span> matchAmount = 0;
            <span class="enscript-keyword">while</span> ((matchAmount &lt; currentTerm().atom.quantityCount) &amp;&amp; input.checkInput(1)) {
                <span class="enscript-keyword">if</span> (!checkCasedCharacter(currentTerm().atom.casedCharacter.lo, currentTerm().atom.casedCharacter.hi, currentTerm().inputPosition + 1)) {
                    input.uncheckInput(1);
                    <span class="enscript-keyword">break</span>;
                }
                ++matchAmount;
            }
            backTrack-&gt;matchAmount = matchAmount;

            MATCH_NEXT();
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCasedCharacterNonGreedy: {
            BackTrackInfoPatternCharacter* backTrack = reinterpret_cast&lt;BackTrackInfoPatternCharacter*&gt;(context-&gt;frame + currentTerm().frameLocation);
            backTrack-&gt;matchAmount = 0;
            MATCH_NEXT();
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeCharacterClass:
            <span class="enscript-keyword">if</span> (matchCharacterClass(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeBackReference:
            <span class="enscript-keyword">if</span> (matchBackReference(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpattern: {
            JSRegExpResult result = matchParentheses(currentTerm(), context);

            <span class="enscript-keyword">if</span> (result == JSRegExpMatch) {
                MATCH_NEXT();
            }  <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result != JSRegExpNoMatch)
                <span class="enscript-keyword">return</span> result;

            BACKTRACK();
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpatternOnceBegin:
            <span class="enscript-keyword">if</span> (matchParenthesesOnceBegin(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpatternOnceEnd:
            <span class="enscript-keyword">if</span> (matchParenthesesOnceEnd(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpatternTerminalBegin:
            <span class="enscript-keyword">if</span> (matchParenthesesTerminalBegin(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpatternTerminalEnd:
            <span class="enscript-keyword">if</span> (matchParenthesesTerminalEnd(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParentheticalAssertionBegin:
            <span class="enscript-keyword">if</span> (matchParentheticalAssertionBegin(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParentheticalAssertionEnd:
            <span class="enscript-keyword">if</span> (matchParentheticalAssertionEnd(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeCheckInput:
            <span class="enscript-keyword">if</span> (input.checkInput(currentTerm().checkInputCount))
                MATCH_NEXT();
            BACKTRACK();

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeUncheckInput:
            input.uncheckInput(currentTerm().checkInputCount);
            MATCH_NEXT();
                
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeDotStarEnclosure:
            <span class="enscript-keyword">if</span> (matchDotStarEnclosure(currentTerm(), context))
                <span class="enscript-keyword">return</span> JSRegExpMatch;
            BACKTRACK();
        }

        <span class="enscript-comment">// We should never fall-through to here.
</span>        ASSERT_NOT_REACHED();

    <span class="enscript-reference">backtrack</span>:
        ASSERT(context-&gt;term &lt; static_cast&lt;<span class="enscript-type">int</span>&gt;(disjunction-&gt;terms.size()));

        <span class="enscript-keyword">switch</span> (currentTerm().type) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeSubpatternBegin:
            <span class="enscript-keyword">return</span> JSRegExpNoMatch;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeSubpatternEnd:
            ASSERT_NOT_REACHED();

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeBodyAlternativeBegin:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeBodyAlternativeDisjunction: {
            <span class="enscript-type">int</span> offset = currentTerm().alternative.next;
            context-&gt;term += offset;
            <span class="enscript-keyword">if</span> (offset &gt; 0)
                MATCH_NEXT();

            <span class="enscript-keyword">if</span> (input.atEnd())
                <span class="enscript-keyword">return</span> JSRegExpNoMatch;

            input.next();

            context-&gt;matchBegin = input.getPos();

            <span class="enscript-keyword">if</span> (currentTerm().alternative.onceThrough)
                context-&gt;term += currentTerm().alternative.next;

            MATCH_NEXT();
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeBodyAlternativeEnd:
            ASSERT_NOT_REACHED();

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAlternativeBegin:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAlternativeDisjunction: {
            <span class="enscript-type">int</span> offset = currentTerm().alternative.next;
            context-&gt;term += offset;
            <span class="enscript-keyword">if</span> (offset &gt; 0)
                MATCH_NEXT();
            BACKTRACK();
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAlternativeEnd: {
            <span class="enscript-comment">// We should never backtrack back into an alternative of the main body of the regex.
</span>            BackTrackInfoAlternative* backTrack = reinterpret_cast&lt;BackTrackInfoAlternative*&gt;(context-&gt;frame + currentTerm().frameLocation);
            <span class="enscript-type">unsigned</span> offset = backTrack-&gt;offset;
            context-&gt;term -= offset;
            BACKTRACK();
        }

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAssertionBOL:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAssertionEOL:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeAssertionWordBoundary:
            BACKTRACK();

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCharacterOnce:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCharacterFixed:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCharacterGreedy:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCharacterNonGreedy:
            <span class="enscript-keyword">if</span> (backtrackPatternCharacter(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCasedCharacterOnce:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCasedCharacterFixed:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCasedCharacterGreedy:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypePatternCasedCharacterNonGreedy:
            <span class="enscript-keyword">if</span> (backtrackPatternCasedCharacter(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeCharacterClass:
            <span class="enscript-keyword">if</span> (backtrackCharacterClass(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeBackReference:
            <span class="enscript-keyword">if</span> (backtrackBackReference(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpattern: {
            JSRegExpResult result = backtrackParentheses(currentTerm(), context);

            <span class="enscript-keyword">if</span> (result == JSRegExpMatch) {
                MATCH_NEXT();
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result != JSRegExpNoMatch)
                <span class="enscript-keyword">return</span> result;

            BACKTRACK();
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpatternOnceBegin:
            <span class="enscript-keyword">if</span> (backtrackParenthesesOnceBegin(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpatternOnceEnd:
            <span class="enscript-keyword">if</span> (backtrackParenthesesOnceEnd(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpatternTerminalBegin:
            <span class="enscript-keyword">if</span> (backtrackParenthesesTerminalBegin(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParenthesesSubpatternTerminalEnd:
            <span class="enscript-keyword">if</span> (backtrackParenthesesTerminalEnd(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParentheticalAssertionBegin:
            <span class="enscript-keyword">if</span> (backtrackParentheticalAssertionBegin(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeParentheticalAssertionEnd:
            <span class="enscript-keyword">if</span> (backtrackParentheticalAssertionEnd(currentTerm(), context))
                MATCH_NEXT();
            BACKTRACK();

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeCheckInput:
            input.uncheckInput(currentTerm().checkInputCount);
            BACKTRACK();

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeUncheckInput:
            input.checkInput(currentTerm().checkInputCount);
            BACKTRACK();

        <span class="enscript-keyword">case</span> <span class="enscript-reference">ByteTerm</span>::TypeDotStarEnclosure:
            ASSERT_NOT_REACHED();
        }

        ASSERT_NOT_REACHED();
        <span class="enscript-keyword">return</span> JSRegExpErrorNoMatch;
    }

    JSRegExpResult matchNonZeroDisjunction(ByteDisjunction* disjunction, DisjunctionContext* context, <span class="enscript-type">bool</span> btrack = false)
    {
        JSRegExpResult result = matchDisjunction(disjunction, context, btrack);

        <span class="enscript-keyword">if</span> (result == JSRegExpMatch) {
            <span class="enscript-keyword">while</span> (context-&gt;matchBegin == context-&gt;matchEnd) {
                result = matchDisjunction(disjunction, context, true);
                <span class="enscript-keyword">if</span> (result != JSRegExpMatch)
                    <span class="enscript-keyword">return</span> result;
            }
            <span class="enscript-keyword">return</span> JSRegExpMatch;
        }

        <span class="enscript-keyword">return</span> result;
    }

    <span class="enscript-type">unsigned</span> interpret()
    {
        <span class="enscript-keyword">if</span> (!input.isAvailableInput(0))
            <span class="enscript-keyword">return</span> offsetNoMatch;

        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; pattern-&gt;m_body-&gt;m_numSubpatterns + 1; ++i)
            output[i &lt;&lt; 1] = offsetNoMatch;

        allocatorPool = pattern-&gt;m_allocator-&gt;startAllocator();
        <span class="enscript-keyword">if</span> (!allocatorPool)
            CRASH();

        DisjunctionContext* context = allocDisjunctionContext(pattern-&gt;m_body.get());

        JSRegExpResult result = matchDisjunction(pattern-&gt;m_body.get(), context, false);
        <span class="enscript-keyword">if</span> (result == JSRegExpMatch) {
            output[0] = context-&gt;matchBegin;
            output[1] = context-&gt;matchEnd;
        }

        freeDisjunctionContext(context);

        pattern-&gt;m_allocator-&gt;stopAllocator();

        ASSERT((result == JSRegExpMatch) == (output[0] != offsetNoMatch));
        <span class="enscript-keyword">return</span> output[0];
    }

    Interpreter(BytecodePattern* pattern, <span class="enscript-type">unsigned</span>* output, <span class="enscript-type">const</span> CharType* input, <span class="enscript-type">unsigned</span> length, <span class="enscript-type">unsigned</span> start)
        : pattern(pattern)
        , output(output)
        , input(input, start, length)
        , allocatorPool(0)
        , remainingMatchCount(matchLimit)
    {
    }

<span class="enscript-type">private</span>:
    BytecodePattern* pattern;
    <span class="enscript-type">unsigned</span>* output;
    InputStream input;
    BumpPointerPool* allocatorPool;
    <span class="enscript-type">unsigned</span> remainingMatchCount;
};



<span class="enscript-type">class</span> ByteCompiler {
    <span class="enscript-type">struct</span> ParenthesesStackEntry {
        <span class="enscript-type">unsigned</span> beginTerm;
        <span class="enscript-type">unsigned</span> savedAlternativeIndex;
        ParenthesesStackEntry(<span class="enscript-type">unsigned</span> beginTerm, <span class="enscript-type">unsigned</span> savedAlternativeIndex<span class="enscript-comment">/*, unsigned subpatternId, bool capture = false*/</span>)
            : beginTerm(beginTerm)
            , savedAlternativeIndex(savedAlternativeIndex)
        {
        }
    };

<span class="enscript-type">public</span>:
    ByteCompiler(YarrPattern&amp; pattern)
        : m_pattern(pattern)
    {
        m_currentAlternativeIndex = 0;
    }

    PassOwnPtr&lt;BytecodePattern&gt; compile(BumpPointerAllocator* allocator)
    {
        regexBegin(m_pattern.m_numSubpatterns, m_pattern.m_body-&gt;m_callFrameSize, m_pattern.m_body-&gt;m_alternatives[0]-&gt;onceThrough());
        emitDisjunction(m_pattern.m_body);
        regexEnd();

        <span class="enscript-keyword">return</span> adoptPtr(<span class="enscript-keyword">new</span> BytecodePattern(m_bodyDisjunction.release(), m_allParenthesesInfo, m_pattern, allocator));
    }

    <span class="enscript-type">void</span> checkInput(<span class="enscript-type">unsigned</span> count)
    {
        m_bodyDisjunction-&gt;terms.append(ByteTerm::CheckInput(count));
    }

    <span class="enscript-type">void</span> uncheckInput(<span class="enscript-type">unsigned</span> count)
    {
        m_bodyDisjunction-&gt;terms.append(ByteTerm::UncheckInput(count));
    }
    
    <span class="enscript-type">void</span> assertionBOL(<span class="enscript-type">unsigned</span> inputPosition)
    {
        m_bodyDisjunction-&gt;terms.append(ByteTerm::BOL(inputPosition));
    }

    <span class="enscript-type">void</span> assertionEOL(<span class="enscript-type">unsigned</span> inputPosition)
    {
        m_bodyDisjunction-&gt;terms.append(ByteTerm::EOL(inputPosition));
    }

    <span class="enscript-type">void</span> assertionWordBoundary(<span class="enscript-type">bool</span> invert, <span class="enscript-type">unsigned</span> inputPosition)
    {
        m_bodyDisjunction-&gt;terms.append(ByteTerm::WordBoundary(invert, inputPosition));
    }

    <span class="enscript-type">void</span> atomPatternCharacter(UChar ch, <span class="enscript-type">unsigned</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, Checked&lt;<span class="enscript-type">unsigned</span>&gt; quantityCount, QuantifierType quantityType)
    {
        <span class="enscript-keyword">if</span> (m_pattern.m_ignoreCase) {
            UChar lo = Unicode::toLower(ch);
            UChar hi = Unicode::toUpper(ch);

            <span class="enscript-keyword">if</span> (lo != hi) {
                m_bodyDisjunction-&gt;terms.append(ByteTerm(lo, hi, inputPosition, frameLocation, quantityCount, quantityType));
                <span class="enscript-keyword">return</span>;
            }
        }

        m_bodyDisjunction-&gt;terms.append(ByteTerm(ch, inputPosition, frameLocation, quantityCount, quantityType));
    }

    <span class="enscript-type">void</span> atomCharacterClass(CharacterClass* characterClass, <span class="enscript-type">bool</span> invert, <span class="enscript-type">unsigned</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, Checked&lt;<span class="enscript-type">unsigned</span>&gt; quantityCount, QuantifierType quantityType)
    {
        m_bodyDisjunction-&gt;terms.append(ByteTerm(characterClass, invert, inputPosition));

        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].atom.quantityCount = quantityCount.unsafeGet();
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].atom.quantityType = quantityType;
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = frameLocation;
    }

    <span class="enscript-type">void</span> atomBackReference(<span class="enscript-type">unsigned</span> subpatternId, <span class="enscript-type">unsigned</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, Checked&lt;<span class="enscript-type">unsigned</span>&gt; quantityCount, QuantifierType quantityType)
    {
        ASSERT(subpatternId);

        m_bodyDisjunction-&gt;terms.append(ByteTerm::BackReference(subpatternId, inputPosition));

        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].atom.quantityCount = quantityCount.unsafeGet();
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].atom.quantityType = quantityType;
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = frameLocation;
    }

    <span class="enscript-type">void</span> atomParenthesesOnceBegin(<span class="enscript-type">unsigned</span> subpatternId, <span class="enscript-type">bool</span> capture, <span class="enscript-type">unsigned</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, <span class="enscript-type">unsigned</span> alternativeFrameLocation)
    {
        <span class="enscript-type">int</span> beginTerm = m_bodyDisjunction-&gt;terms.size();

        m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternOnceBegin, subpatternId, capture, false, inputPosition));
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = frameLocation;
        m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeBegin());
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = alternativeFrameLocation;

        m_parenthesesStack.append(ParenthesesStackEntry(beginTerm, m_currentAlternativeIndex));
        m_currentAlternativeIndex = beginTerm + 1;
    }

    <span class="enscript-type">void</span> atomParenthesesTerminalBegin(<span class="enscript-type">unsigned</span> subpatternId, <span class="enscript-type">bool</span> capture, <span class="enscript-type">unsigned</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, <span class="enscript-type">unsigned</span> alternativeFrameLocation)
    {
        <span class="enscript-type">int</span> beginTerm = m_bodyDisjunction-&gt;terms.size();

        m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternTerminalBegin, subpatternId, capture, false, inputPosition));
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = frameLocation;
        m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeBegin());
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = alternativeFrameLocation;

        m_parenthesesStack.append(ParenthesesStackEntry(beginTerm, m_currentAlternativeIndex));
        m_currentAlternativeIndex = beginTerm + 1;
    }

    <span class="enscript-type">void</span> atomParenthesesSubpatternBegin(<span class="enscript-type">unsigned</span> subpatternId, <span class="enscript-type">bool</span> capture, <span class="enscript-type">unsigned</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, <span class="enscript-type">unsigned</span> alternativeFrameLocation)
    {
        <span class="enscript-comment">// Errrk! - this is a little crazy, we initially generate as a TypeParenthesesSubpatternOnceBegin,
</span>        <span class="enscript-comment">// then fix this up at the end! - simplifying this should make it much clearer.
</span>        <span class="enscript-comment">// <a href="https://bugs.webkit.org/show_bug.cgi?id=50136">https://bugs.webkit.org/show_bug.cgi?id=50136</a>
</span>
        <span class="enscript-type">int</span> beginTerm = m_bodyDisjunction-&gt;terms.size();

        m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternOnceBegin, subpatternId, capture, false, inputPosition));
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = frameLocation;
        m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeBegin());
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = alternativeFrameLocation;

        m_parenthesesStack.append(ParenthesesStackEntry(beginTerm, m_currentAlternativeIndex));
        m_currentAlternativeIndex = beginTerm + 1;
    }

    <span class="enscript-type">void</span> atomParentheticalAssertionBegin(<span class="enscript-type">unsigned</span> subpatternId, <span class="enscript-type">bool</span> invert, <span class="enscript-type">unsigned</span> frameLocation, <span class="enscript-type">unsigned</span> alternativeFrameLocation)
    {
        <span class="enscript-type">int</span> beginTerm = m_bodyDisjunction-&gt;terms.size();

        m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParentheticalAssertionBegin, subpatternId, false, invert, 0));
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = frameLocation;
        m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeBegin());
        m_bodyDisjunction-&gt;terms[m_bodyDisjunction-&gt;terms.size() - 1].frameLocation = alternativeFrameLocation;

        m_parenthesesStack.append(ParenthesesStackEntry(beginTerm, m_currentAlternativeIndex));
        m_currentAlternativeIndex = beginTerm + 1;
    }

    <span class="enscript-type">void</span> atomParentheticalAssertionEnd(<span class="enscript-type">unsigned</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, Checked&lt;<span class="enscript-type">unsigned</span>&gt; quantityCount, QuantifierType quantityType)
    {
        <span class="enscript-type">unsigned</span> beginTerm = popParenthesesStack();
        closeAlternative(beginTerm + 1);
        <span class="enscript-type">unsigned</span> endTerm = m_bodyDisjunction-&gt;terms.size();

        ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeParentheticalAssertionBegin);

        <span class="enscript-type">bool</span> invert = m_bodyDisjunction-&gt;terms[beginTerm].invert();
        <span class="enscript-type">unsigned</span> subpatternId = m_bodyDisjunction-&gt;terms[beginTerm].atom.subpatternId;

        m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParentheticalAssertionEnd, subpatternId, false, invert, inputPosition));
        m_bodyDisjunction-&gt;terms[beginTerm].atom.parenthesesWidth = endTerm - beginTerm;
        m_bodyDisjunction-&gt;terms[endTerm].atom.parenthesesWidth = endTerm - beginTerm;
        m_bodyDisjunction-&gt;terms[endTerm].frameLocation = frameLocation;

        m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityCount = quantityCount.unsafeGet();
        m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityType = quantityType;
        m_bodyDisjunction-&gt;terms[endTerm].atom.quantityCount = quantityCount.unsafeGet();
        m_bodyDisjunction-&gt;terms[endTerm].atom.quantityType = quantityType;
    }

    <span class="enscript-type">void</span> assertionDotStarEnclosure(<span class="enscript-type">bool</span> bolAnchored, <span class="enscript-type">bool</span> eolAnchored)
    {
        m_bodyDisjunction-&gt;terms.append(ByteTerm::DotStarEnclosure(bolAnchored, eolAnchored));
    }

    <span class="enscript-type">unsigned</span> popParenthesesStack()
    {
        ASSERT(m_parenthesesStack.size());
        <span class="enscript-type">int</span> stackEnd = m_parenthesesStack.size() - 1;
        <span class="enscript-type">unsigned</span> beginTerm = m_parenthesesStack[stackEnd].beginTerm;
        m_currentAlternativeIndex = m_parenthesesStack[stackEnd].savedAlternativeIndex;
        m_parenthesesStack.shrink(stackEnd);

        ASSERT(beginTerm &lt; m_bodyDisjunction-&gt;terms.size());
        ASSERT(m_currentAlternativeIndex &lt; m_bodyDisjunction-&gt;terms.size());

        <span class="enscript-keyword">return</span> beginTerm;
    }

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NDEBUG</span>
    <span class="enscript-type">void</span> dumpDisjunction(ByteDisjunction* disjunction)
    {
        dataLog(<span class="enscript-string">&quot;ByteDisjunction(%p):\n\t&quot;</span>, disjunction);
        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; disjunction-&gt;terms.size(); ++i)
            dataLog(<span class="enscript-string">&quot;{ %d } &quot;</span>, disjunction-&gt;terms[i].type);
        dataLog(<span class="enscript-string">&quot;\n&quot;</span>);
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-type">void</span> closeAlternative(<span class="enscript-type">int</span> beginTerm)
    {
        <span class="enscript-type">int</span> origBeginTerm = beginTerm;
        ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeAlternativeBegin);
        <span class="enscript-type">int</span> endIndex = m_bodyDisjunction-&gt;terms.size();

        <span class="enscript-type">unsigned</span> frameLocation = m_bodyDisjunction-&gt;terms[beginTerm].frameLocation;

        <span class="enscript-keyword">if</span> (!m_bodyDisjunction-&gt;terms[beginTerm].alternative.next)
            m_bodyDisjunction-&gt;terms.remove(beginTerm);
        <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">while</span> (m_bodyDisjunction-&gt;terms[beginTerm].alternative.next) {
                beginTerm += m_bodyDisjunction-&gt;terms[beginTerm].alternative.next;
                ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeAlternativeDisjunction);
                m_bodyDisjunction-&gt;terms[beginTerm].alternative.end = endIndex - beginTerm;
                m_bodyDisjunction-&gt;terms[beginTerm].frameLocation = frameLocation;
            }

            m_bodyDisjunction-&gt;terms[beginTerm].alternative.next = origBeginTerm - beginTerm;

            m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeEnd());
            m_bodyDisjunction-&gt;terms[endIndex].frameLocation = frameLocation;
        }
    }

    <span class="enscript-type">void</span> closeBodyAlternative()
    {
        <span class="enscript-type">int</span> beginTerm = 0;
        <span class="enscript-type">int</span> origBeginTerm = 0;
        ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeBodyAlternativeBegin);
        <span class="enscript-type">int</span> endIndex = m_bodyDisjunction-&gt;terms.size();

        <span class="enscript-type">unsigned</span> frameLocation = m_bodyDisjunction-&gt;terms[beginTerm].frameLocation;

        <span class="enscript-keyword">while</span> (m_bodyDisjunction-&gt;terms[beginTerm].alternative.next) {
            beginTerm += m_bodyDisjunction-&gt;terms[beginTerm].alternative.next;
            ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeBodyAlternativeDisjunction);
            m_bodyDisjunction-&gt;terms[beginTerm].alternative.end = endIndex - beginTerm;
            m_bodyDisjunction-&gt;terms[beginTerm].frameLocation = frameLocation;
        }

        m_bodyDisjunction-&gt;terms[beginTerm].alternative.next = origBeginTerm - beginTerm;

        m_bodyDisjunction-&gt;terms.append(ByteTerm::BodyAlternativeEnd());
        m_bodyDisjunction-&gt;terms[endIndex].frameLocation = frameLocation;
    }

    <span class="enscript-type">void</span> atomParenthesesSubpatternEnd(<span class="enscript-type">unsigned</span> lastSubpatternId, <span class="enscript-type">int</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, Checked&lt;<span class="enscript-type">unsigned</span>&gt; quantityCount, QuantifierType quantityType, <span class="enscript-type">unsigned</span> callFrameSize = 0)
    {
        <span class="enscript-type">unsigned</span> beginTerm = popParenthesesStack();
        closeAlternative(beginTerm + 1);
        <span class="enscript-type">unsigned</span> endTerm = m_bodyDisjunction-&gt;terms.size();

        ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeParenthesesSubpatternOnceBegin);

        ByteTerm&amp; parenthesesBegin = m_bodyDisjunction-&gt;terms[beginTerm];

        <span class="enscript-type">bool</span> capture = parenthesesBegin.capture();
        <span class="enscript-type">unsigned</span> subpatternId = parenthesesBegin.atom.subpatternId;

        <span class="enscript-type">unsigned</span> numSubpatterns = lastSubpatternId - subpatternId + 1;
        ByteDisjunction* parenthesesDisjunction = <span class="enscript-keyword">new</span> ByteDisjunction(numSubpatterns, callFrameSize);

        parenthesesDisjunction-&gt;terms.append(ByteTerm::SubpatternBegin());
        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> termInParentheses = beginTerm + 1; termInParentheses &lt; endTerm; ++termInParentheses)
            parenthesesDisjunction-&gt;terms.append(m_bodyDisjunction-&gt;terms[termInParentheses]);
        parenthesesDisjunction-&gt;terms.append(ByteTerm::SubpatternEnd());

        m_bodyDisjunction-&gt;terms.shrink(beginTerm);

        m_allParenthesesInfo.append(parenthesesDisjunction);
        m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpattern, subpatternId, parenthesesDisjunction, capture, inputPosition));

        m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityCount = quantityCount.unsafeGet();
        m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityType = quantityType;
        m_bodyDisjunction-&gt;terms[beginTerm].frameLocation = frameLocation;
    }

    <span class="enscript-type">void</span> atomParenthesesOnceEnd(<span class="enscript-type">int</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, Checked&lt;<span class="enscript-type">unsigned</span>&gt; quantityCount, QuantifierType quantityType)
    {
        <span class="enscript-type">unsigned</span> beginTerm = popParenthesesStack();
        closeAlternative(beginTerm + 1);
        <span class="enscript-type">unsigned</span> endTerm = m_bodyDisjunction-&gt;terms.size();

        ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeParenthesesSubpatternOnceBegin);

        <span class="enscript-type">bool</span> capture = m_bodyDisjunction-&gt;terms[beginTerm].capture();
        <span class="enscript-type">unsigned</span> subpatternId = m_bodyDisjunction-&gt;terms[beginTerm].atom.subpatternId;

        m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternOnceEnd, subpatternId, capture, false, inputPosition));
        m_bodyDisjunction-&gt;terms[beginTerm].atom.parenthesesWidth = endTerm - beginTerm;
        m_bodyDisjunction-&gt;terms[endTerm].atom.parenthesesWidth = endTerm - beginTerm;
        m_bodyDisjunction-&gt;terms[endTerm].frameLocation = frameLocation;

        m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityCount = quantityCount.unsafeGet();
        m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityType = quantityType;
        m_bodyDisjunction-&gt;terms[endTerm].atom.quantityCount = quantityCount.unsafeGet();
        m_bodyDisjunction-&gt;terms[endTerm].atom.quantityType = quantityType;
    }

    <span class="enscript-type">void</span> atomParenthesesTerminalEnd(<span class="enscript-type">int</span> inputPosition, <span class="enscript-type">unsigned</span> frameLocation, Checked&lt;<span class="enscript-type">unsigned</span>&gt; quantityCount, QuantifierType quantityType)
    {
        <span class="enscript-type">unsigned</span> beginTerm = popParenthesesStack();
        closeAlternative(beginTerm + 1);
        <span class="enscript-type">unsigned</span> endTerm = m_bodyDisjunction-&gt;terms.size();

        ASSERT(m_bodyDisjunction-&gt;terms[beginTerm].type == ByteTerm::TypeParenthesesSubpatternTerminalBegin);

        <span class="enscript-type">bool</span> capture = m_bodyDisjunction-&gt;terms[beginTerm].capture();
        <span class="enscript-type">unsigned</span> subpatternId = m_bodyDisjunction-&gt;terms[beginTerm].atom.subpatternId;

        m_bodyDisjunction-&gt;terms.append(ByteTerm(ByteTerm::TypeParenthesesSubpatternTerminalEnd, subpatternId, capture, false, inputPosition));
        m_bodyDisjunction-&gt;terms[beginTerm].atom.parenthesesWidth = endTerm - beginTerm;
        m_bodyDisjunction-&gt;terms[endTerm].atom.parenthesesWidth = endTerm - beginTerm;
        m_bodyDisjunction-&gt;terms[endTerm].frameLocation = frameLocation;

        m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityCount = quantityCount.unsafeGet();
        m_bodyDisjunction-&gt;terms[beginTerm].atom.quantityType = quantityType;
        m_bodyDisjunction-&gt;terms[endTerm].atom.quantityCount = quantityCount.unsafeGet();
        m_bodyDisjunction-&gt;terms[endTerm].atom.quantityType = quantityType;
    }

    <span class="enscript-type">void</span> regexBegin(<span class="enscript-type">unsigned</span> numSubpatterns, <span class="enscript-type">unsigned</span> callFrameSize, <span class="enscript-type">bool</span> onceThrough)
    {
        m_bodyDisjunction = adoptPtr(<span class="enscript-keyword">new</span> ByteDisjunction(numSubpatterns, callFrameSize));
        m_bodyDisjunction-&gt;terms.append(ByteTerm::BodyAlternativeBegin(onceThrough));
        m_bodyDisjunction-&gt;terms[0].frameLocation = 0;
        m_currentAlternativeIndex = 0;
    }

    <span class="enscript-type">void</span> regexEnd()
    {
        closeBodyAlternative();
    }

    <span class="enscript-type">void</span> alternativeBodyDisjunction(<span class="enscript-type">bool</span> onceThrough)
    {
        <span class="enscript-type">int</span> newAlternativeIndex = m_bodyDisjunction-&gt;terms.size();
        m_bodyDisjunction-&gt;terms[m_currentAlternativeIndex].alternative.next = newAlternativeIndex - m_currentAlternativeIndex;
        m_bodyDisjunction-&gt;terms.append(ByteTerm::BodyAlternativeDisjunction(onceThrough));

        m_currentAlternativeIndex = newAlternativeIndex;
    }

    <span class="enscript-type">void</span> alternativeDisjunction()
    {
        <span class="enscript-type">int</span> newAlternativeIndex = m_bodyDisjunction-&gt;terms.size();
        m_bodyDisjunction-&gt;terms[m_currentAlternativeIndex].alternative.next = newAlternativeIndex - m_currentAlternativeIndex;
        m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeDisjunction());

        m_currentAlternativeIndex = newAlternativeIndex;
    }

    <span class="enscript-type">void</span> emitDisjunction(PatternDisjunction* disjunction, <span class="enscript-type">unsigned</span> inputCountAlreadyChecked = 0, <span class="enscript-type">unsigned</span> parenthesesInputCountAlreadyChecked = 0)
    {
        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
            <span class="enscript-type">unsigned</span> currentCountAlreadyChecked = inputCountAlreadyChecked;

            PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt];

            <span class="enscript-keyword">if</span> (alt) {
                <span class="enscript-keyword">if</span> (disjunction == m_pattern.m_body)
                    alternativeBodyDisjunction(alternative-&gt;onceThrough());
                <span class="enscript-keyword">else</span>
                    alternativeDisjunction();
            }

            <span class="enscript-type">unsigned</span> minimumSize = alternative-&gt;m_minimumSize;
            ASSERT(minimumSize &gt;= parenthesesInputCountAlreadyChecked);
            <span class="enscript-type">unsigned</span> countToCheck = minimumSize - parenthesesInputCountAlreadyChecked;

            <span class="enscript-keyword">if</span> (countToCheck) {
                checkInput(countToCheck);
                currentCountAlreadyChecked += countToCheck;
            }

            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; alternative-&gt;m_terms.size(); ++i) {
                PatternTerm&amp; term = alternative-&gt;m_terms[i];

                <span class="enscript-keyword">switch</span> (term.type) {
                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeAssertionBOL:
                    assertionBOL(currentCountAlreadyChecked - term.inputPosition);
                    <span class="enscript-keyword">break</span>;

                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeAssertionEOL:
                    assertionEOL(currentCountAlreadyChecked - term.inputPosition);
                    <span class="enscript-keyword">break</span>;

                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeAssertionWordBoundary:
                    assertionWordBoundary(term.invert(), currentCountAlreadyChecked - term.inputPosition);
                    <span class="enscript-keyword">break</span>;

                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypePatternCharacter:
                    atomPatternCharacter(term.patternCharacter, currentCountAlreadyChecked - term.inputPosition, term.frameLocation, term.quantityCount, term.quantityType);
                    <span class="enscript-keyword">break</span>;

                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeCharacterClass:
                    atomCharacterClass(term.characterClass, term.invert(), currentCountAlreadyChecked- term.inputPosition, term.frameLocation, term.quantityCount, term.quantityType);
                    <span class="enscript-keyword">break</span>;

                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeBackReference:
                    atomBackReference(term.backReferenceSubpatternId, currentCountAlreadyChecked - term.inputPosition, term.frameLocation, term.quantityCount, term.quantityType);
                        <span class="enscript-keyword">break</span>;

                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeForwardReference:
                    <span class="enscript-keyword">break</span>;

                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeParenthesesSubpattern: {
                    <span class="enscript-type">unsigned</span> disjunctionAlreadyCheckedCount = 0;
                    <span class="enscript-keyword">if</span> (term.quantityCount == 1 &amp;&amp; !term.parentheses.isCopy) {
                        <span class="enscript-type">unsigned</span> alternativeFrameLocation = term.frameLocation;
                        <span class="enscript-comment">// For QuantifierFixedCount we pre-check the minimum size; for greedy/non-greedy we reserve a slot in the frame.
</span>                        <span class="enscript-keyword">if</span> (term.quantityType == QuantifierFixedCount)
                            disjunctionAlreadyCheckedCount = term.parentheses.disjunction-&gt;m_minimumSize;
                        <span class="enscript-keyword">else</span>
                            alternativeFrameLocation += YarrStackSpaceForBackTrackInfoParenthesesOnce;
                        <span class="enscript-type">unsigned</span> delegateEndInputOffset = term.inputPosition - currentCountAlreadyChecked;
                        atomParenthesesOnceBegin(term.parentheses.subpatternId, term.capture(), disjunctionAlreadyCheckedCount - delegateEndInputOffset, term.frameLocation, alternativeFrameLocation);
                        emitDisjunction(term.parentheses.disjunction, currentCountAlreadyChecked, disjunctionAlreadyCheckedCount);
                        atomParenthesesOnceEnd(delegateEndInputOffset, term.frameLocation, term.quantityCount, term.quantityType);
                    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (term.parentheses.isTerminal) {
                        <span class="enscript-type">unsigned</span> delegateEndInputOffset = term.inputPosition - currentCountAlreadyChecked;
                        atomParenthesesTerminalBegin(term.parentheses.subpatternId, term.capture(), disjunctionAlreadyCheckedCount - delegateEndInputOffset, term.frameLocation, term.frameLocation + YarrStackSpaceForBackTrackInfoParenthesesOnce);
                        emitDisjunction(term.parentheses.disjunction, currentCountAlreadyChecked, disjunctionAlreadyCheckedCount);
                        atomParenthesesTerminalEnd(delegateEndInputOffset, term.frameLocation, term.quantityCount, term.quantityType);
                    } <span class="enscript-keyword">else</span> {
                        <span class="enscript-type">unsigned</span> delegateEndInputOffset = term.inputPosition - currentCountAlreadyChecked;
                        atomParenthesesSubpatternBegin(term.parentheses.subpatternId, term.capture(), disjunctionAlreadyCheckedCount - delegateEndInputOffset, term.frameLocation, 0);
                        emitDisjunction(term.parentheses.disjunction, currentCountAlreadyChecked, 0);
                        atomParenthesesSubpatternEnd(term.parentheses.lastSubpatternId, delegateEndInputOffset, term.frameLocation, term.quantityCount, term.quantityType, term.parentheses.disjunction-&gt;m_callFrameSize);
                    }
                    <span class="enscript-keyword">break</span>;
                }

                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeParentheticalAssertion: {
                    <span class="enscript-type">unsigned</span> alternativeFrameLocation = term.frameLocation + YarrStackSpaceForBackTrackInfoParentheticalAssertion;

                    ASSERT(currentCountAlreadyChecked &gt;= static_cast&lt;<span class="enscript-type">unsigned</span>&gt;(term.inputPosition));
                    <span class="enscript-type">unsigned</span> positiveInputOffset = currentCountAlreadyChecked - static_cast&lt;<span class="enscript-type">unsigned</span>&gt;(term.inputPosition);
                    <span class="enscript-type">unsigned</span> uncheckAmount = 0;
                    <span class="enscript-keyword">if</span> (positiveInputOffset &gt; term.parentheses.disjunction-&gt;m_minimumSize) {
                        uncheckAmount = positiveInputOffset - term.parentheses.disjunction-&gt;m_minimumSize;
                        uncheckInput(uncheckAmount);
                        currentCountAlreadyChecked -= uncheckAmount;
                    }

                    atomParentheticalAssertionBegin(term.parentheses.subpatternId, term.invert(), term.frameLocation, alternativeFrameLocation);
                    emitDisjunction(term.parentheses.disjunction, currentCountAlreadyChecked, positiveInputOffset - uncheckAmount);
                    atomParentheticalAssertionEnd(0, term.frameLocation, term.quantityCount, term.quantityType);
                    <span class="enscript-keyword">if</span> (uncheckAmount) {
                        checkInput(uncheckAmount);
                        currentCountAlreadyChecked += uncheckAmount;
                    }
                    <span class="enscript-keyword">break</span>;
                }

                <span class="enscript-keyword">case</span> <span class="enscript-reference">PatternTerm</span>::TypeDotStarEnclosure:
                    assertionDotStarEnclosure(term.anchors.bolAnchor, term.anchors.eolAnchor);
                    <span class="enscript-keyword">break</span>;
                }
            }
        }
    }

<span class="enscript-type">private</span>:
    YarrPattern&amp; m_pattern;
    OwnPtr&lt;ByteDisjunction&gt; m_bodyDisjunction;
    <span class="enscript-type">unsigned</span> m_currentAlternativeIndex;
    Vector&lt;ParenthesesStackEntry&gt; m_parenthesesStack;
    Vector&lt;ByteDisjunction*&gt; m_allParenthesesInfo;
};

PassOwnPtr&lt;BytecodePattern&gt; byteCompile(YarrPattern&amp; pattern, BumpPointerAllocator* allocator)
{
    <span class="enscript-keyword">return</span> ByteCompiler(pattern).compile(allocator);
}

<span class="enscript-type">unsigned</span> <span class="enscript-function-name">interpret</span>(BytecodePattern* bytecode, <span class="enscript-type">const</span> UString&amp; input, <span class="enscript-type">unsigned</span> start, <span class="enscript-type">unsigned</span>* output)
{
    <span class="enscript-keyword">if</span> (input.is8Bit())
        <span class="enscript-keyword">return</span> Interpreter&lt;LChar&gt;(bytecode, output, input.characters8(), input.length(), start).interpret();
    <span class="enscript-keyword">return</span> Interpreter&lt;UChar&gt;(bytecode, output, input.characters16(), input.length(), start).interpret();
}

<span class="enscript-type">unsigned</span> <span class="enscript-function-name">interpret</span>(BytecodePattern* bytecode, <span class="enscript-type">const</span> LChar* input, <span class="enscript-type">unsigned</span> length, <span class="enscript-type">unsigned</span> start, <span class="enscript-type">unsigned</span>* output)
{
    <span class="enscript-keyword">return</span> Interpreter&lt;LChar&gt;(bytecode, output, input, length, start).interpret();
}

<span class="enscript-type">unsigned</span> <span class="enscript-function-name">interpret</span>(BytecodePattern* bytecode, <span class="enscript-type">const</span> UChar* input, <span class="enscript-type">unsigned</span> length, <span class="enscript-type">unsigned</span> start, <span class="enscript-type">unsigned</span>* output)
{
    <span class="enscript-keyword">return</span> Interpreter&lt;UChar&gt;(bytecode, output, input, length, start).interpret();
}

<span class="enscript-comment">// These should be the same for both UChar &amp; LChar.
</span><span class="enscript-function-name">COMPILE_ASSERT</span>(<span class="enscript-keyword">sizeof</span>(Interpreter&lt;UChar&gt;::BackTrackInfoPatternCharacter) == (YarrStackSpaceForBackTrackInfoPatternCharacter * <span class="enscript-keyword">sizeof</span>(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoPatternCharacter);
<span class="enscript-function-name">COMPILE_ASSERT</span>(<span class="enscript-keyword">sizeof</span>(Interpreter&lt;UChar&gt;::BackTrackInfoCharacterClass) == (YarrStackSpaceForBackTrackInfoCharacterClass * <span class="enscript-keyword">sizeof</span>(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoCharacterClass);
<span class="enscript-function-name">COMPILE_ASSERT</span>(<span class="enscript-keyword">sizeof</span>(Interpreter&lt;UChar&gt;::BackTrackInfoBackReference) == (YarrStackSpaceForBackTrackInfoBackReference * <span class="enscript-keyword">sizeof</span>(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoBackReference);
<span class="enscript-function-name">COMPILE_ASSERT</span>(<span class="enscript-keyword">sizeof</span>(Interpreter&lt;UChar&gt;::BackTrackInfoAlternative) == (YarrStackSpaceForBackTrackInfoAlternative * <span class="enscript-keyword">sizeof</span>(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoAlternative);
<span class="enscript-function-name">COMPILE_ASSERT</span>(<span class="enscript-keyword">sizeof</span>(Interpreter&lt;UChar&gt;::BackTrackInfoParentheticalAssertion) == (YarrStackSpaceForBackTrackInfoParentheticalAssertion * <span class="enscript-keyword">sizeof</span>(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoParentheticalAssertion);
<span class="enscript-function-name">COMPILE_ASSERT</span>(<span class="enscript-keyword">sizeof</span>(Interpreter&lt;UChar&gt;::BackTrackInfoParenthesesOnce) == (YarrStackSpaceForBackTrackInfoParenthesesOnce * <span class="enscript-keyword">sizeof</span>(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoParenthesesOnce);
<span class="enscript-function-name">COMPILE_ASSERT</span>(<span class="enscript-keyword">sizeof</span>(Interpreter&lt;UChar&gt;::BackTrackInfoParentheses) == (YarrStackSpaceForBackTrackInfoParentheses * <span class="enscript-keyword">sizeof</span>(uintptr_t)), CheckYarrStackSpaceForBackTrackInfoParentheses);


} }
</pre>
<hr />
</body></html>