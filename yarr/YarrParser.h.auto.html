<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>YarrParser.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">YarrParser.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (C) 2009 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">YarrParser_h</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">YarrParser_h</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;runtime/UString.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Yarr.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/ASCIICType.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/unicode/Unicode.h&gt;</span>

namespace JSC { namespace Yarr {

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REGEXP_ERROR_PREFIX</span> <span class="enscript-string">&quot;Invalid regular expression: &quot;</span>

<span class="enscript-type">enum</span> BuiltInCharacterClassID {
    DigitClassID,
    SpaceClassID,
    WordClassID,
    NewlineClassID,
};

<span class="enscript-comment">// The Parser class should not be used directly - only via the Yarr::parse() method.
</span>template&lt;class Delegate, typename CharType&gt;
class Parser {
<span class="enscript-reference">private</span>:
    template&lt;class FriendDelegate&gt;
    friend <span class="enscript-type">const</span> <span class="enscript-type">char</span>* parse(FriendDelegate&amp; delegate, <span class="enscript-type">const</span> UString&amp; pattern, <span class="enscript-type">unsigned</span> backReferenceLimit);

    <span class="enscript-type">enum</span> ErrorCode {
        NoError,
        PatternTooLarge,
        QuantifierOutOfOrder,
        QuantifierWithoutAtom,
        QuantifierTooLarge,
        MissingParentheses,
        ParenthesesUnmatched,
        ParenthesesTypeInvalid,
        CharacterClassUnmatched,
        CharacterClassOutOfOrder,
        EscapeUnterminated,
        NumberOfErrorCodes
    };

    <span class="enscript-comment">/*
     * CharacterClassParserDelegate:
     *
     * The class CharacterClassParserDelegate is used in the parsing of character
     * classes.  This class handles detection of character ranges.  This class
     * implements enough of the delegate interface such that it can be passed to
     * parseEscape() as an EscapeDelegate.  This allows parseEscape() to be reused
     * to perform the parsing of escape characters in character sets.
     */</span>
    class CharacterClassParserDelegate {
    <span class="enscript-reference">public</span>:
        CharacterClassParserDelegate(Delegate&amp; delegate, ErrorCode&amp; err)
            : m_delegate(delegate)
            , m_err(err)
            , m_state(Empty)
            , m_character(0)
        {
        }

        <span class="enscript-comment">/*
         * begin():
         *
         * Called at beginning of construction.
         */</span>
        <span class="enscript-type">void</span> begin(bool invert)
        {
            m_delegate.atomCharacterClassBegin(invert);
        }

        <span class="enscript-comment">/*
         * atomPatternCharacter():
         *
         * This method is called either from parseCharacterClass() (for an unescaped
         * character in a character class), or from parseEscape(). In the former case
         * the value true will be passed for the argument 'hyphenIsRange', and in this
         * mode we will allow a hypen to be treated as indicating a range (i.e. /[a-z]/
         * is different to /[a\-z]/).
         */</span>
        <span class="enscript-type">void</span> atomPatternCharacter(UChar ch, bool hyphenIsRange = false)
        {
            <span class="enscript-keyword">switch</span> (m_state) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AfterCharacterClass</span>:
                <span class="enscript-comment">// Following a builtin character class we need look out for a hyphen.
</span>                <span class="enscript-comment">// We're looking for invalid ranges, such as /[\d-x]/ or /[\d-\d]/.
</span>                <span class="enscript-comment">// If we see a hyphen following a charater class then unlike usual
</span>                <span class="enscript-comment">// we'll report it to the delegate immediately, and put ourself into
</span>                <span class="enscript-comment">// a poisoned state. Any following calls to add another character or
</span>                <span class="enscript-comment">// character class will result in an error. (A hypen following a
</span>                <span class="enscript-comment">// character-class is itself valid, but only  at the end of a regex).
</span>                <span class="enscript-keyword">if</span> (hyphenIsRange &amp;&amp; ch == <span class="enscript-string">'-'</span>) {
                    m_delegate.atomCharacterClassAtom(<span class="enscript-string">'-'</span>);
                    m_state = AfterCharacterClassHyphen;
                    <span class="enscript-keyword">return</span>;
                }
                <span class="enscript-comment">// Otherwise just fall through - cached character so treat this as Empty.
</span>
            <span class="enscript-keyword">case</span> <span class="enscript-reference">Empty</span>:
                m_character = ch;
                m_state = CachedCharacter;
                <span class="enscript-keyword">return</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">CachedCharacter</span>:
                <span class="enscript-keyword">if</span> (hyphenIsRange &amp;&amp; ch == <span class="enscript-string">'-'</span>)
                    m_state = CachedCharacterHyphen;
                <span class="enscript-keyword">else</span> {
                    m_delegate.atomCharacterClassAtom(m_character);
                    m_character = ch;
                }
                <span class="enscript-keyword">return</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">CachedCharacterHyphen</span>:
                <span class="enscript-keyword">if</span> (ch &lt; m_character) {
                    m_err = CharacterClassOutOfOrder;
                    <span class="enscript-keyword">return</span>;
                }
                m_delegate.atomCharacterClassRange(m_character, ch);
                m_state = Empty;
                <span class="enscript-keyword">return</span>;

                <span class="enscript-comment">// See coment in atomBuiltInCharacterClass below.
</span>                <span class="enscript-comment">// This too is technically an error, per ECMA-262, and again we
</span>                <span class="enscript-comment">// we chose to allow this.  Note a subtlely here that while we
</span>                <span class="enscript-comment">// diverge from the spec's definition of CharacterRange we do
</span>                <span class="enscript-comment">// remain in compliance with the grammar.  For example, consider
</span>                <span class="enscript-comment">// the expression /[\d-a-z]/.  We comply with the grammar in
</span>                <span class="enscript-comment">// this case by not allowing a-z to be matched as a range.
</span>            <span class="enscript-keyword">case</span> <span class="enscript-reference">AfterCharacterClassHyphen</span>:
                m_delegate.atomCharacterClassAtom(ch);
                m_state = Empty;
                <span class="enscript-keyword">return</span>;
            }
        }

        <span class="enscript-comment">/*
         * atomBuiltInCharacterClass():
         *
         * Adds a built-in character class, called by parseEscape().
         */</span>
        <span class="enscript-type">void</span> atomBuiltInCharacterClass(BuiltInCharacterClassID classID, bool invert)
        {
            <span class="enscript-keyword">switch</span> (m_state) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">CachedCharacter</span>:
                <span class="enscript-comment">// Flush the currently cached character, then fall through.
</span>                m_delegate.atomCharacterClassAtom(m_character);

            <span class="enscript-keyword">case</span> <span class="enscript-reference">Empty</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AfterCharacterClass</span>:
                m_state = AfterCharacterClass;
                m_delegate.atomCharacterClassBuiltIn(classID, invert);
                <span class="enscript-keyword">return</span>;

                <span class="enscript-comment">// If we hit either of these cases, we have an invalid range that
</span>                <span class="enscript-comment">// looks something like /[x-\d]/ or /[\d-\d]/.
</span>                <span class="enscript-comment">// According to ECMA-262 this should be a syntax error, but
</span>                <span class="enscript-comment">// empirical testing shows this to break teh webz.  Instead we
</span>                <span class="enscript-comment">// comply with to the ECMA-262 grammar, and assume the grammar to
</span>                <span class="enscript-comment">// have matched the range correctly, but tweak our interpretation
</span>                <span class="enscript-comment">// of CharacterRange.  Effectively we implicitly handle the hyphen
</span>                <span class="enscript-comment">// as if it were escaped, e.g. /[\w-_]/ is treated as /[\w\-_]/.
</span>            <span class="enscript-keyword">case</span> <span class="enscript-reference">CachedCharacterHyphen</span>:
                m_delegate.atomCharacterClassAtom(m_character);
                m_delegate.atomCharacterClassAtom(<span class="enscript-string">'-'</span>);
                <span class="enscript-comment">// fall through
</span>            <span class="enscript-keyword">case</span> <span class="enscript-reference">AfterCharacterClassHyphen</span>:
                m_delegate.atomCharacterClassBuiltIn(classID, invert);
                m_state = Empty;
                <span class="enscript-keyword">return</span>;
            }
        }

        <span class="enscript-comment">/*
         * end():
         *
         * Called at end of construction.
         */</span>
        <span class="enscript-type">void</span> end()
        {
            <span class="enscript-keyword">if</span> (m_state == CachedCharacter)
                m_delegate.atomCharacterClassAtom(m_character);
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m_state == CachedCharacterHyphen) {
                m_delegate.atomCharacterClassAtom(m_character);
                m_delegate.atomCharacterClassAtom(<span class="enscript-string">'-'</span>);
            }
            m_delegate.atomCharacterClassEnd();
        }

        <span class="enscript-comment">// parseEscape() should never call these delegate methods when
</span>        <span class="enscript-comment">// invoked with inCharacterClass set.
</span>        NO_RETURN_DUE_TO_ASSERT <span class="enscript-type">void</span> assertionWordBoundary(bool) { ASSERT_NOT_REACHED(); }
        NO_RETURN_DUE_TO_ASSERT <span class="enscript-type">void</span> atomBackReference(<span class="enscript-type">unsigned</span>) { ASSERT_NOT_REACHED(); }

    <span class="enscript-reference">private</span>:
        Delegate&amp; m_delegate;
        ErrorCode&amp; m_err;
        <span class="enscript-type">enum</span> CharacterClassConstructionState {
            Empty,
            CachedCharacter,
            CachedCharacterHyphen,
            AfterCharacterClass,
            AfterCharacterClassHyphen,
        } m_state;
        UChar m_character;
    };

    Parser(Delegate&amp; delegate, <span class="enscript-type">const</span> UString&amp; pattern, <span class="enscript-type">unsigned</span> backReferenceLimit)
        : m_delegate(delegate)
        , m_backReferenceLimit(backReferenceLimit)
        , m_err(NoError)
        , m_data(pattern.getCharacters&lt;CharType&gt;())
        , m_size(pattern.length())
        , m_index(0)
        , m_parenthesesNestingDepth(0)
    {
    }

    <span class="enscript-comment">/*
     * parseEscape():
     *
     * Helper for parseTokens() AND parseCharacterClass().
     * Unlike the other parser methods, this function does not report tokens
     * directly to the member delegate (m_delegate), instead tokens are
     * emitted to the delegate provided as an argument.  In the case of atom
     * escapes, parseTokens() will call parseEscape() passing m_delegate as
     * an argument, and as such the escape will be reported to the delegate.
     *
     * However this method may also be used by parseCharacterClass(), in which
     * case a CharacterClassParserDelegate will be passed as the delegate that
     * tokens should be added to.  A boolean flag is also provided to indicate
     * whether that an escape in a CharacterClass is being parsed (some parsing
     * rules change in this context).
     *
     * The boolean value returned by this method indicates whether the token
     * parsed was an atom (outside of a characted class \b and \B will be
     * interpreted as assertions).
     */</span>
    template&lt;bool inCharacterClass, class EscapeDelegate&gt;
    bool parseEscape(EscapeDelegate&amp; delegate)
    {
        ASSERT(!m_err);
        ASSERT(peek() == <span class="enscript-string">'\\'</span>);
        consume();

        <span class="enscript-keyword">if</span> (atEndOfPattern()) {
            m_err = EscapeUnterminated;
            <span class="enscript-keyword">return</span> false;
        }

        <span class="enscript-keyword">switch</span> (peek()) {
        <span class="enscript-comment">// Assertions
</span>        <span class="enscript-keyword">case</span> <span class="enscript-string">'b'</span>:
            consume();
            <span class="enscript-keyword">if</span> (inCharacterClass)
                delegate.atomPatternCharacter(<span class="enscript-string">'\b'</span>);
            <span class="enscript-keyword">else</span> {
                delegate.assertionWordBoundary(false);
                <span class="enscript-keyword">return</span> false;
            }
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'B'</span>:
            consume();
            <span class="enscript-keyword">if</span> (inCharacterClass)
                delegate.atomPatternCharacter(<span class="enscript-string">'B'</span>);
            <span class="enscript-keyword">else</span> {
                delegate.assertionWordBoundary(true);
                <span class="enscript-keyword">return</span> false;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// CharacterClassEscape
</span>        <span class="enscript-keyword">case</span> <span class="enscript-string">'d'</span>:
            consume();
            delegate.atomBuiltInCharacterClass(DigitClassID, false);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'s'</span>:
            consume();
            delegate.atomBuiltInCharacterClass(SpaceClassID, false);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'w'</span>:
            consume();
            delegate.atomBuiltInCharacterClass(WordClassID, false);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'D'</span>:
            consume();
            delegate.atomBuiltInCharacterClass(DigitClassID, true);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'S'</span>:
            consume();
            delegate.atomBuiltInCharacterClass(SpaceClassID, true);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'W'</span>:
            consume();
            delegate.atomBuiltInCharacterClass(WordClassID, true);
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// DecimalEscape
</span>        <span class="enscript-keyword">case</span> <span class="enscript-string">'1'</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-string">'2'</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-string">'3'</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-string">'4'</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-string">'5'</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-string">'6'</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-string">'7'</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-string">'8'</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-string">'9'</span>: {
            <span class="enscript-comment">// To match Firefox, we parse an invalid backreference in the range [1-7] as an octal escape.
</span>            <span class="enscript-comment">// First, try to parse this as backreference.
</span>            <span class="enscript-keyword">if</span> (!inCharacterClass) {
                ParseState state = saveState();

                <span class="enscript-type">unsigned</span> backReference = consumeNumber();
                <span class="enscript-keyword">if</span> (backReference &lt;= m_backReferenceLimit) {
                    delegate.atomBackReference(backReference);
                    <span class="enscript-keyword">break</span>;
                }

                restoreState(state);
            }
            
            <span class="enscript-comment">// Not a backreference, and not octal.
</span>            <span class="enscript-keyword">if</span> (peek() &gt;= <span class="enscript-string">'8'</span>) {
                delegate.atomPatternCharacter(<span class="enscript-string">'\\'</span>);
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-comment">// Fall-through to handle this as an octal escape.
</span>        }

        <span class="enscript-comment">// Octal escape
</span>        <span class="enscript-keyword">case</span> <span class="enscript-string">'0'</span>:
            delegate.atomPatternCharacter(consumeOctal());
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// ControlEscape
</span>        <span class="enscript-keyword">case</span> <span class="enscript-string">'f'</span>:
            consume();
            delegate.atomPatternCharacter(<span class="enscript-string">'\f'</span>);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'n'</span>:
            consume();
            delegate.atomPatternCharacter(<span class="enscript-string">'\n'</span>);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'r'</span>:
            consume();
            delegate.atomPatternCharacter(<span class="enscript-string">'\r'</span>);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:
            consume();
            delegate.atomPatternCharacter(<span class="enscript-string">'\t'</span>);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'v'</span>:
            consume();
            delegate.atomPatternCharacter(<span class="enscript-string">'\v'</span>);
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// ControlLetter
</span>        <span class="enscript-keyword">case</span> <span class="enscript-string">'c'</span>: {
            ParseState state = saveState();
            consume();
            <span class="enscript-keyword">if</span> (!atEndOfPattern()) {
                <span class="enscript-type">int</span> control = consume();

                <span class="enscript-comment">// To match Firefox, inside a character class, we also accept numbers and '_' as control characters.
</span>                <span class="enscript-keyword">if</span> (inCharacterClass ? WTF::isASCIIAlphanumeric(control) || (control == <span class="enscript-string">'_'</span>) : WTF::isASCIIAlpha(control)) {
                    delegate.atomPatternCharacter(control &amp; 0x1f);
                    <span class="enscript-keyword">break</span>;
                }
            }
            restoreState(state);
            delegate.atomPatternCharacter(<span class="enscript-string">'\\'</span>);
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// HexEscape
</span>        <span class="enscript-keyword">case</span> <span class="enscript-string">'x'</span>: {
            consume();
            <span class="enscript-type">int</span> x = tryConsumeHex(2);
            <span class="enscript-keyword">if</span> (x == -1)
                delegate.atomPatternCharacter(<span class="enscript-string">'x'</span>);
            <span class="enscript-keyword">else</span>
                delegate.atomPatternCharacter(x);
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// UnicodeEscape
</span>        <span class="enscript-keyword">case</span> <span class="enscript-string">'u'</span>: {
            consume();
            <span class="enscript-type">int</span> u = tryConsumeHex(4);
            <span class="enscript-keyword">if</span> (u == -1)
                delegate.atomPatternCharacter(<span class="enscript-string">'u'</span>);
            <span class="enscript-keyword">else</span>
                delegate.atomPatternCharacter(u);
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// IdentityEscape
</span>        <span class="enscript-reference">default</span>:
            delegate.atomPatternCharacter(consume());
        }
        
        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-comment">/*
     * parseAtomEscape(), parseCharacterClassEscape():
     *
     * These methods alias to parseEscape().
     */</span>
    bool parseAtomEscape()
    {
        <span class="enscript-keyword">return</span> parseEscape&lt;false&gt;(m_delegate);
    }
    <span class="enscript-type">void</span> parseCharacterClassEscape(CharacterClassParserDelegate&amp; delegate)
    {
        parseEscape&lt;true&gt;(delegate);
    }

    <span class="enscript-comment">/*
     * parseCharacterClass():
     *
     * Helper for parseTokens(); calls dirctly and indirectly (via parseCharacterClassEscape)
     * to an instance of CharacterClassParserDelegate, to describe the character class to the
     * delegate.
     */</span>
    <span class="enscript-type">void</span> parseCharacterClass()
    {
        ASSERT(!m_err);
        ASSERT(peek() == <span class="enscript-string">'['</span>);
        consume();

        CharacterClassParserDelegate characterClassConstructor(m_delegate, m_err);

        characterClassConstructor.begin(tryConsume(<span class="enscript-string">'^'</span>));

        <span class="enscript-keyword">while</span> (!atEndOfPattern()) {
            <span class="enscript-keyword">switch</span> (peek()) {
            <span class="enscript-keyword">case</span> <span class="enscript-string">']'</span>:
                consume();
                characterClassConstructor.end();
                <span class="enscript-keyword">return</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'\\'</span>:
                parseCharacterClassEscape(characterClassConstructor);
                <span class="enscript-keyword">break</span>;

            <span class="enscript-reference">default</span>:
                characterClassConstructor.atomPatternCharacter(consume(), true);
            }

            <span class="enscript-keyword">if</span> (m_err)
                <span class="enscript-keyword">return</span>;
        }

        m_err = CharacterClassUnmatched;
    }

    <span class="enscript-comment">/*
     * parseParenthesesBegin():
     *
     * Helper for parseTokens(); checks for parentheses types other than regular capturing subpatterns.
     */</span>
    <span class="enscript-type">void</span> parseParenthesesBegin()
    {
        ASSERT(!m_err);
        ASSERT(peek() == <span class="enscript-string">'('</span>);
        consume();

        <span class="enscript-keyword">if</span> (tryConsume(<span class="enscript-string">'?'</span>)) {
            <span class="enscript-keyword">if</span> (atEndOfPattern()) {
                m_err = ParenthesesTypeInvalid;
                <span class="enscript-keyword">return</span>;
            }

            <span class="enscript-keyword">switch</span> (consume()) {
            <span class="enscript-keyword">case</span> <span class="enscript-string">':'</span>:
                m_delegate.atomParenthesesSubpatternBegin(false);
                <span class="enscript-keyword">break</span>;
            
            <span class="enscript-keyword">case</span> <span class="enscript-string">'='</span>:
                m_delegate.atomParentheticalAssertionBegin();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'!'</span>:
                m_delegate.atomParentheticalAssertionBegin(true);
                <span class="enscript-keyword">break</span>;
            
            <span class="enscript-reference">default</span>:
                m_err = ParenthesesTypeInvalid;
            }
        } <span class="enscript-keyword">else</span>
            m_delegate.atomParenthesesSubpatternBegin();

        ++m_parenthesesNestingDepth;
    }

    <span class="enscript-comment">/*
     * parseParenthesesEnd():
     *
     * Helper for parseTokens(); checks for parse errors (due to unmatched parentheses).
     */</span>
    <span class="enscript-type">void</span> parseParenthesesEnd()
    {
        ASSERT(!m_err);
        ASSERT(peek() == <span class="enscript-string">')'</span>);
        consume();

        <span class="enscript-keyword">if</span> (m_parenthesesNestingDepth &gt; 0)
            m_delegate.atomParenthesesEnd();
        <span class="enscript-keyword">else</span>
            m_err = ParenthesesUnmatched;

        --m_parenthesesNestingDepth;
    }

    <span class="enscript-comment">/*
     * parseQuantifier():
     *
     * Helper for parseTokens(); checks for parse errors and non-greedy quantifiers.
     */</span>
    <span class="enscript-type">void</span> parseQuantifier(bool lastTokenWasAnAtom, <span class="enscript-type">unsigned</span> min, <span class="enscript-type">unsigned</span> max)
    {
        ASSERT(!m_err);
        ASSERT(min &lt;= max);

        <span class="enscript-keyword">if</span> (min == UINT_MAX) {
            m_err = QuantifierTooLarge;
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-keyword">if</span> (lastTokenWasAnAtom)
            m_delegate.quantifyAtom(min, max, !tryConsume(<span class="enscript-string">'?'</span>));
        <span class="enscript-keyword">else</span>
            m_err = QuantifierWithoutAtom;
    }

    <span class="enscript-comment">/*
     * parseTokens():
     *
     * This method loops over the input pattern reporting tokens to the delegate.
     * The method returns when a parse error is detected, or the end of the pattern
     * is reached.  One piece of state is tracked around the loop, which is whether
     * the last token passed to the delegate was an atom (this is necessary to detect
     * a parse error when a quantifier provided without an atom to quantify).
     */</span>
    <span class="enscript-type">void</span> parseTokens()
    {
        bool lastTokenWasAnAtom = false;

        <span class="enscript-keyword">while</span> (!atEndOfPattern()) {
            <span class="enscript-keyword">switch</span> (peek()) {
            <span class="enscript-keyword">case</span> <span class="enscript-string">'|'</span>:
                consume();
                m_delegate.disjunction();
                lastTokenWasAnAtom = false;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'('</span>:
                parseParenthesesBegin();
                lastTokenWasAnAtom = false;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">')'</span>:
                parseParenthesesEnd();
                lastTokenWasAnAtom = true;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'^'</span>:
                consume();
                m_delegate.assertionBOL();
                lastTokenWasAnAtom = false;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'$'</span>:
                consume();
                m_delegate.assertionEOL();
                lastTokenWasAnAtom = false;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'.'</span>:
                consume();
                m_delegate.atomBuiltInCharacterClass(NewlineClassID, true);
                lastTokenWasAnAtom = true;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'['</span>:
                parseCharacterClass();
                lastTokenWasAnAtom = true;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'\\'</span>:
                lastTokenWasAnAtom = parseAtomEscape();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'*'</span>:
                consume();
                parseQuantifier(lastTokenWasAnAtom, 0, quantifyInfinite);
                lastTokenWasAnAtom = false;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'+'</span>:
                consume();
                parseQuantifier(lastTokenWasAnAtom, 1, quantifyInfinite);
                lastTokenWasAnAtom = false;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'?'</span>:
                consume();
                parseQuantifier(lastTokenWasAnAtom, 0, 1);
                lastTokenWasAnAtom = false;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'{'</span>: {
                ParseState state = saveState();

                consume();
                <span class="enscript-keyword">if</span> (peekIsDigit()) {
                    <span class="enscript-type">unsigned</span> min = consumeNumber();
                    <span class="enscript-type">unsigned</span> max = min;
                    
                    <span class="enscript-keyword">if</span> (tryConsume(<span class="enscript-string">','</span>))
                        max = peekIsDigit() ? consumeNumber() : quantifyInfinite;

                    <span class="enscript-keyword">if</span> (tryConsume(<span class="enscript-string">'}'</span>)) {
                        <span class="enscript-keyword">if</span> (min &lt;= max)
                            parseQuantifier(lastTokenWasAnAtom, min, max);
                        <span class="enscript-keyword">else</span>
                            m_err = QuantifierOutOfOrder;
                        lastTokenWasAnAtom = false;
                        <span class="enscript-keyword">break</span>;
                    }
                }

                restoreState(state);
            } <span class="enscript-comment">// if we did not find a complete quantifer, fall through to the default case.
</span>
            <span class="enscript-reference">default</span>:
                m_delegate.atomPatternCharacter(consume());
                lastTokenWasAnAtom = true;
            }

            <span class="enscript-keyword">if</span> (m_err)
                <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-keyword">if</span> (m_parenthesesNestingDepth &gt; 0)
            m_err = MissingParentheses;
    }

    <span class="enscript-comment">/*
     * parse():
     *
     * This method calls parseTokens() to parse over the input and converts any
     * error code to a const char* for a result.
     */</span>
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>* parse()
    {
        <span class="enscript-keyword">if</span> (m_size &gt; MAX_PATTERN_SIZE)
            m_err = PatternTooLarge;
        <span class="enscript-keyword">else</span>
            parseTokens();
        ASSERT(atEndOfPattern() || m_err);

        <span class="enscript-comment">// The order of this array must match the ErrorCode enum.
</span>        <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span>* errorMessages[NumberOfErrorCodes] = {
            0, <span class="enscript-comment">// NoError
</span>            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;regular expression too large&quot;</span>,
            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;numbers out of order in {} quantifier&quot;</span>,
            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;nothing to repeat&quot;</span>,
            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;number too large in {} quantifier&quot;</span>,
            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;missing )&quot;</span>,
            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;unmatched parentheses&quot;</span>,
            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;unrecognized character after (?&quot;</span>,
            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;missing terminating ] for character class&quot;</span>,
            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;range out of order in character class&quot;</span>,
            REGEXP_ERROR_PREFIX <span class="enscript-string">&quot;\\ at end of pattern&quot;</span>
        };

        <span class="enscript-keyword">return</span> errorMessages[m_err];
    }

    <span class="enscript-comment">// Misc helper functions:
</span>
    <span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> ParseState;
    
    ParseState saveState()
    {
        <span class="enscript-keyword">return</span> m_index;
    }

    <span class="enscript-type">void</span> restoreState(ParseState state)
    {
        m_index = state;
    }

    bool atEndOfPattern()
    {
        ASSERT(m_index &lt;= m_size);
        <span class="enscript-keyword">return</span> m_index == m_size;
    }

    <span class="enscript-type">int</span> peek()
    {
        ASSERT(m_index &lt; m_size);
        <span class="enscript-keyword">return</span> m_data[m_index];
    }

    bool peekIsDigit()
    {
        <span class="enscript-keyword">return</span> !atEndOfPattern() &amp;&amp; WTF::isASCIIDigit(peek());
    }

    <span class="enscript-type">unsigned</span> peekDigit()
    {
        ASSERT(peekIsDigit());
        <span class="enscript-keyword">return</span> peek() - <span class="enscript-string">'0'</span>;
    }

    <span class="enscript-type">int</span> consume()
    {
        ASSERT(m_index &lt; m_size);
        <span class="enscript-keyword">return</span> m_data[m_index++];
    }

    <span class="enscript-type">unsigned</span> consumeDigit()
    {
        ASSERT(peekIsDigit());
        <span class="enscript-keyword">return</span> consume() - <span class="enscript-string">'0'</span>;
    }

    <span class="enscript-type">unsigned</span> consumeNumber()
    {
        <span class="enscript-type">unsigned</span> n = consumeDigit();
        <span class="enscript-comment">// check for overflow.
</span>        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> newValue; peekIsDigit() &amp;&amp; ((newValue = n * 10 + peekDigit()) &gt;= n); ) {
            n = newValue;
            consume();
        }
        <span class="enscript-keyword">return</span> n;
    }

    <span class="enscript-type">unsigned</span> consumeOctal()
    {
        ASSERT(WTF::isASCIIOctalDigit(peek()));

        <span class="enscript-type">unsigned</span> n = consumeDigit();
        <span class="enscript-keyword">while</span> (n &lt; 32 &amp;&amp; !atEndOfPattern() &amp;&amp; WTF::isASCIIOctalDigit(peek()))
            n = n * 8 + consumeDigit();
        <span class="enscript-keyword">return</span> n;
    }

    bool tryConsume(UChar ch)
    {
        <span class="enscript-keyword">if</span> (atEndOfPattern() || (m_data[m_index] != ch))
            <span class="enscript-keyword">return</span> false;
        ++m_index;
        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-type">int</span> tryConsumeHex(<span class="enscript-type">int</span> count)
    {
        ParseState state = saveState();

        <span class="enscript-type">int</span> n = 0;
        <span class="enscript-keyword">while</span> (count--) {
            <span class="enscript-keyword">if</span> (atEndOfPattern() || !WTF::isASCIIHexDigit(peek())) {
                restoreState(state);
                <span class="enscript-keyword">return</span> -1;
            }
            n = (n &lt;&lt; 4) | WTF::toASCIIHexValue(consume());
        }
        <span class="enscript-keyword">return</span> n;
    }

    Delegate&amp; m_delegate;
    <span class="enscript-type">unsigned</span> m_backReferenceLimit;
    ErrorCode m_err;
    <span class="enscript-type">const</span> CharType* m_data;
    <span class="enscript-type">unsigned</span> m_size;
    <span class="enscript-type">unsigned</span> m_index;
    <span class="enscript-type">unsigned</span> m_parenthesesNestingDepth;

    <span class="enscript-comment">// Derived by empirical testing of compile time in PCRE and WREC.
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> MAX_PATTERN_SIZE = 1024 * 1024;
};

<span class="enscript-comment">/*
 * Yarr::parse():
 *
 * The parse method is passed a pattern to be parsed and a delegate upon which
 * callbacks will be made to record the parsed tokens forming the regex.
 * Yarr::parse() returns null on success, or a const C string providing an error
 * message where a parse error occurs.
 *
 * The Delegate must implement the following interface:
 *
 *    void assertionBOL();
 *    void assertionEOL();
 *    void assertionWordBoundary(bool invert);
 *
 *    void atomPatternCharacter(UChar ch);
 *    void atomBuiltInCharacterClass(BuiltInCharacterClassID classID, bool invert);
 *    void atomCharacterClassBegin(bool invert)
 *    void atomCharacterClassAtom(UChar ch)
 *    void atomCharacterClassRange(UChar begin, UChar end)
 *    void atomCharacterClassBuiltIn(BuiltInCharacterClassID classID, bool invert)
 *    void atomCharacterClassEnd()
 *    void atomParenthesesSubpatternBegin(bool capture = true);
 *    void atomParentheticalAssertionBegin(bool invert = false);
 *    void atomParenthesesEnd();
 *    void atomBackReference(unsigned subpatternId);
 *
 *    void quantifyAtom(unsigned min, unsigned max, bool greedy);
 *
 *    void disjunction();
 *
 * The regular expression is described by a sequence of assertion*() and atom*()
 * callbacks to the delegate, describing the terms in the regular expression.
 * Following an atom a quantifyAtom() call may occur to indicate that the previous
 * atom should be quantified.  In the case of atoms described across multiple
 * calls (parentheses and character classes) the call to quantifyAtom() will come
 * after the call to the atom*End() method, never after atom*Begin().
 *
 * Character classes may either be described by a single call to
 * atomBuiltInCharacterClass(), or by a sequence of atomCharacterClass*() calls.
 * In the latter case, ...Begin() will be called, followed by a sequence of
 * calls to ...Atom(), ...Range(), and ...BuiltIn(), followed by a call to ...End().
 *
 * Sequences of atoms and assertions are broken into alternatives via calls to
 * disjunction().  Assertions, atoms, and disjunctions emitted between calls to
 * atomParenthesesBegin() and atomParenthesesEnd() form the body of a subpattern.
 * atomParenthesesBegin() is passed a subpatternId.  In the case of a regular
 * capturing subpattern, this will be the subpatternId associated with these
 * parentheses, and will also by definition be the lowest subpatternId of these
 * parentheses and of any nested paretheses.  The atomParenthesesEnd() method
 * is passed the subpatternId of the last capturing subexpression nested within
 * these paretheses.  In the case of a capturing subpattern with no nested
 * capturing subpatterns, the same subpatternId will be passed to the begin and
 * end functions.  In the case of non-capturing subpatterns the subpatternId
 * passed to the begin method is also the first possible subpatternId that might
 * be nested within these paretheses.  If a set of non-capturing parentheses does
 * not contain any capturing subpatterns, then the subpatternId passed to begin
 * will be greater than the subpatternId passed to end.
 */</span>

template&lt;class Delegate&gt;
<span class="enscript-type">const</span> <span class="enscript-type">char</span>* <span class="enscript-function-name">parse</span>(Delegate&amp; delegate, <span class="enscript-type">const</span> UString&amp; pattern, <span class="enscript-type">unsigned</span> backReferenceLimit = quantifyInfinite)
{
    <span class="enscript-keyword">if</span> (pattern.is8Bit())
        <span class="enscript-keyword">return</span> Parser&lt;Delegate, LChar&gt;(delegate, pattern, backReferenceLimit).parse();
    <span class="enscript-keyword">return</span> Parser&lt;Delegate, UChar&gt;(delegate, pattern, backReferenceLimit).parse();
}

} } <span class="enscript-comment">// namespace JSC::Yarr
</span>
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">YarrParser_h</span>
</pre>
<hr />
</body></html>