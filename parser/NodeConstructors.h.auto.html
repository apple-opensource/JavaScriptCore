<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>NodeConstructors.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">NodeConstructors.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 *  Copyright (C) 2009 Apple Inc. All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public License
 *  along with this library; see the file COPYING.LIB.  If not, write to
 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA 02110-1301, USA.
 *
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NodeConstructors_h</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NodeConstructors_h</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Nodes.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Lexer.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Parser.h&quot;</span>

namespace JSC {

    inline <span class="enscript-type">void</span>* ParserArenaFreeable::operator new(size_t size, JSGlobalData* globalData)
    {
        <span class="enscript-keyword">return</span> globalData-&gt;parserArena-&gt;allocateFreeable(size);
    }

    inline <span class="enscript-type">void</span>* ParserArenaDeletable::operator new(size_t size, JSGlobalData* globalData)
    {
        <span class="enscript-keyword">return</span> globalData-&gt;parserArena-&gt;allocateDeletable(size);
    }

    inline ParserArenaRefCounted::ParserArenaRefCounted(JSGlobalData* globalData)
    {
        globalData-&gt;parserArena-&gt;derefWithArena(adoptRef(this));
    }

    inline Node::Node(<span class="enscript-type">int</span> lineNumber)
        : m_lineNumber(lineNumber)
    {
    }

    inline ExpressionNode::ExpressionNode(<span class="enscript-type">int</span> lineNumber, ResultType resultType)
        : Node(lineNumber)
        , m_resultType(resultType)
    {
    }

    inline StatementNode::StatementNode(<span class="enscript-type">int</span> lineNumber)
        : Node(lineNumber)
        , m_lastLine(-1)
    {
    }

    inline NullNode::NullNode(<span class="enscript-type">int</span> lineNumber)
        : ExpressionNode(lineNumber, ResultType::nullType())
    {
    }

    inline BooleanNode::BooleanNode(<span class="enscript-type">int</span> lineNumber, bool value)
        : ExpressionNode(lineNumber, ResultType::booleanType())
        , m_value(value)
    {
    }

    inline NumberNode::NumberNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">double</span> value)
        : ExpressionNode(lineNumber, ResultType::numberType())
        , m_value(value)
    {
    }

    inline StringNode::StringNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; value)
        : ExpressionNode(lineNumber, ResultType::stringType())
        , m_value(value)
    {
    }

    inline RegExpNode::RegExpNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; pattern, <span class="enscript-type">const</span> Identifier&amp; flags)
        : ExpressionNode(lineNumber)
        , m_pattern(pattern)
        , m_flags(flags)
    {
    }

    inline ThisNode::ThisNode(<span class="enscript-type">int</span> lineNumber)
        : ExpressionNode(lineNumber)
    {
    }

    inline ResolveNode::ResolveNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, <span class="enscript-type">int</span> startOffset)
        : ExpressionNode(lineNumber)
        , m_ident(ident)
        , m_startOffset(startOffset)
    {
    }

    inline ElementNode::ElementNode(<span class="enscript-type">int</span> elision, ExpressionNode* node)
        : m_next(0)
        , m_elision(elision)
        , m_node(node)
    {
    }

    inline ElementNode::ElementNode(ElementNode* l, <span class="enscript-type">int</span> elision, ExpressionNode* node)
        : m_next(0)
        , m_elision(elision)
        , m_node(node)
    {
        l-&gt;m_next = this;
    }

    inline ArrayNode::ArrayNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">int</span> elision)
        : ExpressionNode(lineNumber)
        , m_element(0)
        , m_elision(elision)
        , m_optional(true)
    {
    }

    inline ArrayNode::ArrayNode(<span class="enscript-type">int</span> lineNumber, ElementNode* element)
        : ExpressionNode(lineNumber)
        , m_element(element)
        , m_elision(0)
        , m_optional(false)
    {
    }

    inline ArrayNode::ArrayNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">int</span> elision, ElementNode* element)
        : ExpressionNode(lineNumber)
        , m_element(element)
        , m_elision(elision)
        , m_optional(true)
    {
    }

    inline PropertyNode::PropertyNode(JSGlobalData*, <span class="enscript-type">const</span> Identifier&amp; name, ExpressionNode* assign, Type type)
        : m_name(name)
        , m_assign(assign)
        , m_type(type)
    {
    }

    inline PropertyNode::PropertyNode(JSGlobalData* globalData, <span class="enscript-type">double</span> name, ExpressionNode* assign, Type type)
        : m_name(globalData-&gt;parserArena-&gt;identifierArena().makeNumericIdentifier(globalData, name))
        , m_assign(assign)
        , m_type(type)
    {
    }

    inline PropertyListNode::PropertyListNode(<span class="enscript-type">int</span> lineNumber, PropertyNode* node)
        : Node(lineNumber)
        , m_node(node)
        , m_next(0)
    {
    }

    inline PropertyListNode::PropertyListNode(<span class="enscript-type">int</span> lineNumber, PropertyNode* node, PropertyListNode* list)
        : Node(lineNumber)
        , m_node(node)
        , m_next(0)
    {
        list-&gt;m_next = this;
    }

    inline ObjectLiteralNode::ObjectLiteralNode(<span class="enscript-type">int</span> lineNumber)
        : ExpressionNode(lineNumber)
        , m_list(0)
    {
    }

    inline ObjectLiteralNode::ObjectLiteralNode(<span class="enscript-type">int</span> lineNumber, PropertyListNode* list)
        : ExpressionNode(lineNumber)
        , m_list(list)
    {
    }

    inline BracketAccessorNode::BracketAccessorNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments)
        : ExpressionNode(lineNumber)
        , m_base(base)
        , m_subscript(subscript)
        , m_subscriptHasAssignments(subscriptHasAssignments)
    {
    }

    inline DotAccessorNode::DotAccessorNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp; ident)
        : ExpressionNode(lineNumber)
        , m_base(base)
        , m_ident(ident)
    {
    }

    inline ArgumentListNode::ArgumentListNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : Node(lineNumber)
        , m_next(0)
        , m_expr(expr)
    {
    }

    inline ArgumentListNode::ArgumentListNode(<span class="enscript-type">int</span> lineNumber, ArgumentListNode* listNode, ExpressionNode* expr)
        : Node(lineNumber)
        , m_next(0)
        , m_expr(expr)
    {
        listNode-&gt;m_next = this;
    }

    inline ArgumentsNode::ArgumentsNode()
        : m_listNode(0)
    {
    }

    inline ArgumentsNode::ArgumentsNode(ArgumentListNode* listNode)
        : m_listNode(listNode)
    {
    }

    inline NewExprNode::NewExprNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : ExpressionNode(lineNumber)
        , m_expr(expr)
        , m_args(0)
    {
    }

    inline NewExprNode::NewExprNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr, ArgumentsNode* args)
        : ExpressionNode(lineNumber)
        , m_expr(expr)
        , m_args(args)
    {
    }

    inline EvalFunctionCallNode::EvalFunctionCallNode(<span class="enscript-type">int</span> lineNumber, ArgumentsNode* args, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_args(args)
    {
    }

    inline FunctionCallValueNode::FunctionCallValueNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr, ArgumentsNode* args, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_expr(expr)
        , m_args(args)
    {
    }

    inline FunctionCallResolveNode::FunctionCallResolveNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, ArgumentsNode* args, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_ident(ident)
        , m_args(args)
    {
    }

    inline FunctionCallBracketNode::FunctionCallBracketNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, ExpressionNode* subscript, ArgumentsNode* args, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableSubExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_subscript(subscript)
        , m_args(args)
    {
    }

    inline FunctionCallDotNode::FunctionCallDotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp; ident, ArgumentsNode* args, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableSubExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_ident(ident)
        , m_args(args)
    {
    }

    inline CallFunctionCallDotNode::CallFunctionCallDotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp; ident, ArgumentsNode* args, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : FunctionCallDotNode(lineNumber, base, ident, args, divot, startOffset, endOffset)
    {
    }

    inline ApplyFunctionCallDotNode::ApplyFunctionCallDotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp; ident, ArgumentsNode* args, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : FunctionCallDotNode(lineNumber, base, ident, args, divot, startOffset, endOffset)
    {
    }

    inline PrePostResolveNode::PrePostResolveNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber, ResultType::numberType()) <span class="enscript-comment">// could be reusable for pre?
</span>        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_ident(ident)
    {
    }

    inline PostfixResolveNode::PostfixResolveNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, Operator oper, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : PrePostResolveNode(lineNumber, ident, divot, startOffset, endOffset)
        , m_operator(oper)
    {
    }

    inline PostfixBracketNode::PostfixBracketNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, ExpressionNode* subscript, Operator oper, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableSubExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_subscript(subscript)
        , m_operator(oper)
    {
    }

    inline PostfixDotNode::PostfixDotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp; ident, Operator oper, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableSubExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_ident(ident)
        , m_operator(oper)
    {
    }

    inline PostfixErrorNode::PostfixErrorNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr, Operator oper, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableSubExpressionData(divot, startOffset, endOffset)
        , m_expr(expr)
        , m_operator(oper)
    {
    }

    inline DeleteResolveNode::DeleteResolveNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_ident(ident)
    {
    }

    inline DeleteBracketNode::DeleteBracketNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, ExpressionNode* subscript, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_subscript(subscript)
    {
    }

    inline DeleteDotNode::DeleteDotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp; ident, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_ident(ident)
    {
    }

    inline DeleteValueNode::DeleteValueNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : ExpressionNode(lineNumber)
        , m_expr(expr)
    {
    }

    inline VoidNode::VoidNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : ExpressionNode(lineNumber)
        , m_expr(expr)
    {
    }

    inline TypeOfResolveNode::TypeOfResolveNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident)
        : ExpressionNode(lineNumber, ResultType::stringType())
        , m_ident(ident)
    {
    }

    inline TypeOfValueNode::TypeOfValueNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : ExpressionNode(lineNumber, ResultType::stringType())
        , m_expr(expr)
    {
    }

    inline PrefixResolveNode::PrefixResolveNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, Operator oper, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : PrePostResolveNode(lineNumber, ident, divot, startOffset, endOffset)
        , m_operator(oper)
    {
    }

    inline PrefixBracketNode::PrefixBracketNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, ExpressionNode* subscript, Operator oper, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowablePrefixedSubExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_subscript(subscript)
        , m_operator(oper)
    {
    }

    inline PrefixDotNode::PrefixDotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp; ident, Operator oper, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowablePrefixedSubExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_ident(ident)
        , m_operator(oper)
    {
    }

    inline PrefixErrorNode::PrefixErrorNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr, Operator oper, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_expr(expr)
        , m_operator(oper)
    {
    }

    inline UnaryOpNode::UnaryOpNode(<span class="enscript-type">int</span> lineNumber, ResultType type, ExpressionNode* expr, OpcodeID opcodeID)
        : ExpressionNode(lineNumber, type)
        , m_expr(expr)
        , m_opcodeID(opcodeID)
    {
    }

    inline UnaryPlusNode::UnaryPlusNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : UnaryOpNode(lineNumber, ResultType::numberType(), expr, op_to_jsnumber)
    {
    }

    inline NegateNode::NegateNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : UnaryOpNode(lineNumber, ResultType::numberType(), expr, op_negate)
    {
    }

    inline BitwiseNotNode::BitwiseNotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : ExpressionNode(lineNumber, ResultType::forBitOp())
        , m_expr(expr)
    {
    }

    inline LogicalNotNode::LogicalNotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : UnaryOpNode(lineNumber, ResultType::booleanType(), expr, op_not)
    {
    }

    inline BinaryOpNode::BinaryOpNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID opcodeID, bool rightHasAssignments)
        : ExpressionNode(lineNumber)
        , m_expr1(expr1)
        , m_expr2(expr2)
        , m_opcodeID(opcodeID)
        , m_rightHasAssignments(rightHasAssignments)
    {
    }

    inline BinaryOpNode::BinaryOpNode(<span class="enscript-type">int</span> lineNumber, ResultType type, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID opcodeID, bool rightHasAssignments)
        : ExpressionNode(lineNumber, type)
        , m_expr1(expr1)
        , m_expr2(expr2)
        , m_opcodeID(opcodeID)
        , m_rightHasAssignments(rightHasAssignments)
    {
    }

    inline MultNode::MultNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::numberType(), expr1, expr2, op_mul, rightHasAssignments)
    {
    }

    inline DivNode::DivNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::numberType(), expr1, expr2, op_div, rightHasAssignments)
    {
    }


    inline ModNode::ModNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::numberType(), expr1, expr2, op_mod, rightHasAssignments)
    {
    }

    inline AddNode::AddNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::forAdd(expr1-&gt;resultDescriptor(), expr2-&gt;resultDescriptor()), expr1, expr2, op_add, rightHasAssignments)
    {
    }

    inline SubNode::SubNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::numberType(), expr1, expr2, op_sub, rightHasAssignments)
    {
    }

    inline LeftShiftNode::LeftShiftNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::forBitOp(), expr1, expr2, op_lshift, rightHasAssignments)
    {
    }

    inline RightShiftNode::RightShiftNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::forBitOp(), expr1, expr2, op_rshift, rightHasAssignments)
    {
    }

    inline UnsignedRightShiftNode::UnsignedRightShiftNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::numberType(), expr1, expr2, op_urshift, rightHasAssignments)
    {
    }

    inline LessNode::LessNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::booleanType(), expr1, expr2, op_less, rightHasAssignments)
    {
    }

    inline GreaterNode::GreaterNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::booleanType(), expr1, expr2, op_greater, rightHasAssignments)
    {
    }

    inline LessEqNode::LessEqNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::booleanType(), expr1, expr2, op_lesseq, rightHasAssignments)
    {
    }

    inline GreaterEqNode::GreaterEqNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::booleanType(), expr1, expr2, op_greatereq, rightHasAssignments)
    {
    }

    inline ThrowableBinaryOpNode::ThrowableBinaryOpNode(<span class="enscript-type">int</span> lineNumber, ResultType type, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID opcodeID, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, type, expr1, expr2, opcodeID, rightHasAssignments)
    {
    }

    inline ThrowableBinaryOpNode::ThrowableBinaryOpNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID opcodeID, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, expr1, expr2, opcodeID, rightHasAssignments)
    {
    }

    inline InstanceOfNode::InstanceOfNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : ThrowableBinaryOpNode(lineNumber, ResultType::booleanType(), expr1, expr2, op_instanceof, rightHasAssignments)
    {
    }

    inline InNode::InNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : ThrowableBinaryOpNode(lineNumber, expr1, expr2, op_in, rightHasAssignments)
    {
    }

    inline EqualNode::EqualNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::booleanType(), expr1, expr2, op_eq, rightHasAssignments)
    {
    }

    inline NotEqualNode::NotEqualNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::booleanType(), expr1, expr2, op_neq, rightHasAssignments)
    {
    }

    inline StrictEqualNode::StrictEqualNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::booleanType(), expr1, expr2, op_stricteq, rightHasAssignments)
    {
    }

    inline NotStrictEqualNode::NotStrictEqualNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::booleanType(), expr1, expr2, op_nstricteq, rightHasAssignments)
    {
    }

    inline BitAndNode::BitAndNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::forBitOp(), expr1, expr2, op_bitand, rightHasAssignments)
    {
    }

    inline BitOrNode::BitOrNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::forBitOp(), expr1, expr2, op_bitor, rightHasAssignments)
    {
    }

    inline BitXOrNode::BitXOrNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
        : BinaryOpNode(lineNumber, ResultType::forBitOp(), expr1, expr2, op_bitxor, rightHasAssignments)
    {
    }

    inline LogicalOpNode::LogicalOpNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, LogicalOperator oper)
        : ExpressionNode(lineNumber, ResultType::booleanType())
        , m_expr1(expr1)
        , m_expr2(expr2)
        , m_operator(oper)
    {
    }

    inline ConditionalNode::ConditionalNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* logical, ExpressionNode* expr1, ExpressionNode* expr2)
        : ExpressionNode(lineNumber)
        , m_logical(logical)
        , m_expr1(expr1)
        , m_expr2(expr2)
    {
    }

    inline ReadModifyResolveNode::ReadModifyResolveNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, Operator oper, ExpressionNode*  right, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_ident(ident)
        , m_right(right)
        , m_operator(oper)
        , m_rightHasAssignments(rightHasAssignments)
    {
    }

    inline AssignResolveNode::AssignResolveNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, ExpressionNode* right, bool rightHasAssignments)
        : ExpressionNode(lineNumber)
        , m_ident(ident)
        , m_right(right)
        , m_rightHasAssignments(rightHasAssignments)
    {
    }

    inline ReadModifyBracketNode::ReadModifyBracketNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, ExpressionNode* subscript, Operator oper, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableSubExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_subscript(subscript)
        , m_right(right)
        , m_operator(oper)
        , m_subscriptHasAssignments(subscriptHasAssignments)
        , m_rightHasAssignments(rightHasAssignments)
    {
    }

    inline AssignBracketNode::AssignBracketNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, ExpressionNode* subscript, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_subscript(subscript)
        , m_right(right)
        , m_subscriptHasAssignments(subscriptHasAssignments)
        , m_rightHasAssignments(rightHasAssignments)
    {
    }

    inline AssignDotNode::AssignDotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp; ident, ExpressionNode* right, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_ident(ident)
        , m_right(right)
        , m_rightHasAssignments(rightHasAssignments)
    {
    }

    inline ReadModifyDotNode::ReadModifyDotNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp; ident, Operator oper, ExpressionNode* right, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableSubExpressionData(divot, startOffset, endOffset)
        , m_base(base)
        , m_ident(ident)
        , m_right(right)
        , m_operator(oper)
        , m_rightHasAssignments(rightHasAssignments)
    {
    }

    inline AssignErrorNode::AssignErrorNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* left, Operator oper, ExpressionNode* right, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        : ExpressionNode(lineNumber)
        , ThrowableExpressionData(divot, startOffset, endOffset)
        , m_left(left)
        , m_operator(oper)
        , m_right(right)
    {
    }

    inline CommaNode::CommaNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2)
        : ExpressionNode(lineNumber)
    {
        m_expressions.append(expr1);
        m_expressions.append(expr2);
    }

    inline ConstStatementNode::ConstStatementNode(<span class="enscript-type">int</span> lineNumber, ConstDeclNode* next)
        : StatementNode(lineNumber)
        , m_next(next)
    {
    }

    inline SourceElements::SourceElements()
    {
    }

    inline EmptyStatementNode::EmptyStatementNode(<span class="enscript-type">int</span> lineNumber)
        : StatementNode(lineNumber)
    {
    }

    inline DebuggerStatementNode::DebuggerStatementNode(<span class="enscript-type">int</span> lineNumber)
        : StatementNode(lineNumber)
    {
    }
    
    inline ExprStatementNode::ExprStatementNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : StatementNode(lineNumber)
        , m_expr(expr)
    {
    }

    inline VarStatementNode::VarStatementNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : StatementNode(lineNumber)
        , m_expr(expr)
    {
    }
    
    inline IfNode::IfNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* condition, StatementNode* ifBlock)
        : StatementNode(lineNumber)
        , m_condition(condition)
        , m_ifBlock(ifBlock)
    {
    }

    inline IfElseNode::IfElseNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* condition, StatementNode* ifBlock, StatementNode* elseBlock)
        : IfNode(lineNumber, condition, ifBlock)
        , m_elseBlock(elseBlock)
    {
    }

    inline DoWhileNode::DoWhileNode(<span class="enscript-type">int</span> lineNumber, StatementNode* statement, ExpressionNode* expr)
        : StatementNode(lineNumber)
        , m_statement(statement)
        , m_expr(expr)
    {
    }

    inline WhileNode::WhileNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr, StatementNode* statement)
        : StatementNode(lineNumber)
        , m_expr(expr)
        , m_statement(statement)
    {
    }

    inline ForNode::ForNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr1, ExpressionNode* expr2, ExpressionNode* expr3, StatementNode* statement, bool expr1WasVarDecl)
        : StatementNode(lineNumber)
        , m_expr1(expr1)
        , m_expr2(expr2)
        , m_expr3(expr3)
        , m_statement(statement)
        , m_expr1WasVarDecl(expr1 &amp;&amp; expr1WasVarDecl)
    {
        ASSERT(statement);
    }

    inline ContinueNode::ContinueNode(JSGlobalData* globalData, <span class="enscript-type">int</span> lineNumber)
        : StatementNode(lineNumber)
        , m_ident(globalData-&gt;propertyNames-&gt;nullIdentifier)
    {
    }

    inline ContinueNode::ContinueNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident)
        : StatementNode(lineNumber)
        , m_ident(ident)
    {
    }
    
    inline BreakNode::BreakNode(JSGlobalData* globalData, <span class="enscript-type">int</span> lineNumber)
        : StatementNode(lineNumber)
        , m_ident(globalData-&gt;propertyNames-&gt;nullIdentifier)
    {
    }

    inline BreakNode::BreakNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident)
        : StatementNode(lineNumber)
        , m_ident(ident)
    {
    }
    
    inline ReturnNode::ReturnNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* value)
        : StatementNode(lineNumber)
        , m_value(value)
    {
    }

    inline WithNode::WithNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr, StatementNode* statement, uint32_t divot, uint32_t expressionLength)
        : StatementNode(lineNumber)
        , m_expr(expr)
        , m_statement(statement)
        , m_divot(divot)
        , m_expressionLength(expressionLength)
    {
    }

    inline LabelNode::LabelNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; name, StatementNode* statement)
        : StatementNode(lineNumber)
        , m_name(name)
        , m_statement(statement)
    {
    }

    inline ThrowNode::ThrowNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr)
        : StatementNode(lineNumber)
        , m_expr(expr)
    {
    }

    inline TryNode::TryNode(<span class="enscript-type">int</span> lineNumber, StatementNode* tryBlock, <span class="enscript-type">const</span> Identifier&amp; exceptionIdent, StatementNode* catchBlock, StatementNode* finallyBlock)
        : StatementNode(lineNumber)
        , m_tryBlock(tryBlock)
        , m_exceptionIdent(exceptionIdent)
        , m_catchBlock(catchBlock)
        , m_finallyBlock(finallyBlock)
    {
    }

    inline ParameterNode::ParameterNode(<span class="enscript-type">const</span> Identifier&amp; ident)
        : m_ident(ident)
        , m_next(0)
    {
    }

    inline ParameterNode::ParameterNode(ParameterNode* l, <span class="enscript-type">const</span> Identifier&amp; ident)
        : m_ident(ident)
        , m_next(0)
    {
        l-&gt;m_next = this;
    }

    inline FuncExprNode::FuncExprNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, FunctionBodyNode* body, <span class="enscript-type">const</span> SourceCode&amp; source, ParameterNode* parameter)
        : ExpressionNode(lineNumber)
        , m_body(body)
    {
        m_body-&gt;finishParsing(source, parameter, ident);
    }

    inline FuncDeclNode::FuncDeclNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, FunctionBodyNode* body, <span class="enscript-type">const</span> SourceCode&amp; source, ParameterNode* parameter)
        : StatementNode(lineNumber)
        , m_body(body)
    {
        m_body-&gt;finishParsing(source, parameter, ident);
    }

    inline CaseClauseNode::CaseClauseNode(ExpressionNode* expr, SourceElements* statements)
        : m_expr(expr)
        , m_statements(statements)
    {
    }

    inline ClauseListNode::ClauseListNode(CaseClauseNode* clause)
        : m_clause(clause)
        , m_next(0)
    {
    }

    inline ClauseListNode::ClauseListNode(ClauseListNode* clauseList, CaseClauseNode* clause)
        : m_clause(clause)
        , m_next(0)
    {
        clauseList-&gt;m_next = this;
    }

    inline CaseBlockNode::CaseBlockNode(ClauseListNode* list1, CaseClauseNode* defaultClause, ClauseListNode* list2)
        : m_list1(list1)
        , m_defaultClause(defaultClause)
        , m_list2(list2)
    {
    }

    inline SwitchNode::SwitchNode(<span class="enscript-type">int</span> lineNumber, ExpressionNode* expr, CaseBlockNode* block)
        : StatementNode(lineNumber)
        , m_expr(expr)
        , m_block(block)
    {
    }

    inline ConstDeclNode::ConstDeclNode(<span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, ExpressionNode* init)
        : ExpressionNode(lineNumber)
        , m_ident(ident)
        , m_next(0)
        , m_init(init)
    {
    }

    inline BlockNode::BlockNode(<span class="enscript-type">int</span> lineNumber, SourceElements* statements)
        : StatementNode(lineNumber)
        , m_statements(statements)
    {
    }

    inline ForInNode::ForInNode(JSGlobalData* globalData, <span class="enscript-type">int</span> lineNumber, ExpressionNode* l, ExpressionNode* expr, StatementNode* statement)
        : StatementNode(lineNumber)
        , m_ident(globalData-&gt;propertyNames-&gt;nullIdentifier)
        , m_init(0)
        , m_lexpr(l)
        , m_expr(expr)
        , m_statement(statement)
        , m_identIsVarDecl(false)
    {
    }

    inline ForInNode::ForInNode(JSGlobalData* globalData, <span class="enscript-type">int</span> lineNumber, <span class="enscript-type">const</span> Identifier&amp; ident, ExpressionNode* in, ExpressionNode* expr, StatementNode* statement, <span class="enscript-type">int</span> divot, <span class="enscript-type">int</span> startOffset, <span class="enscript-type">int</span> endOffset)
        : StatementNode(lineNumber)
        , m_ident(ident)
        , m_init(0)
        , m_lexpr(new (globalData) ResolveNode(lineNumber, ident, divot - startOffset))
        , m_expr(expr)
        , m_statement(statement)
        , m_identIsVarDecl(true)
    {
        <span class="enscript-keyword">if</span> (in) {
            AssignResolveNode* node = new (globalData) AssignResolveNode(lineNumber, ident, in, true);
            node-&gt;setExceptionSourceCode(divot, divot - startOffset, endOffset - divot);
            m_init = node;
        }
        <span class="enscript-comment">// for( var foo = bar in baz )
</span>    }

} <span class="enscript-comment">// namespace JSC
</span>
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">NodeConstructors_h</span>
</pre>
<hr />
</body></html>