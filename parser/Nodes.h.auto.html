<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Nodes.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">Nodes.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 *  Copyright (C) 1999-2000 Harri Porten (<a href="mailto:porten@kde.org">porten@kde.org</a>)
 *  Copyright (C) 2001 Peter Kelly (<a href="mailto:pmk@post.com">pmk@post.com</a>)
 *  Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
 *  Copyright (C) 2007 Cameron Zwarich (<a href="mailto:cwzwarich@uwaterloo.ca">cwzwarich@uwaterloo.ca</a>)
 *  Copyright (C) 2007 Maks Orlovich
 *  Copyright (C) 2007 Eric Seidel &lt;<a href="mailto:eric@webkit.org">eric@webkit.org</a>&gt;
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public License
 *  along with this library; see the file COPYING.LIB.  If not, write to
 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA 02110-1301, USA.
 *
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">Nodes_h</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">Nodes_h</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Error.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;JITCode.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Opcode.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ParserArena.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ResultType.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;SourceCode.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;SymbolTable.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/MathExtras.h&gt;</span>

namespace JSC {

    class ArgumentListNode;
    class BytecodeGenerator;
    class FunctionBodyNode;
    class Label;
    class PropertyListNode;
    class ReadModifyResolveNode;
    class RegisterID;
    class ScopeChainNode;
    class ScopeNode;

    <span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> CodeFeatures;

    <span class="enscript-type">const</span> CodeFeatures NoFeatures = 0;
    <span class="enscript-type">const</span> CodeFeatures EvalFeature = 1 &lt;&lt; 0;
    <span class="enscript-type">const</span> CodeFeatures ArgumentsFeature = 1 &lt;&lt; 1;
    <span class="enscript-type">const</span> CodeFeatures WithFeature = 1 &lt;&lt; 2;
    <span class="enscript-type">const</span> CodeFeatures CatchFeature = 1 &lt;&lt; 3;
    <span class="enscript-type">const</span> CodeFeatures ThisFeature = 1 &lt;&lt; 4;
    <span class="enscript-type">const</span> CodeFeatures StrictModeFeature = 1 &lt;&lt; 5;
    <span class="enscript-type">const</span> CodeFeatures ShadowsArgumentsFeature = 1 &lt;&lt; 6;
    
    <span class="enscript-type">const</span> CodeFeatures AllFeatures = EvalFeature | ArgumentsFeature | WithFeature | CatchFeature | ThisFeature | StrictModeFeature | ShadowsArgumentsFeature;

    <span class="enscript-type">enum</span> Operator {
        OpEqual,
        OpPlusEq,
        OpMinusEq,
        OpMultEq,
        OpDivEq,
        OpPlusPlus,
        OpMinusMinus,
        OpAndEq,
        OpXOrEq,
        OpOrEq,
        OpModEq,
        OpLShift,
        OpRShift,
        OpURShift
    };
    
    <span class="enscript-type">enum</span> LogicalOperator {
        OpLogicalAnd,
        OpLogicalOr
    };

    <span class="enscript-type">typedef</span> HashSet&lt;RefPtr&lt;StringImpl&gt;, IdentifierRepHash&gt; IdentifierSet;

    namespace DeclarationStacks {
        <span class="enscript-type">enum</span> VarAttrs { IsConstant = 1, HasInitializer = 2 };
        <span class="enscript-type">typedef</span> Vector&lt;std::pair&lt;<span class="enscript-type">const</span> Identifier*, <span class="enscript-type">unsigned</span>&gt; &gt; VarStack;
        <span class="enscript-type">typedef</span> Vector&lt;FunctionBodyNode*&gt; FunctionStack;
    }

    <span class="enscript-type">struct</span> SwitchInfo {
        <span class="enscript-type">enum</span> SwitchType { SwitchNone, SwitchImmediate, SwitchCharacter, SwitchString };
        uint32_t bytecodeOffset;
        SwitchType switchType;
    };

    class ParserArenaFreeable {
    <span class="enscript-reference">public</span>:
        <span class="enscript-comment">// ParserArenaFreeable objects are are freed when the arena is deleted.
</span>        <span class="enscript-comment">// Destructors are not called. Clients must not call delete on such objects.
</span>        <span class="enscript-type">void</span>* operator new(size_t, JSGlobalData*);
    };

    class ParserArenaDeletable {
    <span class="enscript-reference">public</span>:
        virtual ~ParserArenaDeletable() { }

        <span class="enscript-comment">// ParserArenaDeletable objects are deleted when the arena is deleted.
</span>        <span class="enscript-comment">// Clients must not call delete directly on such objects.
</span>        <span class="enscript-type">void</span>* operator new(size_t, JSGlobalData*);
    };

    template &lt;typename T&gt;
    <span class="enscript-type">struct</span> ParserArenaData : ParserArenaDeletable {
        T data;
    };

    class ParserArenaRefCounted : public RefCounted&lt;ParserArenaRefCounted&gt; {
    <span class="enscript-reference">protected</span>:
        ParserArenaRefCounted(JSGlobalData*);

    <span class="enscript-reference">public</span>:
        virtual ~ParserArenaRefCounted()
        {
            ASSERT(deletionHasBegun());
        }
    };

    class Node : public ParserArenaFreeable {
    <span class="enscript-reference">protected</span>:
        Node(<span class="enscript-type">int</span>);

    <span class="enscript-reference">public</span>:
        virtual ~Node() { }

        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = 0) = 0;

        <span class="enscript-type">int</span> lineNo() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_lineNumber; }

    <span class="enscript-reference">protected</span>:
        <span class="enscript-type">int</span> m_lineNumber;
    };

    class ExpressionNode : public Node {
    <span class="enscript-reference">protected</span>:
        ExpressionNode(<span class="enscript-type">int</span>, ResultType = ResultType::unknownType());

    <span class="enscript-reference">public</span>:
        virtual bool isNumber() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isString() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isNull() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isPure(BytecodeGenerator&amp;) <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }        
        virtual bool isLocation() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isResolveNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isBracketAccessorNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isDotAccessorNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isFuncExprNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isCommaNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isSimpleArray() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isAdd() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isSubtract() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool hasConditionContextCodegen() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }

        virtual <span class="enscript-type">void</span> emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label*, Label*, bool) { ASSERT_NOT_REACHED(); }

        virtual ExpressionNode* stripUnaryPlus() { <span class="enscript-keyword">return</span> this; }

        ResultType resultDescriptor() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_resultType; }

    <span class="enscript-reference">private</span>:
        ResultType m_resultType;
    };

    class StatementNode : public Node {
    <span class="enscript-reference">protected</span>:
        StatementNode(<span class="enscript-type">int</span>);

    <span class="enscript-reference">public</span>:
        JS_EXPORT_PRIVATE <span class="enscript-type">void</span> setLoc(<span class="enscript-type">int</span> firstLine, <span class="enscript-type">int</span> lastLine);
        <span class="enscript-type">int</span> firstLine() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> lineNo(); }
        <span class="enscript-type">int</span> lastLine() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_lastLine; }

        virtual bool isEmptyStatement() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isReturnNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }
        virtual bool isExprStatement() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }

        virtual bool isBlock() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> false; }

    <span class="enscript-reference">private</span>:
        <span class="enscript-type">int</span> m_lastLine;
    };

    class NullNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        NullNode(<span class="enscript-type">int</span>);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isNull() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }
    };

    class BooleanNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        BooleanNode(<span class="enscript-type">int</span>, bool value);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isPure(BytecodeGenerator&amp;) <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        bool m_value;
    };

    class NumberNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        NumberNode(<span class="enscript-type">int</span>, <span class="enscript-type">double</span> value);

        <span class="enscript-type">double</span> value() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_value; }
        <span class="enscript-type">void</span> setValue(<span class="enscript-type">double</span> value) { m_value = value; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isNumber() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }
        virtual bool isPure(BytecodeGenerator&amp;) <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        <span class="enscript-type">double</span> m_value;
    };

    class StringNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        StringNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;);

        <span class="enscript-type">const</span> Identifier&amp; value() { <span class="enscript-keyword">return</span> m_value; }

    <span class="enscript-reference">private</span>:
        virtual bool isPure(BytecodeGenerator&amp;) <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
        
        virtual bool isString() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        <span class="enscript-type">const</span> Identifier&amp; m_value;
    };
    
    class ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        ThrowableExpressionData()
            : m_divot(static_cast&lt;uint32_t&gt;(-1))
            , m_startOffset(static_cast&lt;uint16_t&gt;(-1))
            , m_endOffset(static_cast&lt;uint16_t&gt;(-1))
        {
        }
        
        ThrowableExpressionData(<span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
            : m_divot(divot)
            , m_startOffset(startOffset)
            , m_endOffset(endOffset)
        {
        }
        
        <span class="enscript-type">void</span> setExceptionSourceCode(<span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
        {
            m_divot = divot;
            m_startOffset = startOffset;
            m_endOffset = endOffset;
        }

        uint32_t divot() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_divot; }
        uint16_t startOffset() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_startOffset; }
        uint16_t endOffset() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_endOffset; }

    <span class="enscript-reference">protected</span>:
        RegisterID* emitThrowReferenceError(BytecodeGenerator&amp;, <span class="enscript-type">const</span> UString&amp; message);

    <span class="enscript-reference">private</span>:
        uint32_t m_divot;
        uint16_t m_startOffset;
        uint16_t m_endOffset;
    };

    class ThrowableSubExpressionData : public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        ThrowableSubExpressionData()
            : m_subexpressionDivotOffset(0)
            , m_subexpressionEndOffset(0)
        {
        }

        ThrowableSubExpressionData(<span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
            : ThrowableExpressionData(divot, startOffset, endOffset)
            , m_subexpressionDivotOffset(0)
            , m_subexpressionEndOffset(0)
        {
        }

        <span class="enscript-type">void</span> setSubexpressionInfo(uint32_t subexpressionDivot, uint16_t subexpressionOffset)
        {
            ASSERT(subexpressionDivot &lt;= divot());
            <span class="enscript-keyword">if</span> ((divot() - subexpressionDivot) &amp; ~0xFFFF) <span class="enscript-comment">// Overflow means we can't do this safely, so just point at the primary divot
</span>                <span class="enscript-keyword">return</span>;
            m_subexpressionDivotOffset = divot() - subexpressionDivot;
            m_subexpressionEndOffset = subexpressionOffset;
        }

    <span class="enscript-reference">protected</span>:
        uint16_t m_subexpressionDivotOffset;
        uint16_t m_subexpressionEndOffset;
    };
    
    class ThrowablePrefixedSubExpressionData : public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        ThrowablePrefixedSubExpressionData()
            : m_subexpressionDivotOffset(0)
            , m_subexpressionStartOffset(0)
        {
        }

        ThrowablePrefixedSubExpressionData(<span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset)
            : ThrowableExpressionData(divot, startOffset, endOffset)
            , m_subexpressionDivotOffset(0)
            , m_subexpressionStartOffset(0)
        {
        }

        <span class="enscript-type">void</span> setSubexpressionInfo(uint32_t subexpressionDivot, uint16_t subexpressionOffset)
        {
            ASSERT(subexpressionDivot &gt;= divot());
            <span class="enscript-keyword">if</span> ((subexpressionDivot - divot()) &amp; ~0xFFFF) <span class="enscript-comment">// Overflow means we can't do this safely, so just point at the primary divot
</span>                <span class="enscript-keyword">return</span>;
            m_subexpressionDivotOffset = subexpressionDivot - divot();
            m_subexpressionStartOffset = subexpressionOffset;
        }

    <span class="enscript-reference">protected</span>:
        uint16_t m_subexpressionDivotOffset;
        uint16_t m_subexpressionStartOffset;
    };

    class RegExpNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        RegExpNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp; pattern, <span class="enscript-type">const</span> Identifier&amp; flags);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_pattern;
        <span class="enscript-type">const</span> Identifier&amp; m_flags;
    };

    class ThisNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        ThisNode(<span class="enscript-type">int</span>);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };

    class ResolveNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        ResolveNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, <span class="enscript-type">int</span> startOffset);

        <span class="enscript-type">const</span> Identifier&amp; identifier() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_ident; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isPure(BytecodeGenerator&amp;) <span class="enscript-type">const</span> ;
        virtual bool isLocation() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }
        virtual bool isResolveNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        int32_t m_startOffset;
    };

    class ElementNode : public ParserArenaFreeable {
    <span class="enscript-reference">public</span>:
        ElementNode(<span class="enscript-type">int</span> elision, ExpressionNode*);
        ElementNode(ElementNode*, <span class="enscript-type">int</span> elision, ExpressionNode*);

        <span class="enscript-type">int</span> elision() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_elision; }
        ExpressionNode* value() { <span class="enscript-keyword">return</span> m_node; }
        ElementNode* next() { <span class="enscript-keyword">return</span> m_next; }

    <span class="enscript-reference">private</span>:
        ElementNode* m_next;
        <span class="enscript-type">int</span> m_elision;
        ExpressionNode* m_node;
    };

    class ArrayNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        ArrayNode(<span class="enscript-type">int</span>, <span class="enscript-type">int</span> elision);
        ArrayNode(<span class="enscript-type">int</span>, ElementNode*);
        ArrayNode(<span class="enscript-type">int</span>, <span class="enscript-type">int</span> elision, ElementNode*);

        ArgumentListNode* toArgumentList(JSGlobalData*, <span class="enscript-type">int</span>) <span class="enscript-type">const</span>;

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isSimpleArray() <span class="enscript-type">const</span> ;

        ElementNode* m_element;
        <span class="enscript-type">int</span> m_elision;
        bool m_optional;
    };

    class PropertyNode : public ParserArenaFreeable {
    <span class="enscript-reference">public</span>:
        <span class="enscript-type">enum</span> Type { Constant = 1, Getter = 2, Setter = 4 };

        PropertyNode(JSGlobalData*, <span class="enscript-type">const</span> Identifier&amp;, ExpressionNode*, Type);
        PropertyNode(JSGlobalData*, <span class="enscript-type">double</span>, ExpressionNode*, Type);

        <span class="enscript-type">const</span> Identifier&amp; name() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_name; }
        Type type() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_type; }

    <span class="enscript-reference">private</span>:
        friend class PropertyListNode;
        <span class="enscript-type">const</span> Identifier&amp; m_name;
        ExpressionNode* m_assign;
        Type m_type;
    };

    class PropertyListNode : public Node {
    <span class="enscript-reference">public</span>:
        PropertyListNode(<span class="enscript-type">int</span>, PropertyNode*);
        PropertyListNode(<span class="enscript-type">int</span>, PropertyNode*, PropertyListNode*);

        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

    <span class="enscript-reference">private</span>:
        PropertyNode* m_node;
        PropertyListNode* m_next;
    };

    class ObjectLiteralNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        ObjectLiteralNode(<span class="enscript-type">int</span>);
        ObjectLiteralNode(<span class="enscript-type">int</span>, PropertyListNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        PropertyListNode* m_list;
    };
    
    class BracketAccessorNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        BracketAccessorNode(<span class="enscript-type">int</span>, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments);

        ExpressionNode* base() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_base; }
        ExpressionNode* subscript() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_subscript; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isLocation() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }
        virtual bool isBracketAccessorNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        bool m_subscriptHasAssignments;
    };

    class DotAccessorNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        DotAccessorNode(<span class="enscript-type">int</span>, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp;);

        ExpressionNode* base() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_base; }
        <span class="enscript-type">const</span> Identifier&amp; identifier() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_ident; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isLocation() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }
        virtual bool isDotAccessorNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        ExpressionNode* m_base;
        <span class="enscript-type">const</span> Identifier&amp; m_ident;
    };

    class ArgumentListNode : public Node {
    <span class="enscript-reference">public</span>:
        ArgumentListNode(<span class="enscript-type">int</span>, ExpressionNode*);
        ArgumentListNode(<span class="enscript-type">int</span>, ArgumentListNode*, ExpressionNode*);

        ArgumentListNode* m_next;
        ExpressionNode* m_expr;

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };

    class ArgumentsNode : public ParserArenaFreeable {
    <span class="enscript-reference">public</span>:
        ArgumentsNode();
        ArgumentsNode(ArgumentListNode*);

        ArgumentListNode* m_listNode;
    };

    class NewExprNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        NewExprNode(<span class="enscript-type">int</span>, ExpressionNode*);
        NewExprNode(<span class="enscript-type">int</span>, ExpressionNode*, ArgumentsNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
        ArgumentsNode* m_args;
    };

    class EvalFunctionCallNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        EvalFunctionCallNode(<span class="enscript-type">int</span>, ArgumentsNode*, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ArgumentsNode* m_args;
    };

    class FunctionCallValueNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        FunctionCallValueNode(<span class="enscript-type">int</span>, ExpressionNode*, ArgumentsNode*, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
        ArgumentsNode* m_args;
    };

    class FunctionCallResolveNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        FunctionCallResolveNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, ArgumentsNode*, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        ArgumentsNode* m_args;
        size_t m_index; <span class="enscript-comment">// Used by LocalVarFunctionCallNode.
</span>        size_t m_scopeDepth; <span class="enscript-comment">// Used by ScopedVarFunctionCallNode and NonLocalVarFunctionCallNode
</span>    };
    
    class FunctionCallBracketNode : public ExpressionNode, public ThrowableSubExpressionData {
    <span class="enscript-reference">public</span>:
        FunctionCallBracketNode(<span class="enscript-type">int</span>, ExpressionNode* base, ExpressionNode* subscript, ArgumentsNode*, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        ArgumentsNode* m_args;
    };

    class FunctionCallDotNode : public ExpressionNode, public ThrowableSubExpressionData {
    <span class="enscript-reference">public</span>:
        FunctionCallDotNode(<span class="enscript-type">int</span>, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp;, ArgumentsNode*, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

    <span class="enscript-reference">protected</span>:
        ExpressionNode* m_base;
        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        ArgumentsNode* m_args;
    };

    class CallFunctionCallDotNode : public FunctionCallDotNode {
    <span class="enscript-reference">public</span>:
        CallFunctionCallDotNode(<span class="enscript-type">int</span>, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp;, ArgumentsNode*, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };
    
    class ApplyFunctionCallDotNode : public FunctionCallDotNode {
    <span class="enscript-reference">public</span>:
        ApplyFunctionCallDotNode(<span class="enscript-type">int</span>, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp;, ArgumentsNode*, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };

    class PrePostResolveNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        PrePostResolveNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">protected</span>:
        <span class="enscript-type">const</span> Identifier&amp; m_ident;
    };

    class PostfixResolveNode : public PrePostResolveNode {
    <span class="enscript-reference">public</span>:
        PostfixResolveNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, Operator, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        Operator m_operator;
    };

    class PostfixBracketNode : public ExpressionNode, public ThrowableSubExpressionData {
    <span class="enscript-reference">public</span>:
        PostfixBracketNode(<span class="enscript-type">int</span>, ExpressionNode* base, ExpressionNode* subscript, Operator, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        Operator m_operator;
    };

    class PostfixDotNode : public ExpressionNode, public ThrowableSubExpressionData {
    <span class="enscript-reference">public</span>:
        PostfixDotNode(<span class="enscript-type">int</span>, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp;, Operator, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        Operator m_operator;
    };

    class PostfixErrorNode : public ExpressionNode, public ThrowableSubExpressionData {
    <span class="enscript-reference">public</span>:
        PostfixErrorNode(<span class="enscript-type">int</span>, ExpressionNode*, Operator, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
        Operator m_operator;
    };

    class DeleteResolveNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        DeleteResolveNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_ident;
    };

    class DeleteBracketNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        DeleteBracketNode(<span class="enscript-type">int</span>, ExpressionNode* base, ExpressionNode* subscript, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
    };

    class DeleteDotNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        DeleteDotNode(<span class="enscript-type">int</span>, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp;, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        <span class="enscript-type">const</span> Identifier&amp; m_ident;
    };

    class DeleteValueNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        DeleteValueNode(<span class="enscript-type">int</span>, ExpressionNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class VoidNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        VoidNode(<span class="enscript-type">int</span>, ExpressionNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class TypeOfResolveNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        TypeOfResolveNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;);

        <span class="enscript-type">const</span> Identifier&amp; identifier() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_ident; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_ident;
    };

    class TypeOfValueNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        TypeOfValueNode(<span class="enscript-type">int</span>, ExpressionNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class PrefixResolveNode : public PrePostResolveNode {
    <span class="enscript-reference">public</span>:
        PrefixResolveNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, Operator, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        Operator m_operator;
    };

    class PrefixBracketNode : public ExpressionNode, public ThrowablePrefixedSubExpressionData {
    <span class="enscript-reference">public</span>:
        PrefixBracketNode(<span class="enscript-type">int</span>, ExpressionNode* base, ExpressionNode* subscript, Operator, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        Operator m_operator;
    };

    class PrefixDotNode : public ExpressionNode, public ThrowablePrefixedSubExpressionData {
    <span class="enscript-reference">public</span>:
        PrefixDotNode(<span class="enscript-type">int</span>, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp;, Operator, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        Operator m_operator;
    };

    class PrefixErrorNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        PrefixErrorNode(<span class="enscript-type">int</span>, ExpressionNode*, Operator, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
        Operator m_operator;
    };

    class UnaryOpNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        UnaryOpNode(<span class="enscript-type">int</span>, ResultType, ExpressionNode*, OpcodeID);

    <span class="enscript-reference">protected</span>:
        ExpressionNode* expr() { <span class="enscript-keyword">return</span> m_expr; }
        <span class="enscript-type">const</span> ExpressionNode* expr() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_expr; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        OpcodeID opcodeID() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_opcodeID; }

        ExpressionNode* m_expr;
        OpcodeID m_opcodeID;
    };

    class UnaryPlusNode : public UnaryOpNode {
    <span class="enscript-reference">public</span>:
        UnaryPlusNode(<span class="enscript-type">int</span>, ExpressionNode*);

    <span class="enscript-reference">private</span>:
        virtual ExpressionNode* stripUnaryPlus() { <span class="enscript-keyword">return</span> expr(); }
    };

    class NegateNode : public UnaryOpNode {
    <span class="enscript-reference">public</span>:
        NegateNode(<span class="enscript-type">int</span>, ExpressionNode*);
    };

    class BitwiseNotNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        BitwiseNotNode(<span class="enscript-type">int</span>, ExpressionNode*);

    <span class="enscript-reference">protected</span>:
        ExpressionNode* expr() { <span class="enscript-keyword">return</span> m_expr; }
        <span class="enscript-type">const</span> ExpressionNode* expr() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_expr; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
    };
 
    class LogicalNotNode : public UnaryOpNode {
    <span class="enscript-reference">public</span>:
        LogicalNotNode(<span class="enscript-type">int</span>, ExpressionNode*);
    <span class="enscript-reference">private</span>:
        <span class="enscript-type">void</span> emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label* trueTarget, Label* falseTarget, bool fallThroughMeansTrue);
        virtual bool hasConditionContextCodegen() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> expr()-&gt;hasConditionContextCodegen(); }
    };

    class BinaryOpNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        BinaryOpNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
        BinaryOpNode(<span class="enscript-type">int</span>, ResultType, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);

        RegisterID* emitStrcat(BytecodeGenerator&amp; generator, RegisterID* destination, RegisterID* lhs = 0, ReadModifyResolveNode* emitExpressionInfoForMe = 0);

        ExpressionNode* lhs() { <span class="enscript-keyword">return</span> m_expr1; };
        ExpressionNode* rhs() { <span class="enscript-keyword">return</span> m_expr2; };

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

    <span class="enscript-reference">protected</span>:
        OpcodeID opcodeID() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_opcodeID; }

    <span class="enscript-reference">protected</span>:
        ExpressionNode* m_expr1;
        ExpressionNode* m_expr2;
    <span class="enscript-reference">private</span>:
        OpcodeID m_opcodeID;
    <span class="enscript-reference">protected</span>:
        bool m_rightHasAssignments;
    };

    class MultNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        MultNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class DivNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        DivNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class ModNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        ModNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class AddNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        AddNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

        virtual bool isAdd() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }
    };

    class SubNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        SubNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

        virtual bool isSubtract() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }
    };

    class LeftShiftNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        LeftShiftNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class RightShiftNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        RightShiftNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class UnsignedRightShiftNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        UnsignedRightShiftNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class LessNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        LessNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class GreaterNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        GreaterNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class LessEqNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        LessEqNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class GreaterEqNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        GreaterEqNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class ThrowableBinaryOpNode : public BinaryOpNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        ThrowableBinaryOpNode(<span class="enscript-type">int</span>, ResultType, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);
        ThrowableBinaryOpNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, OpcodeID, bool rightHasAssignments);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };
    
    class InstanceOfNode : public ThrowableBinaryOpNode {
    <span class="enscript-reference">public</span>:
        InstanceOfNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };

    class InNode : public ThrowableBinaryOpNode {
    <span class="enscript-reference">public</span>:
        InNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class EqualNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        EqualNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };

    class NotEqualNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        NotEqualNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class StrictEqualNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        StrictEqualNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };

    class NotStrictEqualNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        NotStrictEqualNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class BitAndNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        BitAndNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class BitOrNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        BitOrNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    class BitXOrNode : public BinaryOpNode {
    <span class="enscript-reference">public</span>:
        BitXOrNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments);
    };

    <span class="enscript-comment">// m_expr1 &amp;&amp; m_expr2, m_expr1 || m_expr2
</span>    class LogicalOpNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        LogicalOpNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, LogicalOperator);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
        <span class="enscript-type">void</span> emitBytecodeInConditionContext(BytecodeGenerator&amp;, Label* trueTarget, Label* falseTarget, bool fallThroughMeansTrue);
        virtual bool hasConditionContextCodegen() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        ExpressionNode* m_expr1;
        ExpressionNode* m_expr2;
        LogicalOperator m_operator;
    };

    <span class="enscript-comment">// The ternary operator, &quot;m_logical ? m_expr1 : m_expr2&quot;
</span>    class ConditionalNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        ConditionalNode(<span class="enscript-type">int</span>, ExpressionNode* logical, ExpressionNode* expr1, ExpressionNode* expr2);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_logical;
        ExpressionNode* m_expr1;
        ExpressionNode* m_expr2;
    };

    class ReadModifyResolveNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        ReadModifyResolveNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, Operator, ExpressionNode*  right, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        ExpressionNode* m_right;
        size_t m_index; <span class="enscript-comment">// Used by ReadModifyLocalVarNode.
</span>        Operator m_operator;
        bool m_rightHasAssignments;
    };

    class AssignResolveNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        AssignResolveNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, ExpressionNode* right, bool rightHasAssignments);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        ExpressionNode* m_right;
        size_t m_index; <span class="enscript-comment">// Used by ReadModifyLocalVarNode.
</span>        bool m_rightHasAssignments;
    };

    class ReadModifyBracketNode : public ExpressionNode, public ThrowableSubExpressionData {
    <span class="enscript-reference">public</span>:
        ReadModifyBracketNode(<span class="enscript-type">int</span>, ExpressionNode* base, ExpressionNode* subscript, Operator, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        ExpressionNode* m_right;
        Operator m_operator : 30;
        bool m_subscriptHasAssignments : 1;
        bool m_rightHasAssignments : 1;
    };

    class AssignBracketNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        AssignBracketNode(<span class="enscript-type">int</span>, ExpressionNode* base, ExpressionNode* subscript, ExpressionNode* right, bool subscriptHasAssignments, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        ExpressionNode* m_subscript;
        ExpressionNode* m_right;
        bool m_subscriptHasAssignments : 1;
        bool m_rightHasAssignments : 1;
    };

    class AssignDotNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        AssignDotNode(<span class="enscript-type">int</span>, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp;, ExpressionNode* right, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        ExpressionNode* m_right;
        bool m_rightHasAssignments;
    };

    class ReadModifyDotNode : public ExpressionNode, public ThrowableSubExpressionData {
    <span class="enscript-reference">public</span>:
        ReadModifyDotNode(<span class="enscript-type">int</span>, ExpressionNode* base, <span class="enscript-type">const</span> Identifier&amp;, Operator, ExpressionNode* right, bool rightHasAssignments, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_base;
        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        ExpressionNode* m_right;
        Operator m_operator : 31;
        bool m_rightHasAssignments : 1;
    };

    class AssignErrorNode : public ExpressionNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        AssignErrorNode(<span class="enscript-type">int</span>, ExpressionNode* left, Operator, ExpressionNode* right, <span class="enscript-type">unsigned</span> divot, <span class="enscript-type">unsigned</span> startOffset, <span class="enscript-type">unsigned</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_left;
        Operator m_operator;
        ExpressionNode* m_right;
    };
    
    <span class="enscript-type">typedef</span> Vector&lt;ExpressionNode*, 8&gt; ExpressionVector;

    class CommaNode : public ExpressionNode, public ParserArenaDeletable {
    <span class="enscript-reference">public</span>:
        CommaNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2);

        using ParserArenaDeletable::operator new;

        <span class="enscript-type">void</span> append(ExpressionNode* expr) { m_expressions.append(expr); }

    <span class="enscript-reference">private</span>:
        virtual bool isCommaNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionVector m_expressions;
    };
    
    class ConstDeclNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        ConstDeclNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, ExpressionNode*);

        bool hasInitializer() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_init; }
        <span class="enscript-type">const</span> Identifier&amp; ident() { <span class="enscript-keyword">return</span> m_ident; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
        virtual RegisterID* emitCodeSingle(BytecodeGenerator&amp;);

        <span class="enscript-type">const</span> Identifier&amp; m_ident;

    <span class="enscript-reference">public</span>:
        ConstDeclNode* m_next;

    <span class="enscript-reference">private</span>:
        ExpressionNode* m_init;
    };

    class ConstStatementNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        ConstStatementNode(<span class="enscript-type">int</span>, ConstDeclNode* next);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ConstDeclNode* m_next;
    };

    class SourceElements : public ParserArenaDeletable {
    <span class="enscript-reference">public</span>:
        SourceElements();

        <span class="enscript-type">void</span> append(StatementNode*);

        StatementNode* singleStatement() <span class="enscript-type">const</span>;
        StatementNode* lastStatement() <span class="enscript-type">const</span>;

        <span class="enscript-type">void</span> emitBytecode(BytecodeGenerator&amp;, RegisterID* destination);

    <span class="enscript-reference">private</span>:
        Vector&lt;StatementNode*&gt; m_statements;
    };

    class BlockNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        BlockNode(<span class="enscript-type">int</span>, SourceElements* = 0);

        StatementNode* singleStatement() <span class="enscript-type">const</span>;
        StatementNode* lastStatement() <span class="enscript-type">const</span>;

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isBlock() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        SourceElements* m_statements;
    };

    class EmptyStatementNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        EmptyStatementNode(<span class="enscript-type">int</span>);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isEmptyStatement() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }
    };
    
    class DebuggerStatementNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        DebuggerStatementNode(<span class="enscript-type">int</span>);
        
    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };

    class ExprStatementNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        ExprStatementNode(<span class="enscript-type">int</span>, ExpressionNode*);

        ExpressionNode* expr() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_expr; }

    <span class="enscript-reference">private</span>:
        virtual bool isExprStatement() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class VarStatementNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        VarStatementNode(<span class="enscript-type">int</span>, ExpressionNode*);        

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class IfNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        IfNode(<span class="enscript-type">int</span>, ExpressionNode* condition, StatementNode* ifBlock);

    <span class="enscript-reference">protected</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_condition;
        StatementNode* m_ifBlock;
    };

    class IfElseNode : public IfNode {
    <span class="enscript-reference">public</span>:
        IfElseNode(<span class="enscript-type">int</span>, ExpressionNode* condition, StatementNode* ifBlock, StatementNode* elseBlock);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        StatementNode* m_elseBlock;
    };

    class DoWhileNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        DoWhileNode(<span class="enscript-type">int</span>, StatementNode*, ExpressionNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        StatementNode* m_statement;
        ExpressionNode* m_expr;
    };

    class WhileNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        WhileNode(<span class="enscript-type">int</span>, ExpressionNode*, StatementNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
        StatementNode* m_statement;
    };

    class ForNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        ForNode(<span class="enscript-type">int</span>, ExpressionNode* expr1, ExpressionNode* expr2, ExpressionNode* expr3, StatementNode*, bool expr1WasVarDecl);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr1;
        ExpressionNode* m_expr2;
        ExpressionNode* m_expr3;
        StatementNode* m_statement;
        bool m_expr1WasVarDecl;
    };

    class ForInNode : public StatementNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        ForInNode(JSGlobalData*, <span class="enscript-type">int</span>, ExpressionNode*, ExpressionNode*, StatementNode*);
        ForInNode(JSGlobalData*, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, ExpressionNode*, ExpressionNode*, StatementNode*, <span class="enscript-type">int</span> divot, <span class="enscript-type">int</span> startOffset, <span class="enscript-type">int</span> endOffset);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        ExpressionNode* m_init;
        ExpressionNode* m_lexpr;
        ExpressionNode* m_expr;
        StatementNode* m_statement;
        bool m_identIsVarDecl;
    };

    class ContinueNode : public StatementNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        ContinueNode(JSGlobalData*, <span class="enscript-type">int</span>);
        ContinueNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;);
        
    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_ident;
    };

    class BreakNode : public StatementNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        BreakNode(JSGlobalData*, <span class="enscript-type">int</span>);
        BreakNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;);
        
    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_ident;
    };

    class ReturnNode : public StatementNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        ReturnNode(<span class="enscript-type">int</span>, ExpressionNode* value);

        ExpressionNode* value() { <span class="enscript-keyword">return</span> m_value; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isReturnNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; }

        ExpressionNode* m_value;
    };

    class WithNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        WithNode(<span class="enscript-type">int</span>, ExpressionNode*, StatementNode*, uint32_t divot, uint32_t expressionLength);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
        StatementNode* m_statement;
        uint32_t m_divot;
        uint32_t m_expressionLength;
    };

    class LabelNode : public StatementNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        LabelNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp; name, StatementNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">const</span> Identifier&amp; m_name;
        StatementNode* m_statement;
    };

    class ThrowNode : public StatementNode, public ThrowableExpressionData {
    <span class="enscript-reference">public</span>:
        ThrowNode(<span class="enscript-type">int</span>, ExpressionNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
    };

    class TryNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        TryNode(<span class="enscript-type">int</span>, StatementNode* tryBlock, <span class="enscript-type">const</span> Identifier&amp; exceptionIdent, StatementNode* catchBlock, StatementNode* finallyBlock);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        StatementNode* m_tryBlock;
        <span class="enscript-type">const</span> Identifier&amp; m_exceptionIdent;
        StatementNode* m_catchBlock;
        StatementNode* m_finallyBlock;
    };

    class ParameterNode : public ParserArenaFreeable {
    <span class="enscript-reference">public</span>:
        ParameterNode(<span class="enscript-type">const</span> Identifier&amp;);
        ParameterNode(ParameterNode*, <span class="enscript-type">const</span> Identifier&amp;);

        <span class="enscript-type">const</span> Identifier&amp; ident() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_ident; }
        ParameterNode* nextParam() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_next; }

    <span class="enscript-reference">private</span>:
        <span class="enscript-type">const</span> Identifier&amp; m_ident;
        ParameterNode* m_next;
    };

    class ScopeNode : public StatementNode, public ParserArenaRefCounted {
    <span class="enscript-reference">public</span>:
        <span class="enscript-type">typedef</span> DeclarationStacks::VarStack VarStack;
        <span class="enscript-type">typedef</span> DeclarationStacks::FunctionStack FunctionStack;

        ScopeNode(JSGlobalData*, <span class="enscript-type">int</span>, bool inStrictContext);
        ScopeNode(JSGlobalData*, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> SourceCode&amp;, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&amp;, CodeFeatures, <span class="enscript-type">int</span> numConstants);

        using ParserArenaRefCounted::operator new;

        <span class="enscript-type">void</span> destroyData()
        {
            m_arena.reset();
            m_varStack.clear();
            m_functionStack.clear();
            m_statements = 0;
            m_capturedVariables.clear();
        }

        <span class="enscript-type">const</span> SourceCode&amp; source() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_source; }
        <span class="enscript-type">const</span> UString&amp; sourceURL() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_source.provider()-&gt;url(); }
        intptr_t sourceID() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_source.provider()-&gt;asID(); }

        <span class="enscript-type">void</span> setFeatures(CodeFeatures features) { m_features = features; }
        CodeFeatures features() { <span class="enscript-keyword">return</span> m_features; }

        bool usesEval() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_features &amp; EvalFeature; }
        bool usesArguments() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> (m_features &amp; ArgumentsFeature) &amp;&amp; !(m_features &amp; ShadowsArgumentsFeature); }
        bool isStrictMode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_features &amp; StrictModeFeature; }
        <span class="enscript-type">void</span> setUsesArguments() { m_features |= ArgumentsFeature; }
        bool usesThis() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_features &amp; ThisFeature; }
        bool needsActivationForMoreThanVariables() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_features &amp; (EvalFeature | WithFeature | CatchFeature); }
        bool needsActivation() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> (hasCapturedVariables()) || (m_features &amp; (EvalFeature | WithFeature | CatchFeature)); }
        bool hasCapturedVariables() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> !!m_capturedVariables.size(); }
        size_t capturedVariableCount() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_capturedVariables.size(); }
        bool captures(<span class="enscript-type">const</span> Identifier&amp; ident) { <span class="enscript-keyword">return</span> m_capturedVariables.contains(ident.impl()); }

        VarStack&amp; varStack() { <span class="enscript-keyword">return</span> m_varStack; }
        FunctionStack&amp; functionStack() { <span class="enscript-keyword">return</span> m_functionStack; }

        <span class="enscript-type">int</span> neededConstants()
        {
            <span class="enscript-comment">// We may need 2 more constants than the count given by the parser,
</span>            <span class="enscript-comment">// because of the various uses of jsUndefined() and jsNull().
</span>            <span class="enscript-keyword">return</span> m_numConstants + 2;
        }

        StatementNode* singleStatement() <span class="enscript-type">const</span>;

        <span class="enscript-type">void</span> emitStatementsBytecode(BytecodeGenerator&amp;, RegisterID* destination);

    <span class="enscript-reference">protected</span>:
        <span class="enscript-type">void</span> setSource(<span class="enscript-type">const</span> SourceCode&amp; source) { m_source = source; }
        ParserArena m_arena;

    <span class="enscript-reference">private</span>:
        CodeFeatures m_features;
        SourceCode m_source;
        VarStack m_varStack;
        FunctionStack m_functionStack;
        <span class="enscript-type">int</span> m_numConstants;
        SourceElements* m_statements;
        IdentifierSet m_capturedVariables;
    };

    class ProgramNode : public ScopeNode {
    <span class="enscript-reference">public</span>:
        <span class="enscript-type">static</span> <span class="enscript-type">const</span> bool isFunctionNode = false;
        <span class="enscript-type">static</span> PassRefPtr&lt;ProgramNode&gt; create(JSGlobalData*, <span class="enscript-type">int</span>, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&amp;, <span class="enscript-type">const</span> SourceCode&amp;, CodeFeatures, <span class="enscript-type">int</span> numConstants);

        <span class="enscript-type">static</span> <span class="enscript-type">const</span> bool scopeIsFunction = false;

    <span class="enscript-reference">private</span>:
        ProgramNode(JSGlobalData*, <span class="enscript-type">int</span>, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&amp;, <span class="enscript-type">const</span> SourceCode&amp;, CodeFeatures, <span class="enscript-type">int</span> numConstants);

        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };

    class EvalNode : public ScopeNode {
    <span class="enscript-reference">public</span>:
        <span class="enscript-type">static</span> <span class="enscript-type">const</span> bool isFunctionNode = false;
        <span class="enscript-type">static</span> PassRefPtr&lt;EvalNode&gt; create(JSGlobalData*, <span class="enscript-type">int</span>, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&amp;, <span class="enscript-type">const</span> SourceCode&amp;, CodeFeatures, <span class="enscript-type">int</span> numConstants);

        <span class="enscript-type">static</span> <span class="enscript-type">const</span> bool scopeIsFunction = false;

    <span class="enscript-reference">private</span>:
        EvalNode(JSGlobalData*, <span class="enscript-type">int</span>, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&amp;, <span class="enscript-type">const</span> SourceCode&amp;, CodeFeatures, <span class="enscript-type">int</span> numConstants);

        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);
    };

    class FunctionParameters : public Vector&lt;Identifier&gt;, public RefCounted&lt;FunctionParameters&gt; {
        WTF_MAKE_FAST_ALLOCATED;
    <span class="enscript-reference">public</span>:
        <span class="enscript-type">static</span> PassRefPtr&lt;FunctionParameters&gt; create(ParameterNode* firstParameter) { <span class="enscript-keyword">return</span> adoptRef(new FunctionParameters(firstParameter)); }

    <span class="enscript-reference">private</span>:
        FunctionParameters(ParameterNode*);
    };

    class FunctionBodyNode : public ScopeNode {
    <span class="enscript-reference">public</span>:
        <span class="enscript-type">static</span> <span class="enscript-type">const</span> bool isFunctionNode = true;
        <span class="enscript-type">static</span> FunctionBodyNode* create(JSGlobalData*, <span class="enscript-type">int</span>, bool isStrictMode);
        <span class="enscript-type">static</span> PassRefPtr&lt;FunctionBodyNode&gt; create(JSGlobalData*, <span class="enscript-type">int</span>, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&amp;, <span class="enscript-type">const</span> SourceCode&amp;, CodeFeatures, <span class="enscript-type">int</span> numConstants);

        FunctionParameters* parameters() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_parameters.get(); }
        size_t parameterCount() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_parameters-&gt;size(); }

        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        <span class="enscript-type">void</span> finishParsing(<span class="enscript-type">const</span> SourceCode&amp;, ParameterNode*, <span class="enscript-type">const</span> Identifier&amp;);
        <span class="enscript-type">void</span> finishParsing(PassRefPtr&lt;FunctionParameters&gt;, <span class="enscript-type">const</span> Identifier&amp;);
        
        <span class="enscript-type">const</span> Identifier&amp; ident() { <span class="enscript-keyword">return</span> m_ident; }
        <span class="enscript-type">void</span> setInferredName(<span class="enscript-type">const</span> Identifier&amp; inferredName) { ASSERT(!inferredName.isNull()); m_inferredName = inferredName; }
        <span class="enscript-type">const</span> Identifier&amp; inferredName() { <span class="enscript-keyword">return</span> m_inferredName.isEmpty() ? m_ident : m_inferredName; }

        <span class="enscript-type">static</span> <span class="enscript-type">const</span> bool scopeIsFunction = true;

    <span class="enscript-reference">private</span>:
        FunctionBodyNode(JSGlobalData*, <span class="enscript-type">int</span>, bool inStrictContext);
        FunctionBodyNode(JSGlobalData*, <span class="enscript-type">int</span>, SourceElements*, VarStack*, FunctionStack*, IdentifierSet&amp;, <span class="enscript-type">const</span> SourceCode&amp;, CodeFeatures, <span class="enscript-type">int</span> numConstants);

        Identifier m_ident;
        Identifier m_inferredName;
        RefPtr&lt;FunctionParameters&gt; m_parameters;
    };

    class FuncExprNode : public ExpressionNode {
    <span class="enscript-reference">public</span>:
        FuncExprNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, FunctionBodyNode*, <span class="enscript-type">const</span> SourceCode&amp;, ParameterNode* = 0);

        FunctionBodyNode* body() { <span class="enscript-keyword">return</span> m_body; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        virtual bool isFuncExprNode() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> true; } 

        FunctionBodyNode* m_body;
    };

    class FuncDeclNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        FuncDeclNode(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> Identifier&amp;, FunctionBodyNode*, <span class="enscript-type">const</span> SourceCode&amp;, ParameterNode* = 0);

        FunctionBodyNode* body() { <span class="enscript-keyword">return</span> m_body; }

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        FunctionBodyNode* m_body;
    };

    class CaseClauseNode : public ParserArenaFreeable {
    <span class="enscript-reference">public</span>:
        CaseClauseNode(ExpressionNode*, SourceElements* = 0);

        ExpressionNode* expr() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_expr; }

        <span class="enscript-type">void</span> emitBytecode(BytecodeGenerator&amp;, RegisterID* destination);

    <span class="enscript-reference">private</span>:
        ExpressionNode* m_expr;
        SourceElements* m_statements;
    };

    class ClauseListNode : public ParserArenaFreeable {
    <span class="enscript-reference">public</span>:
        ClauseListNode(CaseClauseNode*);
        ClauseListNode(ClauseListNode*, CaseClauseNode*);

        CaseClauseNode* getClause() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_clause; }
        ClauseListNode* getNext() <span class="enscript-type">const</span> { <span class="enscript-keyword">return</span> m_next; }

    <span class="enscript-reference">private</span>:
        CaseClauseNode* m_clause;
        ClauseListNode* m_next;
    };

    class CaseBlockNode : public ParserArenaFreeable {
    <span class="enscript-reference">public</span>:
        CaseBlockNode(ClauseListNode* list1, CaseClauseNode* defaultClause, ClauseListNode* list2);

        RegisterID* emitBytecodeForBlock(BytecodeGenerator&amp;, RegisterID* input, RegisterID* destination);

    <span class="enscript-reference">private</span>:
        <span class="enscript-reference">SwitchInfo</span>::SwitchType tryOptimizedSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num);
        ClauseListNode* m_list1;
        CaseClauseNode* m_defaultClause;
        ClauseListNode* m_list2;
    };

    class SwitchNode : public StatementNode {
    <span class="enscript-reference">public</span>:
        SwitchNode(<span class="enscript-type">int</span>, ExpressionNode*, CaseBlockNode*);

    <span class="enscript-reference">private</span>:
        virtual RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0);

        ExpressionNode* m_expr;
        CaseBlockNode* m_block;
    };

    <span class="enscript-type">struct</span> ElementList {
        ElementNode* head;
        ElementNode* tail;
    };

    <span class="enscript-type">struct</span> PropertyList {
        PropertyListNode* head;
        PropertyListNode* tail;
    };

    <span class="enscript-type">struct</span> ArgumentList {
        ArgumentListNode* head;
        ArgumentListNode* tail;
    };

    <span class="enscript-type">struct</span> ConstDeclList {
        ConstDeclNode* head;
        ConstDeclNode* tail;
    };

    <span class="enscript-type">struct</span> ParameterList {
        ParameterNode* head;
        ParameterNode* tail;
    };

    <span class="enscript-type">struct</span> ClauseList {
        ClauseListNode* head;
        ClauseListNode* tail;
    };

} <span class="enscript-comment">// namespace JSC
</span>
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">Nodes_h</span>
</pre>
<hr />
</body></html>