<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Parser.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">Parser.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 *  Copyright (C) 1999-2001 Harri Porten (<a href="mailto:porten@kde.org">porten@kde.org</a>)
 *  Copyright (C) 2001 Peter Kelly (<a href="mailto:pmk@post.com">pmk@post.com</a>)
 *  Copyright (C) 2003, 2006, 2007, 2008, 2009, 2010 Apple Inc. All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public License
 *  along with this library; see the file COPYING.LIB.  If not, write to
 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA 02110-1301, USA.
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;config.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Parser.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ASTBuilder.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;CodeBlock.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Debugger.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;JSGlobalData.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Lexer.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;NodeInfo.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;SourceProvider.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;utility&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/HashFunctions.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/OwnPtr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;wtf/WTFThreadData.h&gt;</span>

using namespace std;

namespace JSC {

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
Parser&lt;LexerType&gt;::Parser(JSGlobalData* globalData, <span class="enscript-type">const</span> SourceCode&amp; source, FunctionParameters* parameters, JSParserStrictness strictness, JSParserMode parserMode)
    : m_globalData(globalData)
    , m_source(&amp;source)
    , m_stack(wtfThreadData().stack())
    , m_error(false)
    , m_errorMessage(<span class="enscript-string">&quot;Parse error&quot;</span>)
    , m_allowsIn(true)
    , m_lastLine(0)
    , m_lastTokenEnd(0)
    , m_assignmentCount(0)
    , m_nonLHSCount(0)
    , m_syntaxAlreadyValidated(source.provider()-&gt;isValid())
    , m_statementDepth(0)
    , m_nonTrivialExpressionCount(0)
    , m_lastIdentifier(0)
    , m_sourceElements(0)
{
    m_lexer = adoptPtr(<span class="enscript-keyword">new</span> LexerType(globalData));
    m_arena = m_globalData-&gt;parserArena.get();
    m_lexer-&gt;setCode(source, m_arena);

    m_functionCache = source.provider()-&gt;cache();
    ScopeRef scope = pushScope();
    <span class="enscript-keyword">if</span> (parserMode == JSParseFunctionCode)
        scope-&gt;setIsFunction();
    <span class="enscript-keyword">if</span> (strictness == JSParseStrict)
        scope-&gt;setStrictMode();
    <span class="enscript-keyword">if</span> (parameters) {
        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> i = 0; i &lt; parameters-&gt;size(); i++)
            scope-&gt;declareParameter(&amp;parameters-&gt;at(i));
    }
    next();
    m_lexer-&gt;setLastLineNumber(tokenLine());
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
Parser&lt;LexerType&gt;::~Parser()
{
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
UString Parser&lt;LexerType&gt;::parseInner()
{
    UString parseError = UString();
    
    <span class="enscript-type">unsigned</span> oldFunctionCacheSize = m_functionCache ? m_functionCache-&gt;byteSize() : 0;
    ASTBuilder context(const_cast&lt;JSGlobalData*&gt;(m_globalData), const_cast&lt;SourceCode*&gt;(m_source));
    <span class="enscript-keyword">if</span> (m_lexer-&gt;isReparsing())
        m_statementDepth--;
    ScopeRef scope = currentScope();
    SourceElements* sourceElements = parseSourceElements&lt;CheckForStrictMode&gt;(context);
    <span class="enscript-keyword">if</span> (!sourceElements || !consume(EOFTOK))
        parseError = m_errorMessage;

    IdentifierSet capturedVariables;
    scope-&gt;getCapturedVariables(capturedVariables);
    CodeFeatures features = context.features();
    <span class="enscript-keyword">if</span> (scope-&gt;strictMode())
        features |= StrictModeFeature;
    <span class="enscript-keyword">if</span> (scope-&gt;shadowsArguments())
        features |= ShadowsArgumentsFeature;
    <span class="enscript-type">unsigned</span> functionCacheSize = m_functionCache ? m_functionCache-&gt;byteSize() : 0;
    <span class="enscript-keyword">if</span> (functionCacheSize != oldFunctionCacheSize)
        m_lexer-&gt;sourceProvider()-&gt;notifyCacheSizeChanged(functionCacheSize - oldFunctionCacheSize);

    didFinishParsing(sourceElements, context.varDeclarations(), context.funcDeclarations(), features,
                     m_lastLine, context.numConstants(), capturedVariables);

    <span class="enscript-keyword">return</span> parseError;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">void</span> Parser&lt;LexerType&gt;::didFinishParsing(SourceElements* sourceElements, ParserArenaData&lt;DeclarationStacks::VarStack&gt;* varStack, 
                              ParserArenaData&lt;DeclarationStacks::FunctionStack&gt;* funcStack, CodeFeatures features, <span class="enscript-type">int</span> lastLine, <span class="enscript-type">int</span> numConstants, IdentifierSet&amp; capturedVars)
{
    m_sourceElements = sourceElements;
    m_varDeclarations = varStack;
    m_funcDeclarations = funcStack;
    m_capturedVariables.swap(capturedVars);
    m_features = features;
    m_lastLine = lastLine;
    m_numConstants = numConstants;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">bool</span> Parser&lt;LexerType&gt;::allowAutomaticSemicolon()
{
    <span class="enscript-keyword">return</span> match(CLOSEBRACE) || match(EOFTOK) || m_lexer-&gt;prevTerminator();
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;SourceElementsMode mode, <span class="enscript-type">class</span> TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSourceElements(TreeBuilder&amp; context)
{
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> lengthOfUseStrictLiteral = 12; <span class="enscript-comment">// &quot;use strict&quot;.length
</span>    TreeSourceElements sourceElements = context.createSourceElements();
    <span class="enscript-type">bool</span> seenNonDirective = false;
    <span class="enscript-type">const</span> Identifier* directive = 0;
    <span class="enscript-type">unsigned</span> directiveLiteralLength = 0;
    <span class="enscript-type">unsigned</span> startOffset = m_token.m_info.startOffset;
    <span class="enscript-type">unsigned</span> oldLastLineNumber = m_lexer-&gt;lastLineNumber();
    <span class="enscript-type">unsigned</span> oldLineNumber = m_lexer-&gt;lineNumber();
    <span class="enscript-type">bool</span> hasSetStrict = false;
    <span class="enscript-keyword">while</span> (TreeStatement statement = parseStatement(context, directive, &amp;directiveLiteralLength)) {
        <span class="enscript-keyword">if</span> (mode == CheckForStrictMode &amp;&amp; !seenNonDirective) {
            <span class="enscript-keyword">if</span> (directive) {
                <span class="enscript-comment">// &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
</span>                <span class="enscript-keyword">if</span> (!hasSetStrict &amp;&amp; directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_globalData-&gt;propertyNames-&gt;useStrictIdentifier == *directive) {
                    setStrictMode();
                    hasSetStrict = true;
                    failIfFalse(isValidStrictMode());
                    m_lexer-&gt;setOffset(startOffset);
                    next();
                    m_lexer-&gt;setLastLineNumber(oldLastLineNumber);
                    m_lexer-&gt;setLineNumber(oldLineNumber);
                    failIfTrue(m_error);
                    <span class="enscript-keyword">continue</span>;
                }
            } <span class="enscript-keyword">else</span>
                seenNonDirective = true;
        }
        context.appendStatement(sourceElements, statement);
    }
    
    <span class="enscript-keyword">if</span> (m_error)
        fail();
    <span class="enscript-keyword">return</span> sourceElements;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseVarDeclaration(TreeBuilder&amp; context)
{
    ASSERT(match(VAR));
    <span class="enscript-type">int</span> start = tokenLine();
    <span class="enscript-type">int</span> end = 0;
    <span class="enscript-type">int</span> scratch;
    <span class="enscript-type">const</span> Identifier* scratch1 = 0;
    TreeExpression scratch2 = 0;
    <span class="enscript-type">int</span> scratch3 = 0;
    TreeExpression varDecls = parseVarDeclarationList(context, scratch, scratch1, scratch2, scratch3, scratch3, scratch3);
    failIfTrue(m_error);
    failIfFalse(autoSemiColon());
    
    <span class="enscript-keyword">return</span> context.createVarStatement(m_lexer-&gt;lastLineNumber(), varDecls, start, end);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseConstDeclaration(TreeBuilder&amp; context)
{
    ASSERT(match(CONSTTOKEN));
    <span class="enscript-type">int</span> start = tokenLine();
    <span class="enscript-type">int</span> end = 0;
    TreeConstDeclList constDecls = parseConstDeclarationList(context);
    failIfTrue(m_error);
    failIfFalse(autoSemiColon());
    
    <span class="enscript-keyword">return</span> context.createConstStatement(m_lexer-&gt;lastLineNumber(), constDecls, start, end);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseDoWhileStatement(TreeBuilder&amp; context)
{
    ASSERT(match(DO));
    <span class="enscript-type">int</span> startLine = tokenLine();
    next();
    <span class="enscript-type">const</span> Identifier* unused = 0;
    startLoop();
    TreeStatement statement = parseStatement(context, unused);
    endLoop();
    failIfFalse(statement);
    <span class="enscript-type">int</span> endLine = tokenLine();
    consumeOrFail(WHILE);
    consumeOrFail(OPENPAREN);
    TreeExpression expr = parseExpression(context);
    failIfFalse(expr);
    consumeOrFail(CLOSEPAREN);
    <span class="enscript-keyword">if</span> (match(SEMICOLON))
        next(); <span class="enscript-comment">// Always performs automatic semicolon insertion.
</span>    <span class="enscript-keyword">return</span> context.createDoWhileStatement(m_lexer-&gt;lastLineNumber(), statement, expr, startLine, endLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseWhileStatement(TreeBuilder&amp; context)
{
    ASSERT(match(WHILE));
    <span class="enscript-type">int</span> startLine = tokenLine();
    next();
    consumeOrFail(OPENPAREN);
    TreeExpression expr = parseExpression(context);
    failIfFalse(expr);
    <span class="enscript-type">int</span> endLine = tokenLine();
    consumeOrFail(CLOSEPAREN);
    <span class="enscript-type">const</span> Identifier* unused = 0;
    startLoop();
    TreeStatement statement = parseStatement(context, unused);
    endLoop();
    failIfFalse(statement);
    <span class="enscript-keyword">return</span> context.createWhileStatement(m_lexer-&gt;lastLineNumber(), expr, statement, startLine, endLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseVarDeclarationList(TreeBuilder&amp; context, <span class="enscript-type">int</span>&amp; declarations, <span class="enscript-type">const</span> Identifier*&amp; lastIdent, TreeExpression&amp; lastInitializer, <span class="enscript-type">int</span>&amp; identStart, <span class="enscript-type">int</span>&amp; initStart, <span class="enscript-type">int</span>&amp; initEnd)
{
    TreeExpression varDecls = 0;
    <span class="enscript-keyword">do</span> {
        declarations++;
        next();
        matchOrFail(IDENT);
        
        <span class="enscript-type">int</span> varStart = tokenStart();
        identStart = varStart;
        <span class="enscript-type">const</span> Identifier* name = m_token.m_data.ident;
        lastIdent = name;
        next();
        <span class="enscript-type">bool</span> hasInitializer = match(EQUAL);
        failIfFalseIfStrictWithNameAndMessage(declareVariable(name), <span class="enscript-string">&quot;Cannot declare a variable named&quot;</span>, name-&gt;impl(), <span class="enscript-string">&quot;in strict mode.&quot;</span>);
        context.addVar(name, (hasInitializer || (!m_allowsIn &amp;&amp; match(INTOKEN))) ? DeclarationStacks::HasInitializer : 0);
        <span class="enscript-keyword">if</span> (hasInitializer) {
            <span class="enscript-type">int</span> varDivot = tokenStart() + 1;
            initStart = tokenStart();
            next(TreeBuilder::DontBuildStrings); <span class="enscript-comment">// consume '='
</span>            <span class="enscript-type">int</span> initialAssignments = m_assignmentCount;
            TreeExpression initializer = parseAssignmentExpression(context);
            initEnd = lastTokenEnd();
            lastInitializer = initializer;
            failIfFalse(initializer);
            
            TreeExpression node = context.createAssignResolve(m_lexer-&gt;lastLineNumber(), *name, initializer, initialAssignments != m_assignmentCount, varStart, varDivot, lastTokenEnd());
            <span class="enscript-keyword">if</span> (!varDecls)
                varDecls = node;
            <span class="enscript-keyword">else</span>
                varDecls = context.combineCommaNodes(m_lexer-&gt;lastLineNumber(), varDecls, node);
        }
    } <span class="enscript-keyword">while</span> (match(COMMA));
    <span class="enscript-keyword">return</span> varDecls;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeConstDeclList Parser&lt;LexerType&gt;::parseConstDeclarationList(TreeBuilder&amp; context)
{
    failIfTrue(strictMode());
    TreeConstDeclList constDecls = 0;
    TreeConstDeclList tail = 0;
    <span class="enscript-keyword">do</span> {
        next();
        matchOrFail(IDENT);
        <span class="enscript-type">const</span> Identifier* name = m_token.m_data.ident;
        next();
        <span class="enscript-type">bool</span> hasInitializer = match(EQUAL);
        declareVariable(name);
        context.addVar(name, DeclarationStacks::IsConstant | (hasInitializer ? DeclarationStacks::HasInitializer : 0));
        TreeExpression initializer = 0;
        <span class="enscript-keyword">if</span> (hasInitializer) {
            next(TreeBuilder::DontBuildStrings); <span class="enscript-comment">// consume '='
</span>            initializer = parseAssignmentExpression(context);
        }
        tail = context.appendConstDecl(m_lexer-&gt;lastLineNumber(), tail, name, initializer);
        <span class="enscript-keyword">if</span> (!constDecls)
            constDecls = tail;
    } <span class="enscript-keyword">while</span> (match(COMMA));
    <span class="enscript-keyword">return</span> constDecls;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseForStatement(TreeBuilder&amp; context)
{
    ASSERT(match(FOR));
    <span class="enscript-type">int</span> startLine = tokenLine();
    next();
    consumeOrFail(OPENPAREN);
    <span class="enscript-type">int</span> nonLHSCount = m_nonLHSCount;
    <span class="enscript-type">int</span> declarations = 0;
    <span class="enscript-type">int</span> declsStart = 0;
    <span class="enscript-type">int</span> declsEnd = 0;
    TreeExpression decls = 0;
    <span class="enscript-type">bool</span> hasDeclaration = false;
    <span class="enscript-keyword">if</span> (match(VAR)) {
        <span class="enscript-comment">/*
         for (var IDENT in expression) statement
         for (var IDENT = expression in expression) statement
         for (var varDeclarationList; expressionOpt; expressionOpt)
         */</span>
        hasDeclaration = true;
        <span class="enscript-type">const</span> Identifier* forInTarget = 0;
        TreeExpression forInInitializer = 0;
        m_allowsIn = false;
        <span class="enscript-type">int</span> initStart = 0;
        <span class="enscript-type">int</span> initEnd = 0;
        decls = parseVarDeclarationList(context, declarations, forInTarget, forInInitializer, declsStart, initStart, initEnd);
        m_allowsIn = true;
        <span class="enscript-keyword">if</span> (m_error)
            fail();
        
        <span class="enscript-comment">// Remainder of a standard for loop is handled identically
</span>        <span class="enscript-keyword">if</span> (match(SEMICOLON))
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">standardForLoop</span>;
        
        failIfFalse(declarations == 1);
        
        <span class="enscript-comment">// Handle for-in with var declaration
</span>        <span class="enscript-type">int</span> inLocation = tokenStart();
        consumeOrFail(INTOKEN);
        
        TreeExpression expr = parseExpression(context);
        failIfFalse(expr);
        <span class="enscript-type">int</span> exprEnd = lastTokenEnd();
        
        <span class="enscript-type">int</span> endLine = tokenLine();
        consumeOrFail(CLOSEPAREN);
        
        <span class="enscript-type">const</span> Identifier* unused = 0;
        startLoop();
        TreeStatement statement = parseStatement(context, unused);
        endLoop();
        failIfFalse(statement);
        
        <span class="enscript-keyword">return</span> context.createForInLoop(m_lexer-&gt;lastLineNumber(), forInTarget, forInInitializer, expr, statement, declsStart, inLocation, exprEnd, initStart, initEnd, startLine, endLine);
    }
    
    <span class="enscript-keyword">if</span> (!match(SEMICOLON)) {
        m_allowsIn = false;
        declsStart = tokenStart();
        decls = parseExpression(context);
        declsEnd = lastTokenEnd();
        m_allowsIn = true;
        failIfFalse(decls);
    }
    
    <span class="enscript-keyword">if</span> (match(SEMICOLON)) {
    <span class="enscript-reference">standardForLoop</span>:
        <span class="enscript-comment">// Standard for loop
</span>        next();
        TreeExpression condition = 0;
        
        <span class="enscript-keyword">if</span> (!match(SEMICOLON)) {
            condition = parseExpression(context);
            failIfFalse(condition);
        }
        consumeOrFail(SEMICOLON);
        
        TreeExpression increment = 0;
        <span class="enscript-keyword">if</span> (!match(CLOSEPAREN)) {
            increment = parseExpression(context);
            failIfFalse(increment);
        }
        <span class="enscript-type">int</span> endLine = tokenLine();
        consumeOrFail(CLOSEPAREN);
        <span class="enscript-type">const</span> Identifier* unused = 0;
        startLoop();
        TreeStatement statement = parseStatement(context, unused);
        endLoop();
        failIfFalse(statement);
        <span class="enscript-keyword">return</span> context.createForLoop(m_lexer-&gt;lastLineNumber(), decls, condition, increment, statement, hasDeclaration, startLine, endLine);
    }
    
    <span class="enscript-comment">// For-in loop
</span>    failIfFalse(nonLHSCount == m_nonLHSCount);
    consumeOrFail(INTOKEN);
    TreeExpression expr = parseExpression(context);
    failIfFalse(expr);
    <span class="enscript-type">int</span> exprEnd = lastTokenEnd();
    <span class="enscript-type">int</span> endLine = tokenLine();
    consumeOrFail(CLOSEPAREN);
    <span class="enscript-type">const</span> Identifier* unused = 0;
    startLoop();
    TreeStatement statement = parseStatement(context, unused);
    endLoop();
    failIfFalse(statement);
    
    <span class="enscript-keyword">return</span> context.createForInLoop(m_lexer-&gt;lastLineNumber(), decls, expr, statement, declsStart, declsEnd, exprEnd, startLine, endLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBreakStatement(TreeBuilder&amp; context)
{
    ASSERT(match(BREAK));
    <span class="enscript-type">int</span> startCol = tokenStart();
    <span class="enscript-type">int</span> endCol = tokenEnd();
    <span class="enscript-type">int</span> startLine = tokenLine();
    <span class="enscript-type">int</span> endLine = tokenLine();
    next();
    
    <span class="enscript-keyword">if</span> (autoSemiColon()) {
        failIfFalseWithMessage(breakIsValid(), <span class="enscript-string">&quot;'break' is only valid inside a switch or loop statement&quot;</span>);
        <span class="enscript-keyword">return</span> context.createBreakStatement(m_lexer-&gt;lastLineNumber(), startCol, endCol, startLine, endLine);
    }
    matchOrFail(IDENT);
    <span class="enscript-type">const</span> Identifier* ident = m_token.m_data.ident;
    failIfFalseWithNameAndMessage(getLabel(ident), <span class="enscript-string">&quot;Label&quot;</span>, ident-&gt;impl(), <span class="enscript-string">&quot;is not defined&quot;</span>);
    endCol = tokenEnd();
    endLine = tokenLine();
    next();
    failIfFalse(autoSemiColon());
    <span class="enscript-keyword">return</span> context.createBreakStatement(m_lexer-&gt;lastLineNumber(), ident, startCol, endCol, startLine, endLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseContinueStatement(TreeBuilder&amp; context)
{
    ASSERT(match(CONTINUE));
    <span class="enscript-type">int</span> startCol = tokenStart();
    <span class="enscript-type">int</span> endCol = tokenEnd();
    <span class="enscript-type">int</span> startLine = tokenLine();
    <span class="enscript-type">int</span> endLine = tokenLine();
    next();
    
    <span class="enscript-keyword">if</span> (autoSemiColon()) {
        failIfFalseWithMessage(continueIsValid(), <span class="enscript-string">&quot;'continue' is only valid inside a loop statement&quot;</span>);
        <span class="enscript-keyword">return</span> context.createContinueStatement(m_lexer-&gt;lastLineNumber(), startCol, endCol, startLine, endLine);
    }
    matchOrFail(IDENT);
    <span class="enscript-type">const</span> Identifier* ident = m_token.m_data.ident;
    ScopeLabelInfo* label = getLabel(ident);
    failIfFalseWithNameAndMessage(label, <span class="enscript-string">&quot;Label&quot;</span>, ident-&gt;impl(), <span class="enscript-string">&quot;is not defined&quot;</span>);
    failIfFalseWithMessage(label-&gt;m_isLoop, <span class="enscript-string">&quot;'continue' is only valid inside a loop statement&quot;</span>);
    endCol = tokenEnd();
    endLine = tokenLine();
    next();
    failIfFalse(autoSemiColon());
    <span class="enscript-keyword">return</span> context.createContinueStatement(m_lexer-&gt;lastLineNumber(), ident, startCol, endCol, startLine, endLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseReturnStatement(TreeBuilder&amp; context)
{
    ASSERT(match(RETURN));
    failIfFalse(currentScope()-&gt;isFunction());
    <span class="enscript-type">int</span> startLine = tokenLine();
    <span class="enscript-type">int</span> endLine = startLine;
    <span class="enscript-type">int</span> start = tokenStart();
    <span class="enscript-type">int</span> end = tokenEnd();
    next();
    <span class="enscript-comment">// We do the auto semicolon check before attempting to parse an expression
</span>    <span class="enscript-comment">// as we need to ensure the a line break after the return correctly terminates
</span>    <span class="enscript-comment">// the statement
</span>    <span class="enscript-keyword">if</span> (match(SEMICOLON))
        endLine  = tokenLine();
    <span class="enscript-keyword">if</span> (autoSemiColon())
        <span class="enscript-keyword">return</span> context.createReturnStatement(m_lexer-&gt;lastLineNumber(), 0, start, end, startLine, endLine);
    TreeExpression expr = parseExpression(context);
    failIfFalse(expr);
    end = lastTokenEnd();
    <span class="enscript-keyword">if</span> (match(SEMICOLON))
        endLine  = tokenLine();
    failIfFalse(autoSemiColon());
    <span class="enscript-keyword">return</span> context.createReturnStatement(m_lexer-&gt;lastLineNumber(), expr, start, end, startLine, endLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseThrowStatement(TreeBuilder&amp; context)
{
    ASSERT(match(THROW));
    <span class="enscript-type">int</span> eStart = tokenStart();
    <span class="enscript-type">int</span> startLine = tokenLine();
    next();
    
    failIfTrue(autoSemiColon());
    
    TreeExpression expr = parseExpression(context);
    failIfFalse(expr);
    <span class="enscript-type">int</span> eEnd = lastTokenEnd();
    <span class="enscript-type">int</span> endLine = tokenLine();
    failIfFalse(autoSemiColon());
    
    <span class="enscript-keyword">return</span> context.createThrowStatement(m_lexer-&gt;lastLineNumber(), expr, eStart, eEnd, startLine, endLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseWithStatement(TreeBuilder&amp; context)
{
    ASSERT(match(WITH));
    failIfTrueWithMessage(strictMode(), <span class="enscript-string">&quot;'with' statements are not valid in strict mode&quot;</span>);
    currentScope()-&gt;setNeedsFullActivation();
    <span class="enscript-type">int</span> startLine = tokenLine();
    next();
    consumeOrFail(OPENPAREN);
    <span class="enscript-type">int</span> start = tokenStart();
    TreeExpression expr = parseExpression(context);
    failIfFalse(expr);
    <span class="enscript-type">int</span> end = lastTokenEnd();
    
    <span class="enscript-type">int</span> endLine = tokenLine();
    consumeOrFail(CLOSEPAREN);
    <span class="enscript-type">const</span> Identifier* unused = 0;
    TreeStatement statement = parseStatement(context, unused);
    failIfFalse(statement);
    
    <span class="enscript-keyword">return</span> context.createWithStatement(m_lexer-&gt;lastLineNumber(), expr, statement, start, end, startLine, endLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseSwitchStatement(TreeBuilder&amp; context)
{
    ASSERT(match(SWITCH));
    <span class="enscript-type">int</span> startLine = tokenLine();
    next();
    consumeOrFail(OPENPAREN);
    TreeExpression expr = parseExpression(context);
    failIfFalse(expr);
    <span class="enscript-type">int</span> endLine = tokenLine();
    consumeOrFail(CLOSEPAREN);
    consumeOrFail(OPENBRACE);
    startSwitch();
    TreeClauseList firstClauses = parseSwitchClauses(context);
    failIfTrue(m_error);
    
    TreeClause defaultClause = parseSwitchDefaultClause(context);
    failIfTrue(m_error);
    
    TreeClauseList secondClauses = parseSwitchClauses(context);
    failIfTrue(m_error);
    endSwitch();
    consumeOrFail(CLOSEBRACE);
    
    <span class="enscript-keyword">return</span> context.createSwitchStatement(m_lexer-&gt;lastLineNumber(), expr, firstClauses, defaultClause, secondClauses, startLine, endLine);
    
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeClauseList Parser&lt;LexerType&gt;::parseSwitchClauses(TreeBuilder&amp; context)
{
    <span class="enscript-keyword">if</span> (!match(CASE))
        <span class="enscript-keyword">return</span> 0;
    next();
    TreeExpression condition = parseExpression(context);
    failIfFalse(condition);
    consumeOrFail(COLON);
    TreeSourceElements statements = parseSourceElements&lt;DontCheckForStrictMode&gt;(context);
    failIfFalse(statements);
    TreeClause clause = context.createClause(condition, statements);
    TreeClauseList clauseList = context.createClauseList(clause);
    TreeClauseList tail = clauseList;
    
    <span class="enscript-keyword">while</span> (match(CASE)) {
        next();
        TreeExpression condition = parseExpression(context);
        failIfFalse(condition);
        consumeOrFail(COLON);
        TreeSourceElements statements = parseSourceElements&lt;DontCheckForStrictMode&gt;(context);
        failIfFalse(statements);
        clause = context.createClause(condition, statements);
        tail = context.createClauseList(tail, clause);
    }
    <span class="enscript-keyword">return</span> clauseList;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeClause Parser&lt;LexerType&gt;::parseSwitchDefaultClause(TreeBuilder&amp; context)
{
    <span class="enscript-keyword">if</span> (!match(DEFAULT))
        <span class="enscript-keyword">return</span> 0;
    next();
    consumeOrFail(COLON);
    TreeSourceElements statements = parseSourceElements&lt;DontCheckForStrictMode&gt;(context);
    failIfFalse(statements);
    <span class="enscript-keyword">return</span> context.createClause(0, statements);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseTryStatement(TreeBuilder&amp; context)
{
    ASSERT(match(TRY));
    TreeStatement tryBlock = 0;
    <span class="enscript-type">const</span> Identifier* ident = &amp;m_globalData-&gt;propertyNames-&gt;nullIdentifier;
    TreeStatement catchBlock = 0;
    TreeStatement finallyBlock = 0;
    <span class="enscript-type">int</span> firstLine = tokenLine();
    next();
    matchOrFail(OPENBRACE);
    
    tryBlock = parseBlockStatement(context);
    failIfFalse(tryBlock);
    <span class="enscript-type">int</span> lastLine = m_lastLine;
    
    <span class="enscript-keyword">if</span> (match(CATCH)) {
        currentScope()-&gt;setNeedsFullActivation();
        next();
        consumeOrFail(OPENPAREN);
        matchOrFail(IDENT);
        ident = m_token.m_data.ident;
        next();
        AutoPopScopeRef catchScope(<span class="enscript-keyword">this</span>, pushScope());
        failIfFalseIfStrictWithNameAndMessage(declareVariable(ident), <span class="enscript-string">&quot;Cannot declare a variable named&quot;</span>, ident-&gt;impl(), <span class="enscript-string">&quot;in strict mode&quot;</span>);
        catchScope-&gt;preventNewDecls();
        consumeOrFail(CLOSEPAREN);
        matchOrFail(OPENBRACE);
        catchBlock = parseBlockStatement(context);
        failIfFalseWithMessage(catchBlock, <span class="enscript-string">&quot;'try' must have a catch or finally block&quot;</span>);
        failIfFalse(popScope(catchScope, TreeBuilder::NeedsFreeVariableInfo));
    }
    
    <span class="enscript-keyword">if</span> (match(FINALLY)) {
        next();
        matchOrFail(OPENBRACE);
        finallyBlock = parseBlockStatement(context);
        failIfFalse(finallyBlock);
    }
    failIfFalse(catchBlock || finallyBlock);
    <span class="enscript-keyword">return</span> context.createTryStatement(m_lexer-&gt;lastLineNumber(), tryBlock, ident, catchBlock, finallyBlock, firstLine, lastLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseDebuggerStatement(TreeBuilder&amp; context)
{
    ASSERT(match(DEBUGGER));
    <span class="enscript-type">int</span> startLine = tokenLine();
    <span class="enscript-type">int</span> endLine = startLine;
    next();
    <span class="enscript-keyword">if</span> (match(SEMICOLON))
        startLine = tokenLine();
    failIfFalse(autoSemiColon());
    <span class="enscript-keyword">return</span> context.createDebugger(m_lexer-&gt;lastLineNumber(), startLine, endLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBlockStatement(TreeBuilder&amp; context)
{
    ASSERT(match(OPENBRACE));
    <span class="enscript-type">int</span> start = tokenLine();
    next();
    <span class="enscript-keyword">if</span> (match(CLOSEBRACE)) {
        next();
        <span class="enscript-keyword">return</span> context.createBlockStatement(m_lexer-&gt;lastLineNumber(), 0, start, m_lastLine);
    }
    TreeSourceElements subtree = parseSourceElements&lt;DontCheckForStrictMode&gt;(context);
    failIfFalse(subtree);
    matchOrFail(CLOSEBRACE);
    next();
    <span class="enscript-keyword">return</span> context.createBlockStatement(m_lexer-&gt;lastLineNumber(), subtree, start, m_lastLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatement(TreeBuilder&amp; context, <span class="enscript-type">const</span> Identifier*&amp; directive, <span class="enscript-type">unsigned</span>* directiveLiteralLength)
{
    DepthManager statementDepth(&amp;m_statementDepth);
    m_statementDepth++;
    directive = 0;
    <span class="enscript-type">int</span> nonTrivialExpressionCount = 0;
    failIfStackOverflow();
    <span class="enscript-keyword">switch</span> (m_token.m_type) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">OPENBRACE</span>:
        <span class="enscript-keyword">return</span> parseBlockStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">VAR</span>:
        <span class="enscript-keyword">return</span> parseVarDeclaration(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CONSTTOKEN</span>:
        <span class="enscript-keyword">return</span> parseConstDeclaration(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">FUNCTION</span>:
        failIfFalseIfStrictWithMessage(m_statementDepth == 1, <span class="enscript-string">&quot;Functions cannot be declared in a nested block in strict mode&quot;</span>);
        <span class="enscript-keyword">return</span> parseFunctionDeclaration(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SEMICOLON</span>:
        next();
        <span class="enscript-keyword">return</span> context.createEmptyStatement(m_lexer-&gt;lastLineNumber());
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IF</span>:
        <span class="enscript-keyword">return</span> parseIfStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DO</span>:
        <span class="enscript-keyword">return</span> parseDoWhileStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">WHILE</span>:
        <span class="enscript-keyword">return</span> parseWhileStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">FOR</span>:
        <span class="enscript-keyword">return</span> parseForStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CONTINUE</span>:
        <span class="enscript-keyword">return</span> parseContinueStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">BREAK</span>:
        <span class="enscript-keyword">return</span> parseBreakStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RETURN</span>:
        <span class="enscript-keyword">return</span> parseReturnStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">WITH</span>:
        <span class="enscript-keyword">return</span> parseWithStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SWITCH</span>:
        <span class="enscript-keyword">return</span> parseSwitchStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">THROW</span>:
        <span class="enscript-keyword">return</span> parseThrowStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">TRY</span>:
        <span class="enscript-keyword">return</span> parseTryStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DEBUGGER</span>:
        <span class="enscript-keyword">return</span> parseDebuggerStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">EOFTOK</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CASE</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CLOSEBRACE</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DEFAULT</span>:
        <span class="enscript-comment">// These tokens imply the end of a set of source elements
</span>        <span class="enscript-keyword">return</span> 0;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IDENT</span>:
        <span class="enscript-keyword">return</span> parseExpressionOrLabelStatement(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">STRING</span>:
        directive = m_token.m_data.ident;
        <span class="enscript-keyword">if</span> (directiveLiteralLength)
            *directiveLiteralLength = m_token.m_info.endOffset - m_token.m_info.startOffset;
        nonTrivialExpressionCount = m_nonTrivialExpressionCount;
    <span class="enscript-reference">default</span>:
        TreeStatement exprStatement = parseExpressionStatement(context);
        <span class="enscript-keyword">if</span> (directive &amp;&amp; nonTrivialExpressionCount != m_nonTrivialExpressionCount)
            directive = 0;
        <span class="enscript-keyword">return</span> exprStatement;
    }
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeFormalParameterList Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context)
{
    matchOrFail(IDENT);
    failIfFalseIfStrictWithNameAndMessage(declareParameter(m_token.m_data.ident), <span class="enscript-string">&quot;Cannot declare a parameter named&quot;</span>, m_token.m_data.ident-&gt;impl(), <span class="enscript-string">&quot; in strict mode&quot;</span>);
    TreeFormalParameterList list = context.createFormalParameterList(*m_token.m_data.ident);
    TreeFormalParameterList tail = list;
    next();
    <span class="enscript-keyword">while</span> (match(COMMA)) {
        next();
        matchOrFail(IDENT);
        <span class="enscript-type">const</span> Identifier* ident = m_token.m_data.ident;
        failIfFalseIfStrictWithNameAndMessage(declareParameter(ident), <span class="enscript-string">&quot;Cannot declare a parameter named&quot;</span>, ident-&gt;impl(), <span class="enscript-string">&quot;in strict mode&quot;</span>);
        next();
        tail = context.createFormalParameterList(tail, *ident);
    }
    <span class="enscript-keyword">return</span> list;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeFunctionBody Parser&lt;LexerType&gt;::parseFunctionBody(TreeBuilder&amp; context)
{
    <span class="enscript-keyword">if</span> (match(CLOSEBRACE))
        <span class="enscript-keyword">return</span> context.createFunctionBody(m_lexer-&gt;lastLineNumber(), strictMode());
    DepthManager statementDepth(&amp;m_statementDepth);
    m_statementDepth = 0;
    typename TreeBuilder::FunctionBodyBuilder bodyBuilder(const_cast&lt;JSGlobalData*&gt;(m_globalData), m_lexer.get());
    failIfFalse(parseSourceElements&lt;CheckForStrictMode&gt;(bodyBuilder));
    <span class="enscript-keyword">return</span> context.createFunctionBody(m_lexer-&gt;lastLineNumber(), strictMode());
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;FunctionRequirements requirements, <span class="enscript-type">bool</span> nameIsInContainingScope, <span class="enscript-type">class</span> TreeBuilder&gt; <span class="enscript-type">bool</span> Parser&lt;LexerType&gt;::parseFunctionInfo(TreeBuilder&amp; context, <span class="enscript-type">const</span> Identifier*&amp; name, TreeFormalParameterList&amp; parameters, TreeFunctionBody&amp; body, <span class="enscript-type">int</span>&amp; openBracePos, <span class="enscript-type">int</span>&amp; closeBracePos, <span class="enscript-type">int</span>&amp; bodyStartLine)
{
    AutoPopScopeRef functionScope(<span class="enscript-keyword">this</span>, pushScope());
    functionScope-&gt;setIsFunction();
    <span class="enscript-keyword">if</span> (match(IDENT)) {
        name = m_token.m_data.ident;
        next();
        <span class="enscript-keyword">if</span> (!nameIsInContainingScope)
            failIfFalseIfStrict(functionScope-&gt;declareVariable(name));
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (requirements == FunctionNeedsName)
        <span class="enscript-keyword">return</span> false;
    consumeOrFail(OPENPAREN);
    <span class="enscript-keyword">if</span> (!match(CLOSEPAREN)) {
        parameters = parseFormalParameters(context);
        failIfFalse(parameters);
    }
    consumeOrFail(CLOSEPAREN);
    matchOrFail(OPENBRACE);
    
    openBracePos = m_token.m_data.intValue;
    bodyStartLine = tokenLine();
    
    <span class="enscript-comment">// If we know about this function already, we can use the cached info and skip the parser to the end of the function.
</span>    <span class="enscript-keyword">if</span> (<span class="enscript-type">const</span> SourceProviderCacheItem* cachedInfo = TreeBuilder::CanUseFunctionCache ? findCachedFunctionInfo(openBracePos) : 0) {
        <span class="enscript-comment">// If we're in a strict context, the cached function info must say it was strict too.
</span>        ASSERT(!strictMode() || cachedInfo-&gt;strictMode);
        body = context.createFunctionBody(m_lexer-&gt;lastLineNumber(), cachedInfo-&gt;strictMode);
        
        functionScope-&gt;restoreFunctionInfo(cachedInfo);
        failIfFalse(popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo));
        
        closeBracePos = cachedInfo-&gt;closeBracePos;
        m_token = cachedInfo-&gt;closeBraceToken();
        m_lexer-&gt;setOffset(m_token.m_info.endOffset);
        m_lexer-&gt;setLineNumber(m_token.m_info.line);
        
        next();
        <span class="enscript-keyword">return</span> true;
    }
    
    next();
    
    body = parseFunctionBody(context);
    failIfFalse(body);
    <span class="enscript-keyword">if</span> (functionScope-&gt;strictMode() &amp;&amp; name) {
        failIfTrueWithNameAndMessage(m_globalData-&gt;propertyNames-&gt;arguments == *name, <span class="enscript-string">&quot;Function name&quot;</span>, name-&gt;impl(), <span class="enscript-string">&quot;is not valid in strict mode&quot;</span>);
        failIfTrueWithNameAndMessage(m_globalData-&gt;propertyNames-&gt;eval == *name, <span class="enscript-string">&quot;Function name&quot;</span>, name-&gt;impl(), <span class="enscript-string">&quot;is not valid in strict mode&quot;</span>);
    }
    closeBracePos = m_token.m_data.intValue;
    
    <span class="enscript-comment">// Cache the tokenizer state and the function scope the first time the function is parsed.
</span>    <span class="enscript-comment">// Any future reparsing can then skip the function.
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> minimumFunctionLengthToCache = 64;
    OwnPtr&lt;SourceProviderCacheItem&gt; newInfo;
    <span class="enscript-type">int</span> functionLength = closeBracePos - openBracePos;
    <span class="enscript-keyword">if</span> (TreeBuilder::CanUseFunctionCache &amp;&amp; m_functionCache &amp;&amp; functionLength &gt; minimumFunctionLengthToCache) {
        newInfo = adoptPtr(<span class="enscript-keyword">new</span> SourceProviderCacheItem(m_token.m_info.line, closeBracePos));
        functionScope-&gt;saveFunctionInfo(newInfo.get());
    }
    
    failIfFalse(popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo));
    matchOrFail(CLOSEBRACE);
    
    <span class="enscript-keyword">if</span> (newInfo) {
        <span class="enscript-type">unsigned</span> approximateByteSize = newInfo-&gt;approximateByteSize();
        m_functionCache-&gt;add(openBracePos, newInfo.release(), approximateByteSize);
    }
    
    next();
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseFunctionDeclaration(TreeBuilder&amp; context)
{
    ASSERT(match(FUNCTION));
    next();
    <span class="enscript-type">const</span> Identifier* name = 0;
    TreeFormalParameterList parameters = 0;
    TreeFunctionBody body = 0;
    <span class="enscript-type">int</span> openBracePos = 0;
    <span class="enscript-type">int</span> closeBracePos = 0;
    <span class="enscript-type">int</span> bodyStartLine = 0;
    failIfFalse((parseFunctionInfo&lt;FunctionNeedsName, true&gt;(context, name, parameters, body, openBracePos, closeBracePos, bodyStartLine)));
    failIfFalse(name);
    failIfFalseIfStrict(declareVariable(name));
    <span class="enscript-keyword">return</span> context.createFuncDeclStatement(m_lexer-&gt;lastLineNumber(), name, body, parameters, openBracePos, closeBracePos, bodyStartLine, m_lastLine);
}

<span class="enscript-type">struct</span> LabelInfo {
    LabelInfo(<span class="enscript-type">const</span> Identifier* ident, <span class="enscript-type">int</span> start, <span class="enscript-type">int</span> end)
    : m_ident(ident)
    , m_start(start)
    , m_end(end)
    {
    }
    
    <span class="enscript-type">const</span> Identifier* m_ident;
    <span class="enscript-type">int</span> m_start;
    <span class="enscript-type">int</span> m_end;
};

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionOrLabelStatement(TreeBuilder&amp; context)
{
    
    <span class="enscript-comment">/* Expression and Label statements are ambiguous at LL(1), so we have a
     * special case that looks for a colon as the next character in the input.
     */</span>
    Vector&lt;LabelInfo&gt; labels;
    
    <span class="enscript-keyword">do</span> {
        <span class="enscript-type">int</span> start = tokenStart();
        <span class="enscript-type">int</span> startLine = tokenLine();
        <span class="enscript-keyword">if</span> (!nextTokenIsColon()) {
            <span class="enscript-comment">// If we hit this path we're making a expression statement, which
</span>            <span class="enscript-comment">// by definition can't make use of continue/break so we can just
</span>            <span class="enscript-comment">// ignore any labels we might have accumulated.
</span>            TreeExpression expression = parseExpression(context);
            failIfFalse(expression);
            failIfFalse(autoSemiColon());
            <span class="enscript-keyword">return</span> context.createExprStatement(m_lexer-&gt;lastLineNumber(), expression, startLine, m_lastLine);
        }
        <span class="enscript-type">const</span> Identifier* ident = m_token.m_data.ident;
        <span class="enscript-type">int</span> end = tokenEnd();
        next();
        consumeOrFail(COLON);
        <span class="enscript-keyword">if</span> (!m_syntaxAlreadyValidated) {
            <span class="enscript-comment">// This is O(N^2) over the current list of consecutive labels, but I
</span>            <span class="enscript-comment">// have never seen more than one label in a row in the real world.
</span>            <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; labels.size(); i++)
                failIfTrue(ident-&gt;impl() == labels[i].m_ident-&gt;impl());
            failIfTrue(getLabel(ident));
            labels.append(LabelInfo(ident, start, end));
        }
    } <span class="enscript-keyword">while</span> (match(IDENT));
    <span class="enscript-type">bool</span> isLoop = false;
    <span class="enscript-keyword">switch</span> (m_token.m_type) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">FOR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">WHILE</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DO</span>:
        isLoop = true;
        <span class="enscript-keyword">break</span>;
        
    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-type">const</span> Identifier* unused = 0;
    <span class="enscript-keyword">if</span> (!m_syntaxAlreadyValidated) {
        <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; labels.size(); i++)
            pushLabel(labels[i].m_ident, isLoop);
    }
    TreeStatement statement = parseStatement(context, unused);
    <span class="enscript-keyword">if</span> (!m_syntaxAlreadyValidated) {
        <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; labels.size(); i++)
            popLabel();
    }
    failIfFalse(statement);
    <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; labels.size(); i++) {
        <span class="enscript-type">const</span> LabelInfo&amp; info = labels[labels.size() - i - 1];
        statement = context.createLabelStatement(m_lexer-&gt;lastLineNumber(), info.m_ident, statement, info.m_start, info.m_end);
    }
    <span class="enscript-keyword">return</span> statement;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionStatement(TreeBuilder&amp; context)
{
    <span class="enscript-type">int</span> startLine = tokenLine();
    TreeExpression expression = parseExpression(context);
    failIfFalse(expression);
    failIfFalse(autoSemiColon());
    <span class="enscript-keyword">return</span> context.createExprStatement(m_lexer-&gt;lastLineNumber(), expression, startLine, m_lastLine);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseIfStatement(TreeBuilder&amp; context)
{
    ASSERT(match(IF));
    
    <span class="enscript-type">int</span> start = tokenLine();
    next();
    
    consumeOrFail(OPENPAREN);
    
    TreeExpression condition = parseExpression(context);
    failIfFalse(condition);
    <span class="enscript-type">int</span> end = tokenLine();
    consumeOrFail(CLOSEPAREN);
    
    <span class="enscript-type">const</span> Identifier* unused = 0;
    TreeStatement trueBlock = parseStatement(context, unused);
    failIfFalse(trueBlock);
    
    <span class="enscript-keyword">if</span> (!match(ELSE))
        <span class="enscript-keyword">return</span> context.createIfStatement(m_lexer-&gt;lastLineNumber(), condition, trueBlock, start, end);
    
    Vector&lt;TreeExpression&gt; exprStack;
    Vector&lt;pair&lt;<span class="enscript-type">int</span>, <span class="enscript-type">int</span>&gt; &gt; posStack;
    Vector&lt;TreeStatement&gt; statementStack;
    <span class="enscript-type">bool</span> trailingElse = false;
    <span class="enscript-keyword">do</span> {
        next();
        <span class="enscript-keyword">if</span> (!match(IF)) {
            <span class="enscript-type">const</span> Identifier* unused = 0;
            TreeStatement block = parseStatement(context, unused);
            failIfFalse(block);
            statementStack.append(block);
            trailingElse = true;
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-type">int</span> innerStart = tokenLine();
        next();
        
        consumeOrFail(OPENPAREN);
        
        TreeExpression innerCondition = parseExpression(context);
        failIfFalse(innerCondition);
        <span class="enscript-type">int</span> innerEnd = tokenLine();
        consumeOrFail(CLOSEPAREN);
        <span class="enscript-type">const</span> Identifier* unused = 0;
        TreeStatement innerTrueBlock = parseStatement(context, unused);
        failIfFalse(innerTrueBlock);     
        exprStack.append(innerCondition);
        posStack.append(make_pair(innerStart, innerEnd));
        statementStack.append(innerTrueBlock);
    } <span class="enscript-keyword">while</span> (match(ELSE));
    
    <span class="enscript-keyword">if</span> (!trailingElse) {
        TreeExpression condition = exprStack.last();
        exprStack.removeLast();
        TreeStatement trueBlock = statementStack.last();
        statementStack.removeLast();
        pair&lt;<span class="enscript-type">int</span>, <span class="enscript-type">int</span>&gt; pos = posStack.last();
        posStack.removeLast();
        statementStack.append(context.createIfStatement(m_lexer-&gt;lastLineNumber(), condition, trueBlock, pos.first, pos.second));
    }
    
    <span class="enscript-keyword">while</span> (!exprStack.isEmpty()) {
        TreeExpression condition = exprStack.last();
        exprStack.removeLast();
        TreeStatement falseBlock = statementStack.last();
        statementStack.removeLast();
        TreeStatement trueBlock = statementStack.last();
        statementStack.removeLast();
        pair&lt;<span class="enscript-type">int</span>, <span class="enscript-type">int</span>&gt; pos = posStack.last();
        posStack.removeLast();
        statementStack.append(context.createIfStatement(m_lexer-&gt;lastLineNumber(), condition, trueBlock, falseBlock, pos.first, pos.second));
    }
    
    <span class="enscript-keyword">return</span> context.createIfStatement(m_lexer-&gt;lastLineNumber(), condition, trueBlock, statementStack.last(), start, end);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseExpression(TreeBuilder&amp; context)
{
    failIfStackOverflow();
    TreeExpression node = parseAssignmentExpression(context);
    failIfFalse(node);
    <span class="enscript-keyword">if</span> (!match(COMMA))
        <span class="enscript-keyword">return</span> node;
    next();
    m_nonTrivialExpressionCount++;
    m_nonLHSCount++;
    TreeExpression right = parseAssignmentExpression(context);
    failIfFalse(right);
    typename TreeBuilder::Comma commaNode = context.createCommaExpr(m_lexer-&gt;lastLineNumber(), node, right);
    <span class="enscript-keyword">while</span> (match(COMMA)) {
        next(TreeBuilder::DontBuildStrings);
        right = parseAssignmentExpression(context);
        failIfFalse(right);
        context.appendToComma(commaNode, right);
    }
    <span class="enscript-keyword">return</span> commaNode;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context)
{
    failIfStackOverflow();
    <span class="enscript-type">int</span> start = tokenStart();
    <span class="enscript-type">int</span> initialAssignmentCount = m_assignmentCount;
    <span class="enscript-type">int</span> initialNonLHSCount = m_nonLHSCount;
    TreeExpression lhs = parseConditionalExpression(context);
    failIfFalse(lhs);
    <span class="enscript-keyword">if</span> (initialNonLHSCount != m_nonLHSCount)
        <span class="enscript-keyword">return</span> lhs;
    
    <span class="enscript-type">int</span> assignmentStack = 0;
    Operator op;
    <span class="enscript-type">bool</span> hadAssignment = false;
    <span class="enscript-keyword">while</span> (true) {
        <span class="enscript-keyword">switch</span> (m_token.m_type) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">EQUAL</span>: op = OpEqual; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">PLUSEQUAL</span>: op = OpPlusEq; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">MINUSEQUAL</span>: op = OpMinusEq; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">MULTEQUAL</span>: op = OpMultEq; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">DIVEQUAL</span>: op = OpDivEq; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LSHIFTEQUAL</span>: op = OpLShift; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">RSHIFTEQUAL</span>: op = OpRShift; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">URSHIFTEQUAL</span>: op = OpURShift; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ANDEQUAL</span>: op = OpAndEq; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">XOREQUAL</span>: op = OpXOrEq; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">OREQUAL</span>: op = OpOrEq; <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">MODEQUAL</span>: op = OpModEq; <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
        }
        m_nonTrivialExpressionCount++;
        hadAssignment = true;
        context.assignmentStackAppend(assignmentStack, lhs, start, tokenStart(), m_assignmentCount, op);
        start = tokenStart();
        m_assignmentCount++;
        next(TreeBuilder::DontBuildStrings);
        <span class="enscript-keyword">if</span> (strictMode() &amp;&amp; m_lastIdentifier &amp;&amp; context.isResolve(lhs)) {
            failIfTrueIfStrictWithMessage(m_globalData-&gt;propertyNames-&gt;eval == *m_lastIdentifier, <span class="enscript-string">&quot;'eval' cannot be modified in strict mode&quot;</span>);
            failIfTrueIfStrictWithMessage(m_globalData-&gt;propertyNames-&gt;arguments == *m_lastIdentifier, <span class="enscript-string">&quot;'arguments' cannot be modified in strict mode&quot;</span>);
            declareWrite(m_lastIdentifier);
            m_lastIdentifier = 0;
        }
        lhs = parseConditionalExpression(context);
        failIfFalse(lhs);
        <span class="enscript-keyword">if</span> (initialNonLHSCount != m_nonLHSCount)
            <span class="enscript-keyword">break</span>;
    }
<span class="enscript-reference">end</span>:
    <span class="enscript-keyword">if</span> (hadAssignment)
        m_nonLHSCount++;
    
    <span class="enscript-keyword">if</span> (!TreeBuilder::CreatesAST)
        <span class="enscript-keyword">return</span> lhs;
    
    <span class="enscript-keyword">while</span> (assignmentStack)
        lhs = context.createAssignment(m_lexer-&gt;lastLineNumber(), assignmentStack, lhs, initialAssignmentCount, m_assignmentCount, lastTokenEnd());
    
    <span class="enscript-keyword">return</span> lhs;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseConditionalExpression(TreeBuilder&amp; context)
{
    TreeExpression cond = parseBinaryExpression(context);
    failIfFalse(cond);
    <span class="enscript-keyword">if</span> (!match(QUESTION))
        <span class="enscript-keyword">return</span> cond;
    m_nonTrivialExpressionCount++;
    m_nonLHSCount++;
    next(TreeBuilder::DontBuildStrings);
    TreeExpression lhs = parseAssignmentExpression(context);
    consumeOrFailWithFlags(COLON, TreeBuilder::DontBuildStrings);
    
    TreeExpression rhs = parseAssignmentExpression(context);
    failIfFalse(rhs);
    <span class="enscript-keyword">return</span> context.createConditionalExpr(m_lexer-&gt;lastLineNumber(), cond, lhs, rhs);
}

ALWAYS_INLINE <span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">isUnaryOp</span>(JSTokenType token)
{
    <span class="enscript-keyword">return</span> token &amp; UnaryOpTokenFlag;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">int</span> Parser&lt;LexerType&gt;::isBinaryOperator(JSTokenType token)
{
    <span class="enscript-keyword">if</span> (m_allowsIn)
        <span class="enscript-keyword">return</span> token &amp; (BinaryOpTokenPrecedenceMask &lt;&lt; BinaryOpTokenAllowsInPrecedenceAdditionalShift);
    <span class="enscript-keyword">return</span> token &amp; BinaryOpTokenPrecedenceMask;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseBinaryExpression(TreeBuilder&amp; context)
{
    
    <span class="enscript-type">int</span> operandStackDepth = 0;
    <span class="enscript-type">int</span> operatorStackDepth = 0;
    typename TreeBuilder::BinaryExprContext binaryExprContext(context);
    <span class="enscript-keyword">while</span> (true) {
        <span class="enscript-type">int</span> exprStart = tokenStart();
        <span class="enscript-type">int</span> initialAssignments = m_assignmentCount;
        TreeExpression current = parseUnaryExpression(context);
        failIfFalse(current);
        
        context.appendBinaryExpressionInfo(operandStackDepth, current, exprStart, lastTokenEnd(), lastTokenEnd(), initialAssignments != m_assignmentCount);
        <span class="enscript-type">int</span> precedence = isBinaryOperator(m_token.m_type);
        <span class="enscript-keyword">if</span> (!precedence)
            <span class="enscript-keyword">break</span>;
        m_nonTrivialExpressionCount++;
        m_nonLHSCount++;
        <span class="enscript-type">int</span> operatorToken = m_token.m_type;
        next(TreeBuilder::DontBuildStrings);
        
        <span class="enscript-keyword">while</span> (operatorStackDepth &amp;&amp;  context.operatorStackHasHigherPrecedence(operatorStackDepth, precedence)) {
            ASSERT(operandStackDepth &gt; 1);
            
            typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
            typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
            context.shrinkOperandStackBy(operandStackDepth, 2);
            context.appendBinaryOperation(m_lexer-&gt;lastLineNumber(), operandStackDepth, operatorStackDepth, lhs, rhs);
            context.operatorStackPop(operatorStackDepth);
        }
        context.operatorStackAppend(operatorStackDepth, operatorToken, precedence);
    }
    <span class="enscript-keyword">while</span> (operatorStackDepth) {
        ASSERT(operandStackDepth &gt; 1);
        
        typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
        typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
        context.shrinkOperandStackBy(operandStackDepth, 2);
        context.appendBinaryOperation(m_lexer-&gt;lastLineNumber(), operandStackDepth, operatorStackDepth, lhs, rhs);
        context.operatorStackPop(operatorStackDepth);
    }
    <span class="enscript-keyword">return</span> context.popOperandStack(operandStackDepth);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">bool</span> complete, <span class="enscript-type">class</span> TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseProperty(TreeBuilder&amp; context)
{
    <span class="enscript-type">bool</span> wasIdent = false;
    <span class="enscript-keyword">switch</span> (m_token.m_type) {
    <span class="enscript-reference">namedProperty</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IDENT</span>:
        wasIdent = true;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">STRING</span>: {
        <span class="enscript-type">const</span> Identifier* ident = m_token.m_data.ident;
        <span class="enscript-keyword">if</span> (complete || (wasIdent &amp;&amp; (*ident == m_globalData-&gt;propertyNames-&gt;get || *ident == m_globalData-&gt;propertyNames-&gt;set)))
            nextExpectIdentifier(LexerFlagsIgnoreReservedWords);
        <span class="enscript-keyword">else</span>
            nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);
        
        <span class="enscript-keyword">if</span> (match(COLON)) {
            next();
            TreeExpression node = parseAssignmentExpression(context);
            failIfFalse(node);
            <span class="enscript-keyword">return</span> context.<span class="enscript-type">template</span> createProperty&lt;complete&gt;(ident, node, PropertyNode::Constant);
        }
        failIfFalse(wasIdent);
        <span class="enscript-type">const</span> Identifier* accessorName = 0;
        TreeFormalParameterList parameters = 0;
        TreeFunctionBody body = 0;
        <span class="enscript-type">int</span> openBracePos = 0;
        <span class="enscript-type">int</span> closeBracePos = 0;
        <span class="enscript-type">int</span> bodyStartLine = 0;
        <span class="enscript-reference">PropertyNode</span>::Type type;
        <span class="enscript-keyword">if</span> (*ident == m_globalData-&gt;propertyNames-&gt;get)
            type = PropertyNode::Getter;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*ident == m_globalData-&gt;propertyNames-&gt;set)
            type = PropertyNode::Setter;
        <span class="enscript-keyword">else</span>
            fail();
        <span class="enscript-type">const</span> Identifier* stringPropertyName = 0;
        <span class="enscript-type">double</span> numericPropertyName = 0;
        <span class="enscript-keyword">if</span> (m_token.m_type == IDENT || m_token.m_type == STRING)
            stringPropertyName = m_token.m_data.ident;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m_token.m_type == NUMBER)
            numericPropertyName = m_token.m_data.doubleValue;
        <span class="enscript-keyword">else</span>
            fail();
        next();
        failIfFalse((parseFunctionInfo&lt;FunctionNoRequirements, false&gt;(context, accessorName, parameters, body, openBracePos, closeBracePos, bodyStartLine)));
        <span class="enscript-keyword">if</span> (stringPropertyName)
            <span class="enscript-keyword">return</span> context.<span class="enscript-type">template</span> createGetterOrSetterProperty&lt;complete&gt;(m_lexer-&gt;lastLineNumber(), type, stringPropertyName, parameters, body, openBracePos, closeBracePos, bodyStartLine, m_lastLine);
        <span class="enscript-keyword">return</span> context.<span class="enscript-type">template</span> createGetterOrSetterProperty&lt;complete&gt;(const_cast&lt;JSGlobalData*&gt;(m_globalData), m_lexer-&gt;lastLineNumber(), type, numericPropertyName, parameters, body, openBracePos, closeBracePos, bodyStartLine, m_lastLine);
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">NUMBER</span>: {
        <span class="enscript-type">double</span> propertyName = m_token.m_data.doubleValue;
        next();
        consumeOrFail(COLON);
        TreeExpression node = parseAssignmentExpression(context);
        failIfFalse(node);
        <span class="enscript-keyword">return</span> context.<span class="enscript-type">template</span> createProperty&lt;complete&gt;(const_cast&lt;JSGlobalData*&gt;(m_globalData), propertyName, node, PropertyNode::Constant);
    }
    <span class="enscript-reference">default</span>:
        failIfFalse(m_token.m_type &amp; KeywordTokenFlag);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">namedProperty</span>;
    }
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseObjectLiteral(TreeBuilder&amp; context)
{
    <span class="enscript-type">int</span> startOffset = m_token.m_data.intValue;
    <span class="enscript-type">unsigned</span> oldLastLineNumber = m_lexer-&gt;lastLineNumber();
    <span class="enscript-type">unsigned</span> oldLineNumber = m_lexer-&gt;lineNumber();
    consumeOrFailWithFlags(OPENBRACE, TreeBuilder::DontBuildStrings);
    
    <span class="enscript-type">int</span> oldNonLHSCount = m_nonLHSCount;
    
    <span class="enscript-keyword">if</span> (match(CLOSEBRACE)) {
        next();
        <span class="enscript-keyword">return</span> context.createObjectLiteral(m_lexer-&gt;lastLineNumber());
    }
    
    TreeProperty property = parseProperty&lt;false&gt;(context);
    failIfFalse(property);
    <span class="enscript-keyword">if</span> (!m_syntaxAlreadyValidated &amp;&amp; context.getType(property) != PropertyNode::Constant) {
        m_lexer-&gt;setOffset(startOffset);
        next();
        m_lexer-&gt;setLastLineNumber(oldLastLineNumber);
        m_lexer-&gt;setLineNumber(oldLineNumber);
        <span class="enscript-keyword">return</span> parseStrictObjectLiteral(context);
    }
    TreePropertyList propertyList = context.createPropertyList(m_lexer-&gt;lastLineNumber(), property);
    TreePropertyList tail = propertyList;
    <span class="enscript-keyword">while</span> (match(COMMA)) {
        next(TreeBuilder::DontBuildStrings);
        <span class="enscript-comment">// allow extra comma, see <a href="http://bugs.webkit.org/show_bug.cgi?id=5939">http://bugs.webkit.org/show_bug.cgi?id=5939</a>
</span>        <span class="enscript-keyword">if</span> (match(CLOSEBRACE))
            <span class="enscript-keyword">break</span>;
        property = parseProperty&lt;false&gt;(context);
        failIfFalse(property);
        <span class="enscript-keyword">if</span> (!m_syntaxAlreadyValidated &amp;&amp; context.getType(property) != PropertyNode::Constant) {
            m_lexer-&gt;setOffset(startOffset);
            next();
            m_lexer-&gt;setLastLineNumber(oldLastLineNumber);
            m_lexer-&gt;setLineNumber(oldLineNumber);
            <span class="enscript-keyword">return</span> parseStrictObjectLiteral(context);
        }
        tail = context.createPropertyList(m_lexer-&gt;lastLineNumber(), property, tail);
    }
    
    consumeOrFail(CLOSEBRACE);
    
    m_nonLHSCount = oldNonLHSCount;
    
    <span class="enscript-keyword">return</span> context.createObjectLiteral(m_lexer-&gt;lastLineNumber(), propertyList);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseStrictObjectLiteral(TreeBuilder&amp; context)
{
    consumeOrFail(OPENBRACE);
    
    <span class="enscript-type">int</span> oldNonLHSCount = m_nonLHSCount;

    <span class="enscript-keyword">if</span> (match(CLOSEBRACE)) {
        next();
        <span class="enscript-keyword">return</span> context.createObjectLiteral(m_lexer-&gt;lastLineNumber());
    }
    
    TreeProperty property = parseProperty&lt;true&gt;(context);
    failIfFalse(property);
    
    <span class="enscript-type">typedef</span> HashMap&lt;RefPtr&lt;StringImpl&gt;, <span class="enscript-type">unsigned</span>, IdentifierRepHash&gt; ObjectValidationMap;
    ObjectValidationMap objectValidator;
    <span class="enscript-comment">// Add the first property
</span>    <span class="enscript-keyword">if</span> (!m_syntaxAlreadyValidated)
        objectValidator.add(context.getName(property).impl(), context.getType(property));
    
    TreePropertyList propertyList = context.createPropertyList(m_lexer-&gt;lastLineNumber(), property);
    TreePropertyList tail = propertyList;
    <span class="enscript-keyword">while</span> (match(COMMA)) {
        next();
        <span class="enscript-comment">// allow extra comma, see <a href="http://bugs.webkit.org/show_bug.cgi?id=5939">http://bugs.webkit.org/show_bug.cgi?id=5939</a>
</span>        <span class="enscript-keyword">if</span> (match(CLOSEBRACE))
            <span class="enscript-keyword">break</span>;
        property = parseProperty&lt;true&gt;(context);
        failIfFalse(property);
        <span class="enscript-keyword">if</span> (!m_syntaxAlreadyValidated) {
            <span class="enscript-reference">ObjectValidationMap</span>::AddResult propertyEntry = objectValidator.add(context.getName(property).impl(), context.getType(property));
            <span class="enscript-keyword">if</span> (!propertyEntry.isNewEntry) {
                failIfTrue(propertyEntry.iterator-&gt;second == PropertyNode::Constant);
                failIfTrue(context.getType(property) == PropertyNode::Constant);
                failIfTrue(context.getType(property) &amp; propertyEntry.iterator-&gt;second);
                propertyEntry.iterator-&gt;second |= context.getType(property);
            }
        }
        tail = context.createPropertyList(m_lexer-&gt;lastLineNumber(), property, tail);
    }
    
    consumeOrFail(CLOSEBRACE);

    m_nonLHSCount = oldNonLHSCount;

    <span class="enscript-keyword">return</span> context.createObjectLiteral(m_lexer-&gt;lastLineNumber(), propertyList);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrayLiteral(TreeBuilder&amp; context)
{
    consumeOrFailWithFlags(OPENBRACKET, TreeBuilder::DontBuildStrings);
    
    <span class="enscript-type">int</span> oldNonLHSCount = m_nonLHSCount;
    
    <span class="enscript-type">int</span> elisions = 0;
    <span class="enscript-keyword">while</span> (match(COMMA)) {
        next(TreeBuilder::DontBuildStrings);
        elisions++;
    }
    <span class="enscript-keyword">if</span> (match(CLOSEBRACKET)) {
        next(TreeBuilder::DontBuildStrings);
        <span class="enscript-keyword">return</span> context.createArray(m_lexer-&gt;lastLineNumber(), elisions);
    }
    
    TreeExpression elem = parseAssignmentExpression(context);
    failIfFalse(elem);
    typename TreeBuilder::ElementList elementList = context.createElementList(elisions, elem);
    typename TreeBuilder::ElementList tail = elementList;
    elisions = 0;
    <span class="enscript-keyword">while</span> (match(COMMA)) {
        next(TreeBuilder::DontBuildStrings);
        elisions = 0;
        
        <span class="enscript-keyword">while</span> (match(COMMA)) {
            next();
            elisions++;
        }
        
        <span class="enscript-keyword">if</span> (match(CLOSEBRACKET)) {
            next(TreeBuilder::DontBuildStrings);
            <span class="enscript-keyword">return</span> context.createArray(m_lexer-&gt;lastLineNumber(), elisions, elementList);
        }
        TreeExpression elem = parseAssignmentExpression(context);
        failIfFalse(elem);
        tail = context.createElementList(tail, elisions, elem);
    }
    
    consumeOrFail(CLOSEBRACKET);
    
    m_nonLHSCount = oldNonLHSCount;
    
    <span class="enscript-keyword">return</span> context.createArray(m_lexer-&gt;lastLineNumber(), elementList);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parsePrimaryExpression(TreeBuilder&amp; context)
{
    failIfStackOverflow();
    <span class="enscript-keyword">switch</span> (m_token.m_type) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">OPENBRACE</span>:
        <span class="enscript-keyword">if</span> (strictMode())
            <span class="enscript-keyword">return</span> parseStrictObjectLiteral(context);
        <span class="enscript-keyword">return</span> parseObjectLiteral(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">OPENBRACKET</span>:
        <span class="enscript-keyword">return</span> parseArrayLiteral(context);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">OPENPAREN</span>: {
        next();
        <span class="enscript-type">int</span> oldNonLHSCount = m_nonLHSCount;
        TreeExpression result = parseExpression(context);
        m_nonLHSCount = oldNonLHSCount;
        consumeOrFail(CLOSEPAREN);
        
        <span class="enscript-keyword">return</span> result;
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">THISTOKEN</span>: {
        next();
        <span class="enscript-keyword">return</span> context.thisExpr(m_lexer-&gt;lastLineNumber());
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IDENT</span>: {
        <span class="enscript-type">int</span> start = tokenStart();
        <span class="enscript-type">const</span> Identifier* ident = m_token.m_data.ident;
        next();
        currentScope()-&gt;useVariable(ident, m_globalData-&gt;propertyNames-&gt;eval == *ident);
        m_lastIdentifier = ident;
        <span class="enscript-keyword">return</span> context.createResolve(m_lexer-&gt;lastLineNumber(), ident, start);
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">STRING</span>: {
        <span class="enscript-type">const</span> Identifier* ident = m_token.m_data.ident;
        next();
        <span class="enscript-keyword">return</span> context.createString(m_lexer-&gt;lastLineNumber(), ident);
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">NUMBER</span>: {
        <span class="enscript-type">double</span> d = m_token.m_data.doubleValue;
        next();
        <span class="enscript-keyword">return</span> context.createNumberExpr(m_lexer-&gt;lastLineNumber(), d);
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">NULLTOKEN</span>: {
        next();
        <span class="enscript-keyword">return</span> context.createNull(m_lexer-&gt;lastLineNumber());
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">TRUETOKEN</span>: {
        next();
        <span class="enscript-keyword">return</span> context.createBoolean(m_lexer-&gt;lastLineNumber(), true);
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">FALSETOKEN</span>: {
        next();
        <span class="enscript-keyword">return</span> context.createBoolean(m_lexer-&gt;lastLineNumber(), false);
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DIVEQUAL</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DIVIDE</span>: {
        <span class="enscript-comment">/* regexp */</span>
        <span class="enscript-type">const</span> Identifier* pattern;
        <span class="enscript-type">const</span> Identifier* flags;
        <span class="enscript-keyword">if</span> (match(DIVEQUAL))
            failIfFalse(m_lexer-&gt;scanRegExp(pattern, flags, <span class="enscript-string">'='</span>));
        <span class="enscript-keyword">else</span>
            failIfFalse(m_lexer-&gt;scanRegExp(pattern, flags));
        
        <span class="enscript-type">int</span> start = tokenStart();
        next();
        TreeExpression re = context.createRegExp(m_lexer-&gt;lastLineNumber(), *pattern, *flags, start);
        <span class="enscript-keyword">if</span> (!re) {
            <span class="enscript-type">const</span> <span class="enscript-type">char</span>* yarrErrorMsg = Yarr::checkSyntax(pattern-&gt;ustring());
            ASSERT(!m_errorMessage.isNull());
            failWithMessage(yarrErrorMsg);
        }
        <span class="enscript-keyword">return</span> re;
    }
    <span class="enscript-reference">default</span>:
        fail();
    }
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeArguments Parser&lt;LexerType&gt;::parseArguments(TreeBuilder&amp; context)
{
    consumeOrFailWithFlags(OPENPAREN, TreeBuilder::DontBuildStrings);
    <span class="enscript-keyword">if</span> (match(CLOSEPAREN)) {
        next(TreeBuilder::DontBuildStrings);
        <span class="enscript-keyword">return</span> context.createArguments();
    }
    TreeExpression firstArg = parseAssignmentExpression(context);
    failIfFalse(firstArg);
    
    TreeArgumentsList argList = context.createArgumentsList(m_lexer-&gt;lastLineNumber(), firstArg);
    TreeArgumentsList tail = argList;
    <span class="enscript-keyword">while</span> (match(COMMA)) {
        next(TreeBuilder::DontBuildStrings);
        TreeExpression arg = parseAssignmentExpression(context);
        failIfFalse(arg);
        tail = context.createArgumentsList(m_lexer-&gt;lastLineNumber(), tail, arg);
    }
    consumeOrFail(CLOSEPAREN);
    <span class="enscript-keyword">return</span> context.createArguments(argList);
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseMemberExpression(TreeBuilder&amp; context)
{
    TreeExpression base = 0;
    <span class="enscript-type">int</span> start = tokenStart();
    <span class="enscript-type">int</span> expressionStart = start;
    <span class="enscript-type">int</span> newCount = 0;
    <span class="enscript-keyword">while</span> (match(NEW)) {
        next();
        newCount++;
    }
    
    <span class="enscript-keyword">if</span> (match(FUNCTION)) {
        <span class="enscript-type">const</span> Identifier* name = &amp;m_globalData-&gt;propertyNames-&gt;nullIdentifier;
        TreeFormalParameterList parameters = 0;
        TreeFunctionBody body = 0;
        <span class="enscript-type">int</span> openBracePos = 0;
        <span class="enscript-type">int</span> closeBracePos = 0;
        <span class="enscript-type">int</span> bodyStartLine = 0;
        next();
        failIfFalse((parseFunctionInfo&lt;FunctionNoRequirements, false&gt;(context, name, parameters, body, openBracePos, closeBracePos, bodyStartLine)));
        base = context.createFunctionExpr(m_lexer-&gt;lastLineNumber(), name, body, parameters, openBracePos, closeBracePos, bodyStartLine, m_lastLine);
    } <span class="enscript-keyword">else</span>
        base = parsePrimaryExpression(context);
    
    failIfFalse(base);
    <span class="enscript-keyword">while</span> (true) {
        <span class="enscript-keyword">switch</span> (m_token.m_type) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">OPENBRACKET</span>: {
            m_nonTrivialExpressionCount++;
            <span class="enscript-type">int</span> expressionEnd = lastTokenEnd();
            next();
            <span class="enscript-type">int</span> nonLHSCount = m_nonLHSCount;
            <span class="enscript-type">int</span> initialAssignments = m_assignmentCount;
            TreeExpression property = parseExpression(context);
            failIfFalse(property);
            base = context.createBracketAccess(m_lexer-&gt;lastLineNumber(), base, property, initialAssignments != m_assignmentCount, expressionStart, expressionEnd, tokenEnd());
            consumeOrFail(CLOSEBRACKET);
            m_nonLHSCount = nonLHSCount;
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">OPENPAREN</span>: {
            m_nonTrivialExpressionCount++;
            <span class="enscript-type">int</span> nonLHSCount = m_nonLHSCount;
            <span class="enscript-keyword">if</span> (newCount) {
                newCount--;
                <span class="enscript-type">int</span> exprEnd = lastTokenEnd();
                TreeArguments arguments = parseArguments(context);
                failIfFalse(arguments);
                base = context.createNewExpr(m_lexer-&gt;lastLineNumber(), base, arguments, start, exprEnd, lastTokenEnd());           
            } <span class="enscript-keyword">else</span> {
                <span class="enscript-type">int</span> expressionEnd = lastTokenEnd();
                TreeArguments arguments = parseArguments(context);
                failIfFalse(arguments);
                base = context.makeFunctionCallNode(m_lexer-&gt;lastLineNumber(), base, arguments, expressionStart, expressionEnd, lastTokenEnd());
            }
            m_nonLHSCount = nonLHSCount;
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">DOT</span>: {
            m_nonTrivialExpressionCount++;
            <span class="enscript-type">int</span> expressionEnd = lastTokenEnd();
            nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);
            matchOrFail(IDENT);
            base = context.createDotAccess(m_lexer-&gt;lastLineNumber(), base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEnd());
            next();
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">endMemberExpression</span>;
        }
    }
<span class="enscript-reference">endMemberExpression</span>:
    <span class="enscript-keyword">while</span> (newCount--)
        base = context.createNewExpr(m_lexer-&gt;lastLineNumber(), base, start, lastTokenEnd());
    <span class="enscript-keyword">return</span> base;
}

<span class="enscript-type">template</span> &lt;typename LexerType&gt;
<span class="enscript-type">template</span> &lt;<span class="enscript-type">class</span> TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
{
    typename TreeBuilder::UnaryExprContext unaryExprContext(context);
    AllowInOverride allowInOverride(<span class="enscript-keyword">this</span>);
    <span class="enscript-type">int</span> tokenStackDepth = 0;
    <span class="enscript-type">bool</span> modifiesExpr = false;
    <span class="enscript-type">bool</span> requiresLExpr = false;
    <span class="enscript-keyword">while</span> (isUnaryOp(m_token.m_type)) {
        <span class="enscript-keyword">if</span> (strictMode()) {
            <span class="enscript-keyword">switch</span> (m_token.m_type) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">PLUSPLUS</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">MINUSMINUS</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AUTOPLUSPLUS</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AUTOMINUSMINUS</span>:
                failIfTrue(requiresLExpr);
                modifiesExpr = true;
                requiresLExpr = true;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DELETETOKEN</span>:
                failIfTrue(requiresLExpr);
                requiresLExpr = true;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                failIfTrue(requiresLExpr);
                <span class="enscript-keyword">break</span>;
            }
        }
        m_nonLHSCount++;
        context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStart());
        next();
        m_nonTrivialExpressionCount++;
    }
    <span class="enscript-type">int</span> subExprStart = tokenStart();
    TreeExpression expr = parseMemberExpression(context);
    failIfFalse(expr);
    <span class="enscript-type">bool</span> isEvalOrArguments = false;
    <span class="enscript-keyword">if</span> (strictMode() &amp;&amp; !m_syntaxAlreadyValidated) {
        <span class="enscript-keyword">if</span> (context.isResolve(expr))
            isEvalOrArguments = *m_lastIdentifier == m_globalData-&gt;propertyNames-&gt;eval || *m_lastIdentifier == m_globalData-&gt;propertyNames-&gt;arguments;
    }
    failIfTrueIfStrictWithNameAndMessage(isEvalOrArguments &amp;&amp; modifiesExpr, <span class="enscript-string">&quot;'&quot;</span>, m_lastIdentifier-&gt;impl(), <span class="enscript-string">&quot;' cannot be modified in strict mode&quot;</span>);
    <span class="enscript-keyword">switch</span> (m_token.m_type) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PLUSPLUS</span>:
        m_nonTrivialExpressionCount++;
        m_nonLHSCount++;
        expr = context.makePostfixNode(m_lexer-&gt;lastLineNumber(), expr, OpPlusPlus, subExprStart, lastTokenEnd(), tokenEnd());
        m_assignmentCount++;
        failIfTrueIfStrictWithNameAndMessage(isEvalOrArguments, <span class="enscript-string">&quot;'&quot;</span>, m_lastIdentifier-&gt;impl(), <span class="enscript-string">&quot;' cannot be modified in strict mode&quot;</span>);
        failIfTrueIfStrict(requiresLExpr);
        next();
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MINUSMINUS</span>:
        m_nonTrivialExpressionCount++;
        m_nonLHSCount++;
        expr = context.makePostfixNode(m_lexer-&gt;lastLineNumber(), expr, OpMinusMinus, subExprStart, lastTokenEnd(), tokenEnd());
        m_assignmentCount++;
        failIfTrueIfStrictWithNameAndMessage(isEvalOrArguments, <span class="enscript-string">&quot;'&quot;</span>, m_lastIdentifier-&gt;impl(), <span class="enscript-string">&quot;' cannot be modified in strict mode&quot;</span>);
        failIfTrueIfStrict(requiresLExpr);
        next();
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">break</span>;
    }
    
    <span class="enscript-type">int</span> end = lastTokenEnd();
    
    <span class="enscript-keyword">if</span> (!TreeBuilder::CreatesAST &amp;&amp; (m_syntaxAlreadyValidated || !strictMode()))
        <span class="enscript-keyword">return</span> expr;
    
    <span class="enscript-keyword">while</span> (tokenStackDepth) {
        <span class="enscript-keyword">switch</span> (context.unaryTokenStackLastType(tokenStackDepth)) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">EXCLAMATION</span>:
            expr = context.createLogicalNot(m_lexer-&gt;lastLineNumber(), expr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">TILDE</span>:
            expr = context.makeBitwiseNotNode(m_lexer-&gt;lastLineNumber(), expr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">MINUS</span>:
            expr = context.makeNegateNode(m_lexer-&gt;lastLineNumber(), expr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">PLUS</span>:
            expr = context.createUnaryPlus(m_lexer-&gt;lastLineNumber(), expr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">PLUSPLUS</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">AUTOPLUSPLUS</span>:
            expr = context.makePrefixNode(m_lexer-&gt;lastLineNumber(), expr, OpPlusPlus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);
            m_assignmentCount++;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">MINUSMINUS</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">AUTOMINUSMINUS</span>:
            expr = context.makePrefixNode(m_lexer-&gt;lastLineNumber(), expr, OpMinusMinus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);
            m_assignmentCount++;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">TYPEOF</span>:
            expr = context.makeTypeOfNode(m_lexer-&gt;lastLineNumber(), expr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">VOIDTOKEN</span>:
            expr = context.createVoid(m_lexer-&gt;lastLineNumber(), expr);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">DELETETOKEN</span>:
            failIfTrueIfStrictWithNameAndMessage(context.isResolve(expr), <span class="enscript-string">&quot;Cannot delete unqualified property&quot;</span>, m_lastIdentifier-&gt;impl(), <span class="enscript-string">&quot;in strict mode&quot;</span>);
            expr = context.makeDeleteNode(m_lexer-&gt;lastLineNumber(), expr, context.unaryTokenStackLastStart(tokenStackDepth), end, end);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            <span class="enscript-comment">// If we get here something has gone horribly horribly wrong
</span>            CRASH();
        }
        subExprStart = context.unaryTokenStackLastStart(tokenStackDepth);
        context.unaryTokenStackRemoveLast(tokenStackDepth);
    }
    <span class="enscript-keyword">return</span> expr;
}

<span class="enscript-comment">// Instantiate the two flavors of Parser we need instead of putting most of this file in Parser.h
</span><span class="enscript-type">template</span> <span class="enscript-type">class</span> Parser&lt; Lexer&lt;LChar&gt; &gt;;
<span class="enscript-type">template</span> <span class="enscript-type">class</span> Parser&lt; Lexer&lt;UChar&gt; &gt;;

} <span class="enscript-comment">// namespace JSC
</span></pre>
<hr />
</body></html>