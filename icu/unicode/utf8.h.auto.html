<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>utf8.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">utf8.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
*******************************************************************************
*
*   Copyright (C) 1999-2004, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*   file name:  utf8.h
*   encoding:   US-ASCII
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 1999sep13
*   created by: Markus W. Scherer
*/</span>

<span class="enscript-comment">/**
 * \file
 * \brief C API: 8-bit Unicode handling macros
 * 
 * This file defines macros to deal with 8-bit Unicode (UTF-8) code units (bytes) and strings.
 * utf8.h is included by utf.h after unicode/umachine.h
 * and some common definitions.
 *
 * For more information see utf.h and the ICU User Guide Strings chapter
 * (<a href="http://oss.software.ibm.com/icu/userguide/">http://oss.software.ibm.com/icu/userguide/</a>).
 *
 * &lt;em&gt;Usage:&lt;/em&gt;
 * ICU coding guidelines for if() statements should be followed when using these macros.
 * Compound statements (curly braces {}) must be used  for if-else-while... 
 * bodies and all macro statements should be terminated with semicolon.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__UTF8_H__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__UTF8_H__</span>

<span class="enscript-comment">/* utf.h must be included first. */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__UTF_H__</span>
#   <span class="enscript-reference">include</span> <span class="enscript-string">&quot;unicode/utf.h&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* internal definitions ----------------------------------------------------- */</span>

<span class="enscript-comment">/**
 * \var utf8_countTrailBytes
 * Internal array with numbers of trail bytes for any given byte used in
 * lead byte position.
 * @internal
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">U_UTF8_IMPL</span>
U_INTERNAL <span class="enscript-type">const</span> uint8_t 
#<span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">U_STATIC_IMPLEMENTATION</span>)
U_CFUNC <span class="enscript-type">const</span> uint8_t
#<span class="enscript-reference">else</span>
U_CFUNC U_IMPORT <span class="enscript-type">const</span> uint8_t <span class="enscript-comment">/* U_IMPORT2? */</span> <span class="enscript-comment">/*U_IMPORT*/</span> 
#<span class="enscript-reference">endif</span>
utf8_countTrailBytes[256];

<span class="enscript-comment">/**
 * Count the trail bytes for a UTF-8 lead byte.
 * @internal
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_COUNT_TRAIL_BYTES</span>(leadByte) (utf8_countTrailBytes[(uint8_t)leadByte])

<span class="enscript-comment">/**
 * Mask a UTF-8 lead byte, leave only the lower bits that form part of the code point value.
 * @internal
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_MASK_LEAD_BYTE</span>(leadByte, countTrailBytes) ((leadByte)&amp;=(1&lt;&lt;(6-(countTrailBytes)))-1)

<span class="enscript-comment">/**
 * Function for handling &quot;next code point&quot; with error-checking.
 * @internal
 */</span>
U_INTERNAL UChar32 U_EXPORT2
<span class="enscript-function-name">utf8_nextCharSafeBody</span>(<span class="enscript-type">const</span> uint8_t *s, int32_t *pi, int32_t length, UChar32 c, UBool strict);

<span class="enscript-comment">/**
 * Function for handling &quot;append code point&quot; with error-checking.
 * @internal
 */</span>
U_INTERNAL int32_t U_EXPORT2
<span class="enscript-function-name">utf8_appendCharSafeBody</span>(uint8_t *s, int32_t i, int32_t length, UChar32 c, UBool *pIsError);

<span class="enscript-comment">/**
 * Function for handling &quot;previous code point&quot; with error-checking.
 * @internal
 */</span>
U_INTERNAL UChar32 U_EXPORT2
<span class="enscript-function-name">utf8_prevCharSafeBody</span>(<span class="enscript-type">const</span> uint8_t *s, int32_t start, int32_t *pi, UChar32 c, UBool strict);

<span class="enscript-comment">/**
 * Function for handling &quot;skip backward one code point&quot; with error-checking.
 * @internal
 */</span>
U_INTERNAL int32_t U_EXPORT2
<span class="enscript-function-name">utf8_back1SafeBody</span>(<span class="enscript-type">const</span> uint8_t *s, int32_t start, int32_t i);

<span class="enscript-comment">/* single-code point definitions -------------------------------------------- */</span>

<span class="enscript-comment">/**
 * Does this code unit (byte) encode a code point by itself (US-ASCII 0..0x7f)?
 * @param c 8-bit code unit (byte)
 * @return TRUE or FALSE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_IS_SINGLE</span>(c) (((c)&amp;0x80)==0)

<span class="enscript-comment">/**
 * Is this code unit (byte) a UTF-8 lead byte?
 * @param c 8-bit code unit (byte)
 * @return TRUE or FALSE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_IS_LEAD</span>(c) ((uint8_t)((c)-0xc0)&lt;0x3e)

<span class="enscript-comment">/**
 * Is this code unit (byte) a UTF-8 trail byte?
 * @param c 8-bit code unit (byte)
 * @return TRUE or FALSE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_IS_TRAIL</span>(c) (((c)&amp;0xc0)==0x80)

<span class="enscript-comment">/**
 * How many code units (bytes) are used for the UTF-8 encoding
 * of this Unicode code point?
 * @param c 32-bit code point
 * @return 1..4, or 0 if c is a surrogate or not a Unicode code point
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_LENGTH</span>(c) \
    ((uint32_t)(c)&lt;=0x7f ? 1 : \
        ((uint32_t)(c)&lt;=0x7ff ? 2 : \
            ((uint32_t)(c)&lt;=0xd7ff ? 3 : \
                ((uint32_t)(c)&lt;=0xdfff || (uint32_t)(c)&gt;0x10ffff ? 0 : \
                    ((uint32_t)(c)&lt;=0xffff ? 3 : 4)\
                ) \
            ) \
        ) \
    )

<span class="enscript-comment">/**
 * The maximum number of UTF-8 code units (bytes) per Unicode code point (U+0000..U+10ffff).
 * @return 4
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">U8_MAX_LENGTH</span> 4

<span class="enscript-comment">/**
 * Get a code point from a string at a random-access offset,
 * without changing the offset.
 * The offset may point to either the lead byte or one of the trail bytes
 * for a code point, in which case the macro will read all of the bytes
 * for the code point.
 * The result is undefined if the offset points to an illegal UTF-8
 * byte sequence.
 * Iteration through a string is more efficient with U8_NEXT_UNSAFE or U8_NEXT.
 *
 * @param s const uint8_t * string
 * @param i string offset
 * @param c output UChar32 variable
 * @see U8_GET
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_GET_UNSAFE</span>(s, i, c) { \
    int32_t _u8_get_unsafe_index=(int32_t)(i); \
    U8_SET_CP_START_UNSAFE(s, _u8_get_unsafe_index); \
    U8_NEXT_UNSAFE(s, _u8_get_unsafe_index, c); \
}

<span class="enscript-comment">/**
 * Get a code point from a string at a random-access offset,
 * without changing the offset.
 * The offset may point to either the lead byte or one of the trail bytes
 * for a code point, in which case the macro will read all of the bytes
 * for the code point.
 * If the offset points to an illegal UTF-8 byte sequence, then
 * c is set to a negative value.
 * Iteration through a string is more efficient with U8_NEXT_UNSAFE or U8_NEXT.
 *
 * @param s const uint8_t * string
 * @param start starting string offset
 * @param i string offset, start&lt;=i&lt;length
 * @param length string length
 * @param c output UChar32 variable, set to &lt;0 in case of an error
 * @see U8_GET_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_GET</span>(s, start, i, length, c) { \
    int32_t _u8_get_index=(int32_t)(i); \
    U8_SET_CP_START(s, start, _u8_get_index); \
    U8_NEXT(s, _u8_get_index, length, c); \
}

<span class="enscript-comment">/* definitions with forward iteration --------------------------------------- */</span>

<span class="enscript-comment">/**
 * Get a code point from a string at a code point boundary offset,
 * and advance the offset to the next code point boundary.
 * (Post-incrementing forward iteration.)
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
 *
 * The offset may point to the lead byte of a multi-byte sequence,
 * in which case the macro will read the whole sequence.
 * The result is undefined if the offset points to a trail byte
 * or an illegal UTF-8 sequence.
 *
 * @param s const uint8_t * string
 * @param i string offset
 * @param c output UChar32 variable
 * @see U8_NEXT
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_NEXT_UNSAFE</span>(s, i, c) { \
    (c)=(s)[(i)++]; \
    <span class="enscript-keyword">if</span>((uint8_t)((c)-0xc0)&lt;0x35) { \
        uint8_t __count=U8_COUNT_TRAIL_BYTES(c); \
        U8_MASK_LEAD_BYTE(c, __count); \
        <span class="enscript-keyword">switch</span>(__count) { \
        <span class="enscript-comment">/* each following branch falls through to the next one */</span> \
        <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>: \
            (c)=((c)&lt;&lt;6)|((s)[(i)++]&amp;0x3f); \
        <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>: \
            (c)=((c)&lt;&lt;6)|((s)[(i)++]&amp;0x3f); \
        <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>: \
            (c)=((c)&lt;&lt;6)|((s)[(i)++]&amp;0x3f); \
        <span class="enscript-comment">/* no other branches to optimize switch() */</span> \
            <span class="enscript-keyword">break</span>; \
        } \
    } \
}

<span class="enscript-comment">/**
 * Get a code point from a string at a code point boundary offset,
 * and advance the offset to the next code point boundary.
 * (Post-incrementing forward iteration.)
 * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
 *
 * The offset may point to the lead byte of a multi-byte sequence,
 * in which case the macro will read the whole sequence.
 * If the offset points to a trail byte or an illegal UTF-8 sequence, then
 * c is set to a negative value.
 *
 * @param s const uint8_t * string
 * @param i string offset, i&lt;length
 * @param length string length
 * @param c output UChar32 variable, set to &lt;0 in case of an error
 * @see U8_NEXT_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_NEXT</span>(s, i, length, c) { \
    (c)=(s)[(i)++]; \
    <span class="enscript-keyword">if</span>(((uint8_t)(c))&gt;=0x80) { \
        <span class="enscript-keyword">if</span>(U8_IS_LEAD(c)) { \
            (c)=utf8_nextCharSafeBody((<span class="enscript-type">const</span> uint8_t *)s, &amp;(i), (int32_t)(length), c, -1); \
        } <span class="enscript-keyword">else</span> { \
            (c)=U_SENTINEL; \
        } \
    } \
}

<span class="enscript-comment">/**
 * Append a code point to a string, overwriting 1 to 4 bytes.
 * The offset points to the current end of the string contents
 * and is advanced (post-increment).
 * &quot;Unsafe&quot; macro, assumes a valid code point and sufficient space in the string.
 * Otherwise, the result is undefined.
 *
 * @param s const uint8_t * string buffer
 * @param i string offset
 * @param c code point to append
 * @see U8_APPEND
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_APPEND_UNSAFE</span>(s, i, c) { \
    <span class="enscript-keyword">if</span>((uint32_t)(c)&lt;=0x7f) { \
        (s)[(i)++]=(uint8_t)(c); \
    } <span class="enscript-keyword">else</span> { \
        <span class="enscript-keyword">if</span>((uint32_t)(c)&lt;=0x7ff) { \
            (s)[(i)++]=(uint8_t)(((c)&gt;&gt;6)|0xc0); \
        } <span class="enscript-keyword">else</span> { \
            <span class="enscript-keyword">if</span>((uint32_t)(c)&lt;=0xffff) { \
                (s)[(i)++]=(uint8_t)(((c)&gt;&gt;12)|0xe0); \
            } <span class="enscript-keyword">else</span> { \
                (s)[(i)++]=(uint8_t)(((c)&gt;&gt;18)|0xf0); \
                (s)[(i)++]=(uint8_t)((((c)&gt;&gt;12)&amp;0x3f)|0x80); \
            } \
            (s)[(i)++]=(uint8_t)((((c)&gt;&gt;6)&amp;0x3f)|0x80); \
        } \
        (s)[(i)++]=(uint8_t)(((c)&amp;0x3f)|0x80); \
    } \
}

<span class="enscript-comment">/**
 * Append a code point to a string, overwriting 1 or 2 code units.
 * The offset points to the current end of the string contents
 * and is advanced (post-increment).
 * &quot;Safe&quot; macro, checks for a valid code point.
 * If a non-ASCII code point is written, checks for sufficient space in the string.
 * If the code point is not valid or trail bytes do not fit,
 * then isError is set to TRUE.
 *
 * @param s const uint8_t * string buffer
 * @param i string offset, i&lt;length
 * @param length size of the string buffer
 * @param c code point to append
 * @param isError output UBool set to TRUE if an error occurs, otherwise not modified
 * @see U8_APPEND_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_APPEND</span>(s, i, length, c, isError) { \
    <span class="enscript-keyword">if</span>((uint32_t)(c)&lt;=0x7f) { \
        (s)[(i)++]=(uint8_t)(c); \
    } <span class="enscript-keyword">else</span> { \
        (i)=utf8_appendCharSafeBody(s, (int32_t)(i), (int32_t)(length), c, &amp;(isError)); \
    } \
}

<span class="enscript-comment">/**
 * Advance the string offset from one code point boundary to the next.
 * (Post-incrementing iteration.)
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
 *
 * @param s const uint8_t * string
 * @param i string offset
 * @see U8_FWD_1
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_FWD_1_UNSAFE</span>(s, i) { \
    (i)+=1+U8_COUNT_TRAIL_BYTES((s)[i]); \
}

<span class="enscript-comment">/**
 * Advance the string offset from one code point boundary to the next.
 * (Post-incrementing iteration.)
 * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
 *
 * @param s const uint8_t * string
 * @param i string offset, i&lt;length
 * @param length string length
 * @see U8_FWD_1_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_FWD_1</span>(s, i, length) { \
    uint8_t __b=(s)[(i)++]; \
    <span class="enscript-keyword">if</span>(U8_IS_LEAD(__b)) { \
        uint8_t __count=U8_COUNT_TRAIL_BYTES(__b); \
        <span class="enscript-keyword">if</span>((i)+__count&gt;(length)) { \
            __count=(uint8_t)((length)-(i)); \
        } \
        <span class="enscript-keyword">while</span>(__count&gt;0 &amp;&amp; U8_IS_TRAIL((s)[i])) { \
            ++(i); \
            --__count; \
        } \
    } \
}

<span class="enscript-comment">/**
 * Advance the string offset from one code point boundary to the n-th next one,
 * i.e., move forward by n code points.
 * (Post-incrementing iteration.)
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
 *
 * @param s const uint8_t * string
 * @param i string offset
 * @param n number of code points to skip
 * @see U8_FWD_N
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_FWD_N_UNSAFE</span>(s, i, n) { \
    int32_t __N=(n); \
    <span class="enscript-keyword">while</span>(__N&gt;0) { \
        U8_FWD_1_UNSAFE(s, i); \
        --__N; \
    } \
}

<span class="enscript-comment">/**
 * Advance the string offset from one code point boundary to the n-th next one,
 * i.e., move forward by n code points.
 * (Post-incrementing iteration.)
 * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
 *
 * @param s const uint8_t * string
 * @param i string offset, i&lt;length
 * @param length string length
 * @param n number of code points to skip
 * @see U8_FWD_N_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_FWD_N</span>(s, i, length, n) { \
    int32_t __N=(n); \
    <span class="enscript-keyword">while</span>(__N&gt;0 &amp;&amp; (i)&lt;(length)) { \
        U8_FWD_1(s, i, length); \
        --__N; \
    } \
}

<span class="enscript-comment">/**
 * Adjust a random-access offset to a code point boundary
 * at the start of a code point.
 * If the offset points to a UTF-8 trail byte,
 * then the offset is moved backward to the corresponding lead byte.
 * Otherwise, it is not modified.
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
 *
 * @param s const uint8_t * string
 * @param i string offset
 * @see U8_SET_CP_START
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_SET_CP_START_UNSAFE</span>(s, i) { \
    <span class="enscript-keyword">while</span>(U8_IS_TRAIL((s)[i])) { --(i); } \
}

<span class="enscript-comment">/**
 * Adjust a random-access offset to a code point boundary
 * at the start of a code point.
 * If the offset points to a UTF-8 trail byte,
 * then the offset is moved backward to the corresponding lead byte.
 * Otherwise, it is not modified.
 * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
 *
 * @param s const uint8_t * string
 * @param start starting string offset (usually 0)
 * @param i string offset, start&lt;=i
 * @see U8_SET_CP_START_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_SET_CP_START</span>(s, start, i) { \
    <span class="enscript-keyword">if</span>(U8_IS_TRAIL((s)[(i)])) { \
        (i)=utf8_back1SafeBody(s, start, (int32_t)(i)); \
    } \
}

<span class="enscript-comment">/* definitions with backward iteration -------------------------------------- */</span>

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the previous one
 * and get the code point between them.
 * (Pre-decrementing backward iteration.)
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
 *
 * The input offset may be the same as the string length.
 * If the offset is behind a multi-byte sequence, then the macro will read
 * the whole sequence.
 * If the offset is behind a lead byte, then that itself
 * will be returned as the code point.
 * The result is undefined if the offset is behind an illegal UTF-8 sequence.
 *
 * @param s const uint8_t * string
 * @param i string offset
 * @param c output UChar32 variable
 * @see U8_PREV
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_PREV_UNSAFE</span>(s, i, c) { \
    (c)=(s)[--(i)]; \
    <span class="enscript-keyword">if</span>(U8_IS_TRAIL(c)) { \
        uint8_t __b, __count=1, __shift=6; \
\
        <span class="enscript-comment">/* c is a trail byte */</span> \
        (c)&amp;=0x3f; \
        <span class="enscript-keyword">for</span>(;;) { \
            __b=(s)[--(i)]; \
            <span class="enscript-keyword">if</span>(__b&gt;=0xc0) { \
                U8_MASK_LEAD_BYTE(__b, __count); \
                (c)|=(UChar32)__b&lt;&lt;__shift; \
                <span class="enscript-keyword">break</span>; \
            } <span class="enscript-keyword">else</span> { \
                (c)|=(UChar32)(__b&amp;0x3f)&lt;&lt;__shift; \
                ++__count; \
                __shift+=6; \
            } \
        } \
    } \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the previous one
 * and get the code point between them.
 * (Pre-decrementing backward iteration.)
 * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
 *
 * The input offset may be the same as the string length.
 * If the offset is behind a multi-byte sequence, then the macro will read
 * the whole sequence.
 * If the offset is behind a lead byte, then that itself
 * will be returned as the code point.
 * If the offset is behind an illegal UTF-8 sequence, then c is set to a negative value.
 *
 * @param s const uint8_t * string
 * @param start starting string offset (usually 0)
 * @param i string offset, start&lt;=i
 * @param c output UChar32 variable, set to &lt;0 in case of an error
 * @see U8_PREV_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_PREV</span>(s, start, i, c) { \
    (c)=(s)[--(i)]; \
    <span class="enscript-keyword">if</span>((c)&gt;=0x80) { \
        <span class="enscript-keyword">if</span>((c)&lt;=0xbf) { \
            (c)=utf8_prevCharSafeBody(s, start, &amp;(i), c, -1); \
        } <span class="enscript-keyword">else</span> { \
            (c)=U_SENTINEL; \
        } \
    } \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the previous one.
 * (Pre-decrementing backward iteration.)
 * The input offset may be the same as the string length.
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
 *
 * @param s const uint8_t * string
 * @param i string offset
 * @see U8_BACK_1
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_BACK_1_UNSAFE</span>(s, i) { \
    <span class="enscript-keyword">while</span>(U8_IS_TRAIL((s)[--(i)])) {} \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the previous one.
 * (Pre-decrementing backward iteration.)
 * The input offset may be the same as the string length.
 * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
 *
 * @param s const uint8_t * string
 * @param start starting string offset (usually 0)
 * @param i string offset, start&lt;=i
 * @see U8_BACK_1_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_BACK_1</span>(s, start, i) { \
    <span class="enscript-keyword">if</span>(U8_IS_TRAIL((s)[--(i)])) { \
        (i)=utf8_back1SafeBody(s, start, (int32_t)(i)); \
    } \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the n-th one before it,
 * i.e., move backward by n code points.
 * (Pre-decrementing backward iteration.)
 * The input offset may be the same as the string length.
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
 *
 * @param s const uint8_t * string
 * @param i string offset
 * @param n number of code points to skip
 * @see U8_BACK_N
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_BACK_N_UNSAFE</span>(s, i, n) { \
    int32_t __N=(n); \
    <span class="enscript-keyword">while</span>(__N&gt;0) { \
        U8_BACK_1_UNSAFE(s, i); \
        --__N; \
    } \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the n-th one before it,
 * i.e., move backward by n code points.
 * (Pre-decrementing backward iteration.)
 * The input offset may be the same as the string length.
 * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
 *
 * @param s const uint8_t * string
 * @param start index of the start of the string
 * @param i string offset, i&lt;length
 * @param n number of code points to skip
 * @see U8_BACK_N_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_BACK_N</span>(s, start, i, n) { \
    int32_t __N=(n); \
    <span class="enscript-keyword">while</span>(__N&gt;0 &amp;&amp; (i)&gt;(start)) { \
        U8_BACK_1(s, start, i); \
        --__N; \
    } \
}

<span class="enscript-comment">/**
 * Adjust a random-access offset to a code point boundary after a code point.
 * If the offset is behind a partial multi-byte sequence,
 * then the offset is incremented to behind the whole sequence.
 * Otherwise, it is not modified.
 * The input offset may be the same as the string length.
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-8.
 *
 * @param s const uint8_t * string
 * @param i string offset
 * @see U8_SET_CP_LIMIT
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_SET_CP_LIMIT_UNSAFE</span>(s, i) { \
    U8_BACK_1_UNSAFE(s, i); \
    U8_FWD_1_UNSAFE(s, i); \
}

<span class="enscript-comment">/**
 * Adjust a random-access offset to a code point boundary after a code point.
 * If the offset is behind a partial multi-byte sequence,
 * then the offset is incremented to behind the whole sequence.
 * Otherwise, it is not modified.
 * The input offset may be the same as the string length.
 * &quot;Safe&quot; macro, checks for illegal sequences and for string boundaries.
 *
 * @param s const uint8_t * string
 * @param start starting string offset (usually 0)
 * @param i string offset, start&lt;=i&lt;=length
 * @param length string length
 * @see U8_SET_CP_LIMIT_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U8_SET_CP_LIMIT</span>(s, start, i, length) { \
    <span class="enscript-keyword">if</span>((start)&lt;(i) &amp;&amp; (i)&lt;(length)) { \
        U8_BACK_1(s, start, i); \
        U8_FWD_1(s, i, length); \
    } \
}

#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>