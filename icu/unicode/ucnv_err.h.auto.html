<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ucnv_err.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ucnv_err.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
**********************************************************************
*   Copyright (C) 1999-2004, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
 *
 *
 *   ucnv_err.h:
 */</span>

<span class="enscript-comment">/**
 * \file
 * \brief C UConverter predefined error callbacks
 *
 *  &lt;h2&gt;Error Behaviour Functions&lt;/h2&gt;
 *  Defines some error behaviour functions called by ucnv_{from,to}Unicode
 *  These are provided as part of ICU and many are stable, but they
 *  can also be considered only as an example of what can be done with
 *  callbacks.  You may of course write your own.
 *
 *  If you want to write your own, you may also find the functions from
 *  ucnv_cb.h useful when writing your own callbacks.
 *
 *  These functions, although public, should NEVER be called directly.
 *  They should be used as parameters to the ucnv_setFromUCallback
 *  and ucnv_setToUCallback functions, to set the behaviour of a converter
 *  when it encounters ILLEGAL/UNMAPPED/INVALID sequences.
 *
 *  usage example:  'STOP' doesn't need any context, but newContext
 *    could be set to something other than 'NULL' if needed. The available
 *    contexts in this header can modify the default behavior of the callback.
 *
 *  \code
 *  UErrorCode err = U_ZERO_ERROR;
 *  UConverter *myConverter = ucnv_open(&quot;ibm-949&quot;, &amp;err);
 *  const void *oldContext;
 *  UConverterFromUCallback oldAction;
 *
 *
 *  if (U_SUCCESS(err))
 *  {
 *      ucnv_setFromUCallBack(myConverter,
 *                       UCNV_FROM_U_CALLBACK_STOP,
 *                       NULL,
 *                       &amp;oldAction,
 *                       &amp;oldContext,
 *                       &amp;status);
 *  }
 *  \endcode
 *
 *  The code above tells &quot;myConverter&quot; to stop when it encounters an
 *  ILLEGAL/TRUNCATED/INVALID sequences when it is used to convert from
 *  Unicode -&gt; Codepage. The behavior from Codepage to Unicode is not changed,
 *  and ucnv_setToUCallBack would need to be called in order to change
 *  that behavior too.
 *
 *  Here is an example with a context:
 *
 *  \code
 *  UErrorCode err = U_ZERO_ERROR;
 *  UConverter *myConverter = ucnv_open(&quot;ibm-949&quot;, &amp;err);
 *  const void *oldContext;
 *  UConverterFromUCallback oldAction;
 *
 *
 *  if (U_SUCCESS(err))
 *  {
 *      ucnv_setToUCallBack(myConverter,
 *                       UCNV_TO_U_CALLBACK_SUBSTITUTE,
 *                       UCNV_SUB_STOP_ON_ILLEGAL,
 *                       &amp;oldAction,
 *                       &amp;oldContext,
 *                       &amp;status);
 *  }
 *  \endcode
 *
 *  The code above tells &quot;myConverter&quot; to stop when it encounters an
 *  ILLEGAL/TRUNCATED/INVALID sequences when it is used to convert from
 *  Codepage -&gt; Unicode. Any unmapped and legal characters will be
 *  substituted to be the default substitution character.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UCNV_ERR_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCNV_ERR_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;unicode/utypes.h&quot;</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">UCONFIG_NO_CONVERSION</span>

<span class="enscript-comment">/** Forward declaring the UConverter structure. @stable ICU 2.0 */</span>
<span class="enscript-type">struct</span> UConverter;

<span class="enscript-comment">/** @stable ICU 2.0 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> UConverter UConverter;

<span class="enscript-comment">/**
 * FROM_U, TO_U context options for sub callback
 * @stable ICU 2.0
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCNV_SUB_STOP_ON_ILLEGAL</span> <span class="enscript-string">&quot;i&quot;</span>

<span class="enscript-comment">/**
 * FROM_U, TO_U context options for skip callback
 * @stable ICU 2.0
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCNV_SKIP_STOP_ON_ILLEGAL</span> <span class="enscript-string">&quot;i&quot;</span>

<span class="enscript-comment">/**
 * FROM_U_CALLBACK_ESCAPE context option to escape the code unit according to ICU (%UXXXX) 
 * @stable ICU 2.0
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCNV_ESCAPE_ICU</span>       NULL
<span class="enscript-comment">/**
 * FROM_U_CALLBACK_ESCAPE context option to escape the code unit according to JAVA (\\uXXXX)
 * @stable ICU 2.0
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCNV_ESCAPE_JAVA</span>      <span class="enscript-string">&quot;J&quot;</span>
<span class="enscript-comment">/**
 * FROM_U_CALLBACK_ESCAPE context option to escape the code unit according to C (\\uXXXX \\UXXXXXXXX)
 * TO_U_CALLBACK_ESCAPE option to escape the character value accoding to C (\\xXXXX)
 * @stable ICU 2.0
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCNV_ESCAPE_C</span>         <span class="enscript-string">&quot;C&quot;</span>
<span class="enscript-comment">/**
 * FROM_U_CALLBACK_ESCAPE context option to escape the code unit according to XML Decimal escape (&amp;amp;#DDDD;)
 * TO_U_CALLBACK_ESCAPE context option to escape the character value accoding to XML Decimal escape (&amp;amp;#DDDD;)
 * @stable ICU 2.0
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCNV_ESCAPE_XML_DEC</span>   <span class="enscript-string">&quot;D&quot;</span>
<span class="enscript-comment">/**
 * FROM_U_CALLBACK_ESCAPE context option to escape the code unit according to XML Hex escape (&amp;amp;#xXXXX;)
 * TO_U_CALLBACK_ESCAPE context option to escape the character value accoding to XML Hex escape (&amp;amp;#xXXXX;)
 * @stable ICU 2.0
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCNV_ESCAPE_XML_HEX</span>   <span class="enscript-string">&quot;X&quot;</span>
<span class="enscript-comment">/**
 * FROM_U_CALLBACK_ESCAPE context option to escape teh code unit according to Unicode (U+XXXXX)
 * @stable ICU 2.0
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCNV_ESCAPE_UNICODE</span>   <span class="enscript-string">&quot;U&quot;</span>

<span class="enscript-comment">/** 
 * The process condition code to be used with the callbacks.  
 * Codes which are greater than UCNV_IRREGULAR should be 
 * passed on to any chained callbacks.
 * @stable ICU 2.0
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
    UCNV_UNASSIGNED = 0,  <span class="enscript-comment">/**&lt; The code point is unassigned.
                             The error code U_INVALID_CHAR_FOUND will be set. */</span>
    UCNV_ILLEGAL = 1,     <span class="enscript-comment">/**&lt; The code point is illegal. For example, 
                             \\x81\\x2E is illegal in SJIS because \\x2E
                             is not a valid trail byte for the \\x81 
                             lead byte.
                             Also, starting with Unicode 3.0.1, non-shortest byte sequences
                             in UTF-8 (like \\xC1\\xA1 instead of \\x61 for U+0061)
                             are also illegal, not just irregular.
                             The error code U_ILLEGAL_CHAR_FOUND will be set. */</span>
    UCNV_IRREGULAR = 2,   <span class="enscript-comment">/**&lt; The codepoint is not a regular sequence in 
                             the encoding. For example, \\xED\\xA0\\x80..\\xED\\xBF\\xBF
                             are irregular UTF-8 byte sequences for single surrogate
                             code points.
                             The error code U_INVALID_CHAR_FOUND will be set. */</span>
    UCNV_RESET = 3,       <span class="enscript-comment">/**&lt; The callback is called with this reason when a
                             'reset' has occured. Callback should reset all
                             state. */</span>
    UCNV_CLOSE = 4,        <span class="enscript-comment">/**&lt; Called when the converter is closed. The
                             callback should release any allocated memory.*/</span>
    UCNV_CLONE = 5         <span class="enscript-comment">/**&lt; Called when ucnv_safeClone() is called on the
                              converter. the pointer available as the
                              'context' is an alias to the original converters'
                              context pointer. If the context must be owned
                              by the new converter, the callback must clone 
                              the data and call ucnv_setFromUCallback 
                              (or setToUCallback) with the correct pointer.
                              @stable ICU 2.2
                           */</span>
} UConverterCallbackReason;


<span class="enscript-comment">/**
 * The structure for the fromUnicode callback function parameter.
 * @stable ICU 2.0
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    uint16_t size;              <span class="enscript-comment">/**&lt; The size of this struct. @stable ICU 2.0 */</span>
    UBool flush;                <span class="enscript-comment">/**&lt; The internal state of converter will be reset and data flushed if set to TRUE. @stable ICU 2.0    */</span>
    UConverter *converter;      <span class="enscript-comment">/**&lt; Pointer to the converter that is opened and to which this struct is passed as an argument. @stable ICU 2.0  */</span>
    <span class="enscript-type">const</span> UChar *source;        <span class="enscript-comment">/**&lt; Pointer to the source source buffer. @stable ICU 2.0    */</span>
    <span class="enscript-type">const</span> UChar *sourceLimit;   <span class="enscript-comment">/**&lt; Pointer to the limit (end + 1) of source buffer. @stable ICU 2.0    */</span>
    <span class="enscript-type">char</span> *target;               <span class="enscript-comment">/**&lt; Pointer to the target buffer. @stable ICU 2.0    */</span>
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *targetLimit;    <span class="enscript-comment">/**&lt; Pointer to the limit (end + 1) of target buffer. @stable ICU 2.0     */</span>
    int32_t *offsets;           <span class="enscript-comment">/**&lt; Pointer to the buffer that recieves the offsets. *offset = blah ; offset++;. @stable ICU 2.0  */</span>
} UConverterFromUnicodeArgs;


<span class="enscript-comment">/**
 * The structure for the toUnicode callback function parameter.
 * @stable ICU 2.0
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    uint16_t size;              <span class="enscript-comment">/**&lt; The size of this struct   @stable ICU 2.0 */</span>
    UBool flush;                <span class="enscript-comment">/**&lt; The internal state of converter will be reset and data flushed if set to TRUE. @stable ICU 2.0   */</span>
    UConverter *converter;      <span class="enscript-comment">/**&lt; Pointer to the converter that is opened and to which this struct is passed as an argument. @stable ICU 2.0 */</span>
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *source;         <span class="enscript-comment">/**&lt; Pointer to the source source buffer. @stable ICU 2.0    */</span>
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *sourceLimit;    <span class="enscript-comment">/**&lt; Pointer to the limit (end + 1) of source buffer. @stable ICU 2.0    */</span>
    UChar *target;              <span class="enscript-comment">/**&lt; Pointer to the target buffer. @stable ICU 2.0    */</span>
    <span class="enscript-type">const</span> UChar *targetLimit;   <span class="enscript-comment">/**&lt; Pointer to the limit (end + 1) of target buffer. @stable ICU 2.0     */</span>
    int32_t *offsets;           <span class="enscript-comment">/**&lt; Pointer to the buffer that recieves the offsets. *offset = blah ; offset++;. @stable ICU 2.0  */</span>
} UConverterToUnicodeArgs;


<span class="enscript-comment">/**
 * DO NOT CALL THIS FUNCTION DIRECTLY!
 * This From Unicode callback STOPS at the ILLEGAL_SEQUENCE,
 * returning the error code back to the caller immediately.
 *
 * @param context Pointer to the callback's private data
 * @param fromUArgs Information about the conversion in progress
 * @param codeUnits Points to 'length' UChars of the concerned Unicode sequence
 * @param length Size (in bytes) of the concerned codepage sequence
 * @param codePoint Single UChar32 (UTF-32) containing the concerend Unicode codepoint.
 * @param reason Defines the reason the callback was invoked
 * @param err This should always be set to a failure status prior to calling.
 * @stable ICU 2.0
 */</span>
U_STABLE <span class="enscript-type">void</span> U_EXPORT2 <span class="enscript-function-name">UCNV_FROM_U_CALLBACK_STOP</span> (
                  <span class="enscript-type">const</span> <span class="enscript-type">void</span> *context,
                  UConverterFromUnicodeArgs *fromUArgs,
                  <span class="enscript-type">const</span> UChar* codeUnits,
                  int32_t length,
                  UChar32 codePoint,
                  UConverterCallbackReason reason,
                  UErrorCode * err);



<span class="enscript-comment">/**
 * DO NOT CALL THIS FUNCTION DIRECTLY!
 * This To Unicode callback STOPS at the ILLEGAL_SEQUENCE,
 * returning the error code back to the caller immediately.
 *
 * @param context Pointer to the callback's private data
 * @param toUArgs Information about the conversion in progress
 * @param codeUnits Points to 'length' bytes of the concerned codepage sequence
 * @param length Size (in bytes) of the concerned codepage sequence
 * @param reason Defines the reason the callback was invoked
 * @param err This should always be set to a failure status prior to calling.
 * @stable ICU 2.0
 */</span>
U_STABLE <span class="enscript-type">void</span> U_EXPORT2 <span class="enscript-function-name">UCNV_TO_U_CALLBACK_STOP</span> (
                  <span class="enscript-type">const</span> <span class="enscript-type">void</span> *context,
                  UConverterToUnicodeArgs *toUArgs,
                  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* codeUnits,
                  int32_t length,
                  UConverterCallbackReason reason,
                  UErrorCode * err);

<span class="enscript-comment">/**
 * DO NOT CALL THIS FUNCTION DIRECTLY!
 * This From Unicode callback skips any ILLEGAL_SEQUENCE, or
 * skips only UNASSINGED_SEQUENCE depending on the context parameter
 * simply ignoring those characters. 
 *
 * @param context  The function currently recognizes the callback options:
 *                 UCNV_SKIP_STOP_ON_ILLEGAL: STOPS at the ILLEGAL_SEQUENCE,
 *                      returning the error code back to the caller immediately.
 *                 NULL: Skips any ILLEGAL_SEQUENCE
 * @param fromUArgs Information about the conversion in progress
 * @param codeUnits Points to 'length' UChars of the concerned Unicode sequence
 * @param length Size (in bytes) of the concerned codepage sequence
 * @param codePoint Single UChar32 (UTF-32) containing the concerend Unicode codepoint.
 * @param reason Defines the reason the callback was invoked
 * @param err Return value will be set to success if the callback was handled,
 *      otherwise this value will be set to a failure status.
 * @stable ICU 2.0
 */</span>
U_STABLE <span class="enscript-type">void</span> U_EXPORT2 <span class="enscript-function-name">UCNV_FROM_U_CALLBACK_SKIP</span> (
                  <span class="enscript-type">const</span> <span class="enscript-type">void</span> *context,
                  UConverterFromUnicodeArgs *fromUArgs,
                  <span class="enscript-type">const</span> UChar* codeUnits,
                  int32_t length,
                  UChar32 codePoint,
                  UConverterCallbackReason reason,
                  UErrorCode * err);

<span class="enscript-comment">/**
 * DO NOT CALL THIS FUNCTION DIRECTLY!
 * This From Unicode callback will Substitute the ILLEGAL SEQUENCE, or 
 * UNASSIGNED_SEQUENCE depending on context parameter, with the
 * current substitution string for the converter. This is the default
 * callback.
 *
 * @param context The function currently recognizes the callback options:
 *                 UCNV_SUB_STOP_ON_ILLEGAL: STOPS at the ILLEGAL_SEQUENCE,
 *                      returning the error code back to the caller immediately.
 *                 NULL: Substitutes any ILLEGAL_SEQUENCE
 * @param fromUArgs Information about the conversion in progress
 * @param codeUnits Points to 'length' UChars of the concerned Unicode sequence
 * @param length Size (in bytes) of the concerned codepage sequence
 * @param codePoint Single UChar32 (UTF-32) containing the concerend Unicode codepoint.
 * @param reason Defines the reason the callback was invoked
 * @param err Return value will be set to success if the callback was handled,
 *      otherwise this value will be set to a failure status.
 * @see ucnv_setSubstChars
 * @stable ICU 2.0
 */</span>
U_STABLE <span class="enscript-type">void</span> U_EXPORT2 <span class="enscript-function-name">UCNV_FROM_U_CALLBACK_SUBSTITUTE</span> (
                  <span class="enscript-type">const</span> <span class="enscript-type">void</span> *context,
                  UConverterFromUnicodeArgs *fromUArgs,
                  <span class="enscript-type">const</span> UChar* codeUnits,
                  int32_t length,
                  UChar32 codePoint,
                  UConverterCallbackReason reason,
                  UErrorCode * err);

<span class="enscript-comment">/**
 * DO NOT CALL THIS FUNCTION DIRECTLY!
 * This From Unicode callback will Substitute the ILLEGAL SEQUENCE with the
 * hexadecimal representation of the illegal codepoints
 *
 * @param context The function currently recognizes the callback options:
 *        &lt;ul&gt;
 *        &lt;li&gt;UCNV_ESCAPE_ICU: Substitues the  ILLEGAL SEQUENCE with the hexadecimal 
 *          representation in the format  %UXXXX, e.g. &quot;%uFFFE%u00AC%uC8FE&quot;). 
 *          In the Event the converter doesn't support the characters {%,U}[A-F][0-9], 
 *          it will  substitute  the illegal sequence with the substitution characters.
 *          Note that  codeUnit(32bit int eg: unit of a surrogate pair) is represented as
 *          %UD84D%UDC56&lt;/li&gt;
 *        &lt;li&gt;UCNV_ESCAPE_JAVA: Substitues the  ILLEGAL SEQUENCE with the hexadecimal 
 *          representation in the format  \\uXXXX, e.g. &quot;\\uFFFE\\u00AC\\uC8FE&quot;). 
 *          In the Event the converter doesn't support the characters {\,u}[A-F][0-9], 
 *          it will  substitute  the illegal sequence with the substitution characters.
 *          Note that  codeUnit(32bit int eg: unit of a surrogate pair) is represented as
 *          \\uD84D\\uDC56&lt;/li&gt;
 *        &lt;li&gt;UCNV_ESCAPE_C: Substitues the  ILLEGAL SEQUENCE with the hexadecimal 
 *          representation in the format  \\uXXXX, e.g. &quot;\\uFFFE\\u00AC\\uC8FE&quot;). 
 *          In the Event the converter doesn't support the characters {\,u,U}[A-F][0-9], 
 *          it will  substitute  the illegal sequence with the substitution characters.
 *          Note that  codeUnit(32bit int eg: unit of a surrogate pair) is represented as
 *          \\U00023456&lt;/li&gt;
 *        &lt;li&gt;UCNV_ESCAPE_XML_DEC: Substitues the  ILLEGAL SEQUENCE with the decimal 
 *          representation in the format  &amp;amp;#DDDDDDDD;, e.g. &quot;&amp;amp;#65534;&amp;amp;#172;&amp;amp;#51454;&quot;). 
 *          In the Event the converter doesn't support the characters {&amp;amp;,#}[0-9], 
 *          it will  substitute  the illegal sequence with the substitution characters.
 *          Note that  codeUnit(32bit int eg: unit of a surrogate pair) is represented as
 *          &amp;amp;#144470; and Zero padding is ignored.&lt;/li&gt;
 *        &lt;li&gt;UCNV_ESCAPE_XML_HEX:Substitues the  ILLEGAL SEQUENCE with the decimal 
 *          representation in the format  &amp;#xXXXX, e.g. &quot;&amp;amp;#xFFFE;&amp;amp;#x00AC;&amp;amp;#xC8FE;&quot;). 
 *          In the Event the converter doesn't support the characters {&amp;,#,x}[0-9], 
 *          it will  substitute  the illegal sequence with the substitution characters.
 *          Note that  codeUnit(32bit int eg: unit of a surrogate pair) is represented as
 *          &amp;amp;#x23456;&lt;/li&gt;
 *        &lt;/ul&gt;
 * @param fromUArgs Information about the conversion in progress
 * @param codeUnits Points to 'length' UChars of the concerned Unicode sequence
 * @param length Size (in bytes) of the concerned codepage sequence
 * @param codePoint Single UChar32 (UTF-32) containing the concerend Unicode codepoint.
 * @param reason Defines the reason the callback was invoked
 * @param err Return value will be set to success if the callback was handled,
 *      otherwise this value will be set to a failure status.
 * @stable ICU 2.0
 */</span>
U_STABLE <span class="enscript-type">void</span> U_EXPORT2 <span class="enscript-function-name">UCNV_FROM_U_CALLBACK_ESCAPE</span> (
                  <span class="enscript-type">const</span> <span class="enscript-type">void</span> *context,
                  UConverterFromUnicodeArgs *fromUArgs,
                  <span class="enscript-type">const</span> UChar* codeUnits,
                  int32_t length,
                  UChar32 codePoint,
                  UConverterCallbackReason reason,
                  UErrorCode * err);


<span class="enscript-comment">/**
 * DO NOT CALL THIS FUNCTION DIRECTLY!
 * This To Unicode callback skips any ILLEGAL_SEQUENCE, or
 * skips only UNASSINGED_SEQUENCE depending on the context parameter
 * simply ignoring those characters. 
 *
 * @param context  The function currently recognizes the callback options:
 *                 UCNV_SKIP_STOP_ON_ILLEGAL: STOPS at the ILLEGAL_SEQUENCE,
 *                      returning the error code back to the caller immediately.
 *                 NULL: Skips any ILLEGAL_SEQUENCE
 * @param toUArgs Information about the conversion in progress
 * @param codeUnits Points to 'length' bytes of the concerned codepage sequence
 * @param length Size (in bytes) of the concerned codepage sequence
 * @param reason Defines the reason the callback was invoked
 * @param err Return value will be set to success if the callback was handled,
 *      otherwise this value will be set to a failure status.
 * @stable ICU 2.0
 */</span>
U_STABLE <span class="enscript-type">void</span> U_EXPORT2 <span class="enscript-function-name">UCNV_TO_U_CALLBACK_SKIP</span> (
                  <span class="enscript-type">const</span> <span class="enscript-type">void</span> *context,
                  UConverterToUnicodeArgs *toUArgs,
                  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* codeUnits,
                  int32_t length,
                  UConverterCallbackReason reason,
                  UErrorCode * err);

<span class="enscript-comment">/**
 * DO NOT CALL THIS FUNCTION DIRECTLY!
 * This To Unicode callback will Substitute the ILLEGAL SEQUENCE,or 
 * UNASSIGNED_SEQUENCE depending on context parameter,  with the
 * Unicode substitution character, U+FFFD.
 *
 * @param context  The function currently recognizes the callback options:
 *                 UCNV_SUB_STOP_ON_ILLEGAL: STOPS at the ILLEGAL_SEQUENCE,
 *                      returning the error code back to the caller immediately.
 *                 NULL: Substitutes any ILLEGAL_SEQUENCE
 * @param toUArgs Information about the conversion in progress
 * @param codeUnits Points to 'length' bytes of the concerned codepage sequence
 * @param length Size (in bytes) of the concerned codepage sequence
 * @param reason Defines the reason the callback was invoked
 * @param err Return value will be set to success if the callback was handled,
 *      otherwise this value will be set to a failure status.
 * @stable ICU 2.0
 */</span>
U_STABLE <span class="enscript-type">void</span> U_EXPORT2 <span class="enscript-function-name">UCNV_TO_U_CALLBACK_SUBSTITUTE</span> (
                  <span class="enscript-type">const</span> <span class="enscript-type">void</span> *context,
                  UConverterToUnicodeArgs *toUArgs,
                  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* codeUnits,
                  int32_t length,
                  UConverterCallbackReason reason,
                  UErrorCode * err);

<span class="enscript-comment">/**
 * DO NOT CALL THIS FUNCTION DIRECTLY!
 * This To Unicode callback will Substitute the ILLEGAL SEQUENCE with the
 * hexadecimal representation of the illegal bytes
 *  (in the format  %XNN, e.g. &quot;%XFF%X0A%XC8%X03&quot;).
 *
 * @param context This function currently recognizes the callback options:
 *      UCNV_ESCAPE_ICU, UCNV_ESCAPE_JAVA, UCNV_ESCAPE_C, UCNV_ESCAPE_XML_DEC,
 *      UCNV_ESCAPE_XML_HEX and UCNV_ESCAPE_UNICODE.
 * @param toUArgs Information about the conversion in progress
 * @param codeUnits Points to 'length' bytes of the concerned codepage sequence
 * @param length Size (in bytes) of the concerned codepage sequence
 * @param reason Defines the reason the callback was invoked
 * @param err Return value will be set to success if the callback was handled,
 *      otherwise this value will be set to a failure status.
 * @stable ICU 2.0
 */</span>

U_STABLE <span class="enscript-type">void</span> U_EXPORT2 <span class="enscript-function-name">UCNV_TO_U_CALLBACK_ESCAPE</span> (
                  <span class="enscript-type">const</span> <span class="enscript-type">void</span> *context,
                  UConverterToUnicodeArgs *toUArgs,
                  <span class="enscript-type">const</span> <span class="enscript-type">char</span>* codeUnits,
                  int32_t length,
                  UConverterCallbackReason reason,
                  UErrorCode * err);

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*UCNV_ERR_H*/</span> 
</pre>
<hr />
</body></html>