<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>utf16.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">utf16.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
*******************************************************************************
*
*   Copyright (C) 1999-2004, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*   file name:  utf16.h
*   encoding:   US-ASCII
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 1999sep09
*   created by: Markus W. Scherer
*/</span>

<span class="enscript-comment">/**
 * \file
 * \brief C API: 16-bit Unicode handling macros
 * 
 * This file defines macros to deal with 16-bit Unicode (UTF-16) code units and strings.
 * utf16.h is included by utf.h after unicode/umachine.h
 * and some common definitions.
 *
 * For more information see utf.h and the ICU User Guide Strings chapter
 * (<a href="http://oss.software.ibm.com/icu/userguide/">http://oss.software.ibm.com/icu/userguide/</a>).
 *
 * &lt;em&gt;Usage:&lt;/em&gt;
 * ICU coding guidelines for if() statements should be followed when using these macros.
 * Compound statements (curly braces {}) must be used  for if-else-while... 
 * bodies and all macro statements should be terminated with semicolon.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__UTF16_H__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__UTF16_H__</span>

<span class="enscript-comment">/* utf.h must be included first. */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__UTF_H__</span>
#   <span class="enscript-reference">include</span> <span class="enscript-string">&quot;unicode/utf.h&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* single-code point definitions -------------------------------------------- */</span>

<span class="enscript-comment">/**
 * Does this code unit alone encode a code point (BMP, not a surrogate)?
 * @param c 16-bit code unit
 * @return TRUE or FALSE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_IS_SINGLE</span>(c) !U_IS_SURROGATE(c)

<span class="enscript-comment">/**
 * Is this code unit a lead surrogate (U+d800..U+dbff)?
 * @param c 16-bit code unit
 * @return TRUE or FALSE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_IS_LEAD</span>(c) (((c)&amp;0xfffffc00)==0xd800)

<span class="enscript-comment">/**
 * Is this code unit a trail surrogate (U+dc00..U+dfff)?
 * @param c 16-bit code unit
 * @return TRUE or FALSE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_IS_TRAIL</span>(c) (((c)&amp;0xfffffc00)==0xdc00)

<span class="enscript-comment">/**
 * Is this code unit a surrogate (U+d800..U+dfff)?
 * @param c 16-bit code unit
 * @return TRUE or FALSE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_IS_SURROGATE</span>(c) U_IS_SURROGATE(c)

<span class="enscript-comment">/**
 * Assuming c is a surrogate code point (U16_IS_SURROGATE(c)),
 * is it a lead surrogate?
 * @param c 16-bit code unit
 * @return TRUE or FALSE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_IS_SURROGATE_LEAD</span>(c) (((c)&amp;0x400)==0)

<span class="enscript-comment">/**
 * Helper constant for U16_GET_SUPPLEMENTARY.
 * @internal
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">U16_SURROGATE_OFFSET</span> ((0xd800&lt;&lt;10UL)+0xdc00-0x10000)

<span class="enscript-comment">/**
 * Get a supplementary code point value (U+10000..U+10ffff)
 * from its lead and trail surrogates.
 * The result is undefined if the input values are not
 * lead and trail surrogates.
 *
 * @param lead lead surrogate (U+d800..U+dbff)
 * @param trail trail surrogate (U+dc00..U+dfff)
 * @return supplementary code point (U+10000..U+10ffff)
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_GET_SUPPLEMENTARY</span>(lead, trail) \
    (((UChar32)(lead)&lt;&lt;10UL)+(UChar32)(trail)-U16_SURROGATE_OFFSET)


<span class="enscript-comment">/**
 * Get the lead surrogate (0xd800..0xdbff) for a
 * supplementary code point (0x10000..0x10ffff).
 * @param supplementary 32-bit code point (U+10000..U+10ffff)
 * @return lead surrogate (U+d800..U+dbff) for supplementary
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_LEAD</span>(supplementary) (UChar)(((supplementary)&gt;&gt;10)+0xd7c0)

<span class="enscript-comment">/**
 * Get the trail surrogate (0xdc00..0xdfff) for a
 * supplementary code point (0x10000..0x10ffff).
 * @param supplementary 32-bit code point (U+10000..U+10ffff)
 * @return trail surrogate (U+dc00..U+dfff) for supplementary
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_TRAIL</span>(supplementary) (UChar)(((supplementary)&amp;0x3ff)|0xdc00)

<span class="enscript-comment">/**
 * How many 16-bit code units are used to encode this Unicode code point? (1 or 2)
 * The result is not defined if c is not a Unicode code point (U+0000..U+10ffff).
 * @param c 32-bit code point
 * @return 1 or 2
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_LENGTH</span>(c) ((uint32_t)(c)&lt;=0xffff ? 1 : 2)

<span class="enscript-comment">/**
 * The maximum number of 16-bit code units per Unicode code point (U+0000..U+10ffff).
 * @return 2
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">U16_MAX_LENGTH</span> 2

<span class="enscript-comment">/**
 * Get a code point from a string at a random-access offset,
 * without changing the offset.
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-16.
 *
 * The offset may point to either the lead or trail surrogate unit
 * for a supplementary code point, in which case the macro will read
 * the adjacent matching surrogate as well.
 * The result is undefined if the offset points to a single, unpaired surrogate.
 * Iteration through a string is more efficient with U16_NEXT_UNSAFE or U16_NEXT.
 *
 * @param s const UChar * string
 * @param i string offset
 * @param c output UChar32 variable
 * @see U16_GET
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_GET_UNSAFE</span>(s, i, c) { \
    (c)=(s)[i]; \
    <span class="enscript-keyword">if</span>(U16_IS_SURROGATE(c)) { \
        <span class="enscript-keyword">if</span>(U16_IS_SURROGATE_LEAD(c)) { \
            (c)=U16_GET_SUPPLEMENTARY((c), (s)[(i)+1]); \
        } <span class="enscript-keyword">else</span> { \
            (c)=U16_GET_SUPPLEMENTARY((s)[(i)-1], (c)); \
        } \
    } \
}

<span class="enscript-comment">/**
 * Get a code point from a string at a random-access offset,
 * without changing the offset.
 * &quot;Safe&quot; macro, handles unpaired surrogates and checks for string boundaries.
 *
 * The offset may point to either the lead or trail surrogate unit
 * for a supplementary code point, in which case the macro will read
 * the adjacent matching surrogate as well.
 * If the offset points to a single, unpaired surrogate, then that itself
 * will be returned as the code point.
 * Iteration through a string is more efficient with U16_NEXT_UNSAFE or U16_NEXT.
 *
 * @param s const UChar * string
 * @param start starting string offset (usually 0)
 * @param i string offset, start&lt;=i&lt;length
 * @param length string length
 * @param c output UChar32 variable
 * @see U16_GET_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_GET</span>(s, start, i, length, c) { \
    (c)=(s)[i]; \
    <span class="enscript-keyword">if</span>(U16_IS_SURROGATE(c)) { \
        uint16_t __c2; \
        <span class="enscript-keyword">if</span>(U16_IS_SURROGATE_LEAD(c)) { \
            <span class="enscript-keyword">if</span>((i)+1&lt;(length) &amp;&amp; U16_IS_TRAIL(__c2=(s)[(i)+1])) { \
                (c)=U16_GET_SUPPLEMENTARY((c), __c2); \
            } \
        } <span class="enscript-keyword">else</span> { \
            <span class="enscript-keyword">if</span>((i)-1&gt;=(start) &amp;&amp; U16_IS_LEAD(__c2=(s)[(i)-1])) { \
                (c)=U16_GET_SUPPLEMENTARY(__c2, (c)); \
            } \
        } \
    } \
}

<span class="enscript-comment">/* definitions with forward iteration --------------------------------------- */</span>

<span class="enscript-comment">/**
 * Get a code point from a string at a code point boundary offset,
 * and advance the offset to the next code point boundary.
 * (Post-incrementing forward iteration.)
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-16.
 *
 * The offset may point to the lead surrogate unit
 * for a supplementary code point, in which case the macro will read
 * the following trail surrogate as well.
 * If the offset points to a trail surrogate, then that itself
 * will be returned as the code point.
 * The result is undefined if the offset points to a single, unpaired lead surrogate.
 *
 * @param s const UChar * string
 * @param i string offset
 * @param c output UChar32 variable
 * @see U16_NEXT
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_NEXT_UNSAFE</span>(s, i, c) { \
    (c)=(s)[(i)++]; \
    <span class="enscript-keyword">if</span>(U16_IS_LEAD(c)) { \
        (c)=U16_GET_SUPPLEMENTARY((c), (s)[(i)++]); \
    } \
}

<span class="enscript-comment">/**
 * Get a code point from a string at a code point boundary offset,
 * and advance the offset to the next code point boundary.
 * (Post-incrementing forward iteration.)
 * &quot;Safe&quot; macro, handles unpaired surrogates and checks for string boundaries.
 *
 * The offset may point to the lead surrogate unit
 * for a supplementary code point, in which case the macro will read
 * the following trail surrogate as well.
 * If the offset points to a trail surrogate or
 * to a single, unpaired lead surrogate, then that itself
 * will be returned as the code point.
 *
 * @param s const UChar * string
 * @param i string offset, i&lt;length
 * @param length string length
 * @param c output UChar32 variable
 * @see U16_NEXT_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_NEXT</span>(s, i, length, c) { \
    (c)=(s)[(i)++]; \
    <span class="enscript-keyword">if</span>(U16_IS_LEAD(c)) { \
        uint16_t __c2; \
        <span class="enscript-keyword">if</span>((i)&lt;(length) &amp;&amp; U16_IS_TRAIL(__c2=(s)[(i)])) { \
            ++(i); \
            (c)=U16_GET_SUPPLEMENTARY((c), __c2); \
        } \
    } \
}

<span class="enscript-comment">/**
 * Append a code point to a string, overwriting 1 or 2 code units.
 * The offset points to the current end of the string contents
 * and is advanced (post-increment).
 * &quot;Unsafe&quot; macro, assumes a valid code point and sufficient space in the string.
 * Otherwise, the result is undefined.
 *
 * @param s const UChar * string buffer
 * @param i string offset
 * @param c code point to append
 * @see U16_APPEND
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_APPEND_UNSAFE</span>(s, i, c) { \
    <span class="enscript-keyword">if</span>((uint32_t)(c)&lt;=0xffff) { \
        (s)[(i)++]=(uint16_t)(c); \
    } <span class="enscript-keyword">else</span> { \
        (s)[(i)++]=(uint16_t)(((c)&gt;&gt;10)+0xd7c0); \
        (s)[(i)++]=(uint16_t)(((c)&amp;0x3ff)|0xdc00); \
    } \
}

<span class="enscript-comment">/**
 * Append a code point to a string, overwriting 1 or 2 code units.
 * The offset points to the current end of the string contents
 * and is advanced (post-increment).
 * &quot;Safe&quot; macro, checks for a valid code point.
 * If a surrogate pair is written, checks for sufficient space in the string.
 * If the code point is not valid or a trail surrogate does not fit,
 * then isError is set to TRUE.
 *
 * @param s const UChar * string buffer
 * @param i string offset, i&lt;length
 * @param capacity size of the string buffer
 * @param c code point to append
 * @param isError output UBool set to TRUE if an error occurs, otherwise not modified
 * @see U16_APPEND_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_APPEND</span>(s, i, capacity, c, isError) { \
    <span class="enscript-keyword">if</span>((uint32_t)(c)&lt;=0xffff) { \
        (s)[(i)++]=(uint16_t)(c); \
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>((uint32_t)(c)&lt;=0x10ffff &amp;&amp; (i)+1&lt;(capacity)) { \
        (s)[(i)++]=(uint16_t)(((c)&gt;&gt;10)+0xd7c0); \
        (s)[(i)++]=(uint16_t)(((c)&amp;0x3ff)|0xdc00); \
    } <span class="enscript-keyword">else</span> <span class="enscript-comment">/* c&gt;0x10ffff or not enough space */</span> { \
        (isError)=TRUE; \
    } \
}

<span class="enscript-comment">/**
 * Advance the string offset from one code point boundary to the next.
 * (Post-incrementing iteration.)
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-16.
 *
 * @param s const UChar * string
 * @param i string offset
 * @see U16_FWD_1
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_FWD_1_UNSAFE</span>(s, i) { \
    <span class="enscript-keyword">if</span>(U16_IS_LEAD((s)[(i)++])) { \
        ++(i); \
    } \
}

<span class="enscript-comment">/**
 * Advance the string offset from one code point boundary to the next.
 * (Post-incrementing iteration.)
 * &quot;Safe&quot; macro, handles unpaired surrogates and checks for string boundaries.
 *
 * @param s const UChar * string
 * @param i string offset, i&lt;length
 * @param length string length
 * @see U16_FWD_1_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_FWD_1</span>(s, i, length) { \
    <span class="enscript-keyword">if</span>(U16_IS_LEAD((s)[(i)++]) &amp;&amp; (i)&lt;(length) &amp;&amp; U16_IS_TRAIL((s)[i])) { \
        ++(i); \
    } \
}

<span class="enscript-comment">/**
 * Advance the string offset from one code point boundary to the n-th next one,
 * i.e., move forward by n code points.
 * (Post-incrementing iteration.)
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-16.
 *
 * @param s const UChar * string
 * @param i string offset
 * @param n number of code points to skip
 * @see U16_FWD_N
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_FWD_N_UNSAFE</span>(s, i, n) { \
    int32_t __N=(n); \
    <span class="enscript-keyword">while</span>(__N&gt;0) { \
        U16_FWD_1_UNSAFE(s, i); \
        --__N; \
    } \
}

<span class="enscript-comment">/**
 * Advance the string offset from one code point boundary to the n-th next one,
 * i.e., move forward by n code points.
 * (Post-incrementing iteration.)
 * &quot;Safe&quot; macro, handles unpaired surrogates and checks for string boundaries.
 *
 * @param s const UChar * string
 * @param i string offset, i&lt;length
 * @param length string length
 * @param n number of code points to skip
 * @see U16_FWD_N_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_FWD_N</span>(s, i, length, n) { \
    int32_t __N=(n); \
    <span class="enscript-keyword">while</span>(__N&gt;0 &amp;&amp; (i)&lt;(length)) { \
        U16_FWD_1(s, i, length); \
        --__N; \
    } \
}

<span class="enscript-comment">/**
 * Adjust a random-access offset to a code point boundary
 * at the start of a code point.
 * If the offset points to the trail surrogate of a surrogate pair,
 * then the offset is decremented.
 * Otherwise, it is not modified.
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-16.
 *
 * @param s const UChar * string
 * @param i string offset
 * @see U16_SET_CP_START
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_SET_CP_START_UNSAFE</span>(s, i) { \
    <span class="enscript-keyword">if</span>(U16_IS_TRAIL((s)[i])) { \
        --(i); \
    } \
}

<span class="enscript-comment">/**
 * Adjust a random-access offset to a code point boundary
 * at the start of a code point.
 * If the offset points to the trail surrogate of a surrogate pair,
 * then the offset is decremented.
 * Otherwise, it is not modified.
 * &quot;Safe&quot; macro, handles unpaired surrogates and checks for string boundaries.
 *
 * @param s const UChar * string
 * @param start starting string offset (usually 0)
 * @param i string offset, start&lt;=i
 * @see U16_SET_CP_START_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_SET_CP_START</span>(s, start, i) { \
    <span class="enscript-keyword">if</span>(U16_IS_TRAIL((s)[i]) &amp;&amp; (i)&gt;(start) &amp;&amp; U16_IS_LEAD((s)[(i)-1])) { \
        --(i); \
    } \
}

<span class="enscript-comment">/* definitions with backward iteration -------------------------------------- */</span>

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the previous one
 * and get the code point between them.
 * (Pre-decrementing backward iteration.)
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-16.
 *
 * The input offset may be the same as the string length.
 * If the offset is behind a trail surrogate unit
 * for a supplementary code point, then the macro will read
 * the preceding lead surrogate as well.
 * If the offset is behind a lead surrogate, then that itself
 * will be returned as the code point.
 * The result is undefined if the offset is behind a single, unpaired trail surrogate.
 *
 * @param s const UChar * string
 * @param i string offset
 * @param c output UChar32 variable
 * @see U16_PREV
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_PREV_UNSAFE</span>(s, i, c) { \
    (c)=(s)[--(i)]; \
    <span class="enscript-keyword">if</span>(U16_IS_TRAIL(c)) { \
        (c)=U16_GET_SUPPLEMENTARY((s)[--(i)], (c)); \
    } \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the previous one
 * and get the code point between them.
 * (Pre-decrementing backward iteration.)
 * &quot;Safe&quot; macro, handles unpaired surrogates and checks for string boundaries.
 *
 * The input offset may be the same as the string length.
 * If the offset is behind a trail surrogate unit
 * for a supplementary code point, then the macro will read
 * the preceding lead surrogate as well.
 * If the offset is behind a lead surrogate or behind a single, unpaired
 * trail surrogate, then that itself
 * will be returned as the code point.
 *
 * @param s const UChar * string
 * @param start starting string offset (usually 0)
 * @param i string offset, start&lt;=i
 * @param c output UChar32 variable
 * @see U16_PREV_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_PREV</span>(s, start, i, c) { \
    (c)=(s)[--(i)]; \
    <span class="enscript-keyword">if</span>(U16_IS_TRAIL(c)) { \
        uint16_t __c2; \
        <span class="enscript-keyword">if</span>((i)&gt;(start) &amp;&amp; U16_IS_LEAD(__c2=(s)[(i)-1])) { \
            --(i); \
            (c)=U16_GET_SUPPLEMENTARY(__c2, (c)); \
        } \
    } \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the previous one.
 * (Pre-decrementing backward iteration.)
 * The input offset may be the same as the string length.
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-16.
 *
 * @param s const UChar * string
 * @param i string offset
 * @see U16_BACK_1
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_BACK_1_UNSAFE</span>(s, i) { \
    <span class="enscript-keyword">if</span>(U16_IS_TRAIL((s)[--(i)])) { \
        --(i); \
    } \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the previous one.
 * (Pre-decrementing backward iteration.)
 * The input offset may be the same as the string length.
 * &quot;Safe&quot; macro, handles unpaired surrogates and checks for string boundaries.
 *
 * @param s const UChar * string
 * @param start starting string offset (usually 0)
 * @param i string offset, start&lt;=i
 * @see U16_BACK_1_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_BACK_1</span>(s, start, i) { \
    <span class="enscript-keyword">if</span>(U16_IS_TRAIL((s)[--(i)]) &amp;&amp; (i)&gt;(start) &amp;&amp; U16_IS_LEAD((s)[(i)-1])) { \
        --(i); \
    } \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the n-th one before it,
 * i.e., move backward by n code points.
 * (Pre-decrementing backward iteration.)
 * The input offset may be the same as the string length.
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-16.
 *
 * @param s const UChar * string
 * @param i string offset
 * @param n number of code points to skip
 * @see U16_BACK_N
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_BACK_N_UNSAFE</span>(s, i, n) { \
    int32_t __N=(n); \
    <span class="enscript-keyword">while</span>(__N&gt;0) { \
        U16_BACK_1_UNSAFE(s, i); \
        --__N; \
    } \
}

<span class="enscript-comment">/**
 * Move the string offset from one code point boundary to the n-th one before it,
 * i.e., move backward by n code points.
 * (Pre-decrementing backward iteration.)
 * The input offset may be the same as the string length.
 * &quot;Safe&quot; macro, handles unpaired surrogates and checks for string boundaries.
 *
 * @param s const UChar * string
 * @param start start of string
 * @param i string offset, i&lt;length
 * @param n number of code points to skip
 * @see U16_BACK_N_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_BACK_N</span>(s, start, i, n) { \
    int32_t __N=(n); \
    <span class="enscript-keyword">while</span>(__N&gt;0 &amp;&amp; (i)&gt;(start)) { \
        U16_BACK_1(s, start, i); \
        --__N; \
    } \
}

<span class="enscript-comment">/**
 * Adjust a random-access offset to a code point boundary after a code point.
 * If the offset is behind the lead surrogate of a surrogate pair,
 * then the offset is incremented.
 * Otherwise, it is not modified.
 * The input offset may be the same as the string length.
 * &quot;Unsafe&quot; macro, assumes well-formed UTF-16.
 *
 * @param s const UChar * string
 * @param i string offset
 * @see U16_SET_CP_LIMIT
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_SET_CP_LIMIT_UNSAFE</span>(s, i) { \
    <span class="enscript-keyword">if</span>(U16_IS_LEAD((s)[(i)-1])) { \
        ++(i); \
    } \
}

<span class="enscript-comment">/**
 * Adjust a random-access offset to a code point boundary after a code point.
 * If the offset is behind the lead surrogate of a surrogate pair,
 * then the offset is incremented.
 * Otherwise, it is not modified.
 * The input offset may be the same as the string length.
 * &quot;Safe&quot; macro, handles unpaired surrogates and checks for string boundaries.
 *
 * @param s const UChar * string
 * @param start starting string offset (usually 0)
 * @param i string offset, start&lt;=i&lt;=length
 * @param length string length
 * @see U16_SET_CP_LIMIT_UNSAFE
 * @stable ICU 2.4
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">U16_SET_CP_LIMIT</span>(s, start, i, length) { \
    <span class="enscript-keyword">if</span>((start)&lt;(i) &amp;&amp; (i)&lt;(length) &amp;&amp; U16_IS_LEAD((s)[(i)-1]) &amp;&amp; U16_IS_TRAIL((s)[i])) { \
        ++(i); \
    } \
}

#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>